{"result":[{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Provides diagnostic logging utilities","source":"","sys_updated_on":"2017-08-22 18:19:20","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"030416e72f3332001144839fb18c95e3","sys_updated_by":"admin","sys_created_on":"2017-07-12 23:43:59","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"DiagnosticsUtil.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"arturo.ma","sys_mod_count":"12","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"# Global variables\r\n$global:SncLogPrefix = \"<SNC_LOG>\"\r\n$global:SncLogSuffix = \"</SNC_LOG>\"\r\n\r\n<# \r\n .Synopsis\r\n  SNCLog-DebugInfo.\r\n\r\n .Description\r\n Log message\r\n\r\n .Parameter message\r\n  message to log\r\n\r\n .Example\r\n   # Log a debug message\r\n  SNCLog-DebugInfo -Message \"My debug message\"\r\n\r\n Requires -Version 2.0\r\n#>\r\nfunction SNCLog-DebugInfo {\r\n\tparam(\r\n\t\t[Parameter(Mandatory=$false)] [String]$message = ''\r\n\t);\r\n\r\n\tif ($global:logInfo -eq $False) {\r\n\t\treturn\r\n\t}\r\n\r\n\tif ([string]::IsNullOrEmpty($message)) {\r\n\t\treturn\r\n\t}\r\n\r\n\t$timeStamp = SNCGet-TimeStamp\r\n\t$outputMsg = \"{0}{1} {2}{3}\" -f $global:SncLogPrefix, $timeStamp, $message, $global:SncLogSuffix\r\n\tWrite-Host \"$outputMsg\"\r\n}\r\n\r\n<# \r\n .Synopsis\r\n  SNCLog-ParameterInfo.\r\n\r\n .Description\r\n Log script/function parameters\r\n\r\n .Example\r\n  SNCLog-ParameterInfo @(\"Running Exchange-RemoveMailbox\", $exchangeServer, $domain, $parameters)\r\n\r\n Requires -Version 2.0\r\n#>\r\nfunction SNCLog-ParameterInfo {\r\n\tif ($global:logInfo -eq $False) {\r\n\t\treturn\r\n\t}\r\n\r\n\t$paramInfo = \"\"\r\n\tforeach ($arg in $args) {\r\n\t\t\tif ($paramInfo.length -gt 0) {\r\n\t\t\t\t$paramInfo += \"`t\"\r\n\t\t\t}\r\n\t\t\t$paramInfo += $arg ;\r\n\t}\r\n\tSNCLog-DebugInfo \"$paramInfo\"\r\n}\r\n\r\n<# \r\n .Synopsis\r\n  SNCObfuscate-Value\r\n\r\n .Description\r\n  Hides the true value by replacing it with '***'\r\n\r\n .Parameter theString\r\n  String to obfuscate\r\n\r\n .Parameter position\r\n  The position to start to obfuscate the string\r\n\r\n .Example\r\n  SNCObfuscate-Value myPassword will return ***\r\n#>\r\nfunction SNCObfuscate-Value {\r\n\tparam(\r\n\t\t[Parameter(Mandatory = $false)][String]$theString = '',\r\n\r\n\t\t[Parameter(Mandatory=$false)][int]$position = 0\r\n\t);\r\n\r\n\tif ([string]::IsNullOrEmpty($theString)) {\r\n\t\tSNCLog-DebugInfo \"Received a null or empty string\"\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif ($position -gt 0 -and $position -lt $theString.length) {\r\n\t\t$firstPart = $theString.Substring(0, $position)\r\n\t\t$secondPart = $theString.Substring($position)\r\n\t\t$hidden = $secondPart  -replace \"\\w\", '*'\r\n\t\t$hidden = $hidden  -replace \"\\W\", '*'\r\n\t\t$starred =  $firstPart + $hidden\r\n\t} else {\r\n\t\t$starred = \"***\"\r\n\t}\r\n\treturn $starred\r\n}\r\n\r\n<# \r\n .Synopsis\r\n  SNCGet-TimeMillis\r\n\r\n .Description\r\n  Returns the current Unix epoch time in msecs\r\n\r\n .Example\r\n  SNCGet-TimeMillis\r\n#>\r\nfunction SNCGet-TimeMillis {\r\n\r\n\t$currTimeInMs = [long]([double](Get-Date -uFormat %s)*1000)\r\n\treturn $currTimeInMs\r\n}\r\n\r\nfunction SNCGet-TimeStamp {\r\n\t$dateStr = Get-Date -format \"yyyy-MM-dd HH:mm:ss\"\r\n\treturn $dateStr\r\n}\r\n\r\nfunction SNCLog-EnvironmentVars {\r\n\tif ($global:logInfo -eq $False) {\r\n\t\treturn\r\n\t}\r\n\r\n\t$evars = @(\"Env vars:\")\r\n\tforeach ($var in ( Get-ChildItem -Path Env:SNC* | Sort-Object Name)) {\r\n\t\t$name = $var.name\r\n\t\t$value = $var.value\r\n\t\tif ($name -NotMatch \"SNCEncryptedVars\" -and $name -NotMatch \"SNC_JVM_ARCH\") {\r\n\t\t\tif ($global:encryptedVars -and $global:encryptedVars.length -gt 0)  {\r\n\t\t\t\tif ($global:encryptedVars -Match $name) {\r\n\t\t\t\t\t$value = SNCObfuscate-Value -theString $var.value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t$var = \"`$env:\" + $name.toString() + \":\" + $value.toString()\r\n\t\t\t$evars += $var\r\n\t\t}\r\n\t}\r\n\t$separator = \"`t\"\r\n\t$vars = [string]::Join($separator, $evars)\r\n\tSNCLog-DebugInfo \"$vars`r`n\"\r\n}\r\n\r\nfunction SNCLog-Variables {\r\n\tif ($global:logInfo -eq $False) {\r\n\t\treturn\r\n\t}\r\n\r\n\t$vars = @(\"`tVars:\")\r\n\tCompare-Object (Get-Variable) $global:AutomaticVariables -Property Name -PassThru `\r\n\t\t| Where-Object {$_.name -ne \"AutomaticVariables\"} `\r\n\t\t| ForEach-Object { `\r\n\t\t\t$name = $_.name;  $val = $_.value; `\r\n\t\t\tif (-Not($_.name.startswith(\"SncLog\")) -and $_.name -ne \"logInfo\" -and `\r\n\t\t\t\t\t$_.name -ne \"EncryptedVars\" -and $_.name -ne \"vars\") { `\r\n\t\t\t\tif ($global:encryptedVars -and $global:encryptedVars.length -gt 0) { `\r\n\t\t\t\t\tif ($global:encryptedVars -like $name) { `\r\n\t\t\t\t\t\t$val = SNCObfuscate-Value -theString $val `\r\n\t\t\t\t\t} `\r\n\t\t\t\t} `\r\n\t\t\t\t$vars += \"`$$name : $val\" `\r\n\t\t\t} `\r\n\t\t}\r\n\t$separator = \"`t\"\r\n\t$theVars = [string]::Join($separator, $vars)\r\n\tSNCLog-DebugInfo \"$theVars`r`n\"\r\n}\r\n\r\n<# \r\n .Synopsis\r\n  SNCGet-CmdParams\r\n\r\n .Description\r\n  Returns a string representation of the command parameters that are stored\r\n  in the hashtable parameter\r\n\r\n .Parameter paramHTable\r\n  Hashtable which contains all the cmdlet parameters\r\n\r\n .Example\r\n  SNCGet-CmdParams $cmdParameters\r\n#>\r\nfunction SNCGet-CmdParams {\r\n\tparam(\r\n\t\t[Parameter(Mandatory=$true)] [hashtable]$paramHTable\r\n\t);\r\n\r\n\tif ($paramHTable -ne $null -and $paramHTable.count -gt 0) {\r\n\t\t$cmdParams = ($paramHTable.GetEnumerator() | % { \"-$($_.Key) $($_.Value)\" }) -join ' '\r\n\t\treturn $cmdParams\r\n\t}\r\n\treturn \"\"\r\n}\r\n\r\n<# \r\n .Synopsis\r\n  SNCLog-PowershellVersion\r\n\r\n .Description\r\n  Logs the PowerShell version\r\n\r\n .Example\r\n  SNCLog-PowershellVersion\r\n#>\r\nfunction SNCLog-PowershellVersion {\r\n\t$PsVersion = $PSVersionTable.PSVersion -as \"String\"\r\n\tSNCLog-DebugInfo \"PowerShell Version: $PsVersion\"\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_030416e72f3332001144839fb18c95e3","name":"DiagnosticsUtil.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/b0c9a9a3370002000e4d03488e41f113","value":"b0c9a9a3370002000e4d03488e41f113"},"description":"","source":"","sys_updated_on":"2015-05-22 20:49:02","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"0dc0eaff370002000e4d03488e41f11f","sys_updated_by":"will.swift","sys_created_on":"2015-05-22 20:49:02","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"RegistryAPI","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"0","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_0dc0eaff370002000e4d03488e41f11f","name":"RegistryAPI","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/b0c9a9a3370002000e4d03488e41f113","value":"b0c9a9a3370002000e4d03488e41f113"},"description":"","source":"","sys_updated_on":"2021-01-04 05:59:53","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"0e991bcf53456010347cddeeff7b1287","sys_updated_by":"cong.thieu","sys_created_on":"2020-12-17 19:57:49","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"JEAUtils","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"cong.thieu","sys_mod_count":"2","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"This directory contains JEA-related utilities","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_0e991bcf53456010347cddeeff7b1287","name":"JEAUtils","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Launches a process and fetches the output of the process captured through stdout - uses an admin share so requires proper access","source":"","sys_updated_on":"2021-04-13 21:44:33","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"1ed24b15376001006b882d465abe5dd1","sys_updated_by":"marjan.marzban","sys_created_on":"2013-04-04 16:40:54","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"LaunchProc.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"jimmy.yuan","sys_mod_count":"158","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"$executingScriptDirectory = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent\r\n\r\n<######################\r\n #  Launch a process against a target computer.  Write the output of that process to the admin temp share on that machine.\r\n #  Access to the machine and the admin share is done using the $cred parameter if there is one.  To get information from\r\n #  the admin temp share, an impersonation context is used for the user of the given credential if there is one.  The default \r\n #  time to wait is about 10 seconds before declaring failure.  That can be changed by the calling script in the\r\n #  parameter $secondsToWait\r\n ######################>\r\nfunction launchProcess {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [string]$command, [int]$secondsToWait = 10, [switch]$UTF8,[string]$remoteBaseDir, [bool]$shouldKillProcess=$false, [bool]$stdErrInStdOut=$false)\r\n\r\n    SNCLog-DebugInfo \"Running launchProcess\"\r\n\r\n    $signature = @\"\r\n    [DllImport(\"advapi32.dll\", SetLastError = true)]\r\n    public static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, ref IntPtr phToken);\r\n\"@;\r\n\r\n    $LogOnUser = Add-Type -memberDefinition $signature -name \"Win32LogOnUser\" -namespace Win32Functions -passThru;\r\n\r\n    [IntPtr]$userToken = [Security.Principal.WindowsIdentity]::GetCurrent().Token;\r\n\r\n    $context = $null\r\n    if ($cred) {\r\n        if ($LogOnUser::LogOnUser($cred.GetNetworkCredential().UserName, $cred.GetNetworkCredential().Domain, $cred.GetNetworkCredential().Password, 9, 0, [ref]$userToken)) {\r\n           $Identity = new-object security.Principal.WindowsIdentity $userToken\r\n           $context = $Identity.Impersonate();\r\n        }\r\n        else {\r\n            # If Domain is empty, try a 2nd time with domain as \"workgroup\"\r\n            if ( $cred.GetNetworkCredential().Domain -eq \"\" ){\r\n                # Attach localhost to the user\r\n                $username = \"localhost\\\" + $cred.GetNetworkCredential().UserName;\r\n                # Rebuild the credentails with the same user, same password but with workgroup as the domain\r\n                $credWithLocalhostDomain = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $cred.password;\r\n                # Calling a recursion with the localhost domain\r\n                SNCLog-DebugInfo \"Failed impersonation first time, trying again with localhost as Domain\";\r\n                launchProcess -computer $computer -cred $credWithLocalhostDomain -command $command -secondsToWait $secondsToWait -remoteBaseDir $remoteBaseDir -shouldKillProcess $shouldKillProcess -stdErrInStdOut $stdErrInStdOut;\r\n                # Make sure to exit the method after the recursion ends\r\n                return;\r\n            }\r\n            $err = \"The impersonation of user $($cred.UserName) failed.\"\r\n            if (-not $stdErrInStdOut) {\r\n                throw $err\r\n            }\r\n            SNCLog-DebugInfo \"$err\";\r\n            return;\r\n        }\r\n    }\r\n   \r\n    $guid = [Guid]::NewGuid().ToString()\r\n\r\n    if ($remoteBaseDir){\r\n        $baseDir = $remoteBaseDir;\r\n    }else{\r\n        $baseDir = getConfigurableParm -variable \"SNC_base_dir\" -defaultvalue \"admin$\\temp\"\r\n    }\r\n    \r\n    # path that the MID server looks for the output file\r\n    $outputFile = \"\\\\$computer\\$baseDir\\psscript_output_$($guid).txt\"\r\n    \r\n    # path that the process on the target writes output to\r\n    $localOutputFile = \"\\\\127.0.0.1\\$baseDir\\psscript_output_$($guid).txt\"\r\n    \r\n    # path that the MID server looks for the error file\r\n    $errorFile = \"\\\\$computer\\$baseDir\\psscript_err_$($guid).txt\"\r\n    \r\n    # path that the process on the target writes errors to\r\n    $localErrorFile = \"\\\\127.0.0.1\\$baseDir\\psscript_err_$($guid).txt\"\r\n\r\n    $items = $command -split \" \";\r\n    $mainCommand = $items[0];\r\n    \r\n    # In case we need the StdErr in the the StdOut - for example: WMI operations for patterns\r\n    if (-not $stdErrInStdOut){\r\n        $commandWithSuffix = \"$command > `\"$localOutputFile`\" 2>`\"$localErrorFile`\"\";\r\n    } else {\r\n        $commandWithSuffix = \"$command > `\"$localOutputFile`\" 2>&1\";\r\n    }\r\n\r\n    # need to wrap everything after /c in double quotes so the following commands, including any piping\r\n    # should be treated as one command.  wrapping with double quotes is needed since if $command starts with a\r\n    # quote character, cmd will remove the starting char and the last quote character. (see cmd /?)\r\n    if ($UTF8) {\r\n        # changes code page to 65001 so that unicode characters are written to the output file properly\r\n        # need to wrap the files with quotes in case they have spaces in them\r\n        $fullCommand = \"cmd /c `\"chcp 65001 & $commandWithSuffix`\"\";\r\n    } else {\r\n        $fullCommand = \"cmd /c `\"$commandWithSuffix`\"\";\r\n    }\r\n\r\n    SNCLog-DebugInfo \"`t`$fullCommand: $fullCommand\"\r\n    $commandLength = $fullCommand.length;\r\n    if ($fullCommand.length -gt 8191) {\r\n        $errMsg = \"launchProcess command has length $commandLength, which exceeds the command line max length of 8191.\";\r\n        if (-not $stdErrInStdOut){\r\n            throw $errMsg;\r\n        } else {\r\n            write-output $errMsg;\r\n        }\r\n    }\r\n\r\n    if (-not $SNC_session){\r\n        $SNC_session = CreateNewCimSession -Host $computer -Credential $cred;\r\n    }\r\n\r\n    if ($SNC_session){\r\n        SNCLog-DebugInfo \"Using CIM session $SNC_session to invoke CIM Method and create the process\";\r\n        $processInfo = invoke-CimMethod -CimSession $SNC_session -ClassName win32_process -MethodName create -Arguments @{CommandLine=$fullCommand} -EA \"Stop\"\r\n    }\r\n    elseif ($cred) {\r\n        SNCLog-DebugInfo \"Using invoke wmi method with cred to create the process\";\r\n        $processInfo = invoke-wmimethod win32_process -name create -computer $computer -credential $cred -argumentlist $fullCommand -EA \"Stop\"\r\n    } else {\r\n        SNCLog-DebugInfo \"Using invoke wmi method with NO cred to create the process\";\r\n        $processInfo = invoke-wmimethod win32_process -name create -computer $computer -argumentlist $fullCommand -EA \"Stop\"\r\n    }\r\n\r\n   if ($processInfo.ReturnValue -eq 0) {\r\n        $pid = $processInfo.processId\r\n        $proc = getProcess -computer $computer -cred $cred -filter \"processId=$pid\"\r\n\r\n        $date = get-date\r\n        $enddate = $date.AddSeconds($secondsToWait);\r\n\r\n        while ($proc -and ($date -lt $enddate)) {\r\n            Start-Sleep -Milliseconds 250\r\n            $proc = getProcess -computer $computer -cred $cred -filter \"processId=$pid\"\r\n            $date = get-date\r\n        }\r\n        \r\n        if ($proc) {\r\n            $errMsg = \"Command timeout after more than $secondsToWait seconds\";\r\n            cleanup\r\n            if ($shouldKillProcess) {\r\n                # try and kill the process; No need to wait for a response\r\n                $null = launchProcess -computer $computer -cred $cred -command \"taskkill /T /F /PID $pid\";\r\n                $errMsg += \", killing remote process $pid\";\r\n            }\r\n            if (-not $stdErrInStdOut){\r\n                throw $errMsg;\r\n            } else {\r\n                write-output $errMsg;\r\n                return;\r\n            }\r\n        }\r\n        \r\n        $isStdOut = $false;\r\n        if ([System.IO.File]::Exists($outputFile)) {\r\n            # Check the output file size.\r\n            # We often get a 0 bytes file if we have an error.\r\n            $outputFileSize = (Get-ChildItem $outputFile -ErrorAction SilentlyContinue).Length;\r\n            if ($outputFileSize -gt 0){\r\n                $isStdOut = $true;\r\n                \r\n                # Maximize console width so StreamGobbler can gobble \r\n                # more than the 80 character default per line\r\n                mode con lines=1 cols=$([int16]::MaxValue-1);\r\n               \r\n                if ($UTF8) {\r\n                    # grab the contents of the output file and return it as a UTF8 string\r\n                    Get-Content -Path $outputFile -Encoding UTF8 | out-string -width $([int16]::MaxValue);\r\n                } else {\r\n                    # File output is done with the \"type\" shell command.\r\n                    # it was previously done with Get-Content which added a line-break for any line longer than 80 characters, \r\n                    # and \"more\" which had problems with output of unicode.\r\n                    type \"$outputFile\"\r\n                }\r\n            }\r\n            removeFileGracefully -fileName $outputFile\r\n        }\r\n        if ([System.IO.File]::Exists($errorFile)) {\r\n            $errorFileSize = (Get-ChildItem $errorFile -ErrorAction SilentlyContinue).Length;\r\n            if ($errorFileSize -gt 0){\r\n                $err = type $errorFile;\r\n\r\n                if ($err){\r\n                    $errStr = \"\";\r\n                    if ($err -is [System.Object[]]){\r\n                        ForEach ($item In $err) {\r\n                            $errStr += $item + \"`n\";\r\n                        }\r\n                    }\r\n                    else{\r\n                        $errStr = $err;\r\n                    }\r\n                    \r\n                    if ($errStr.indexOf(\"'$mainCommand' is not recognized as an internal or external command\") -eq 0){\r\n                        $errstr = \"Error: $mainCommand is required to complete this operation; Original message: $errStr\";\r\n                    }\r\n                    else{\r\n                        $errstr = \"Error: $errStr\";\r\n                    }\r\n                    \r\n                    # We have both StdOut and StdErr\r\n                    if ($isStdOut){\r\n                        <# Currently write-error cause the probe to fail even when there is an output tag in the payload.\r\n                            A simple example where we do have an StdErr and StdOut - the probe will fail even if we have enough data to continue (for example we failed capturing nice to have data).\r\n                            This should be improved in a future release when we can continue processing the probe data even if we have an error on the payload.\r\n                        #>\r\n                        #write-error $errStr;\r\n                    }else{\r\n                        # Only StdErr no StdOut\r\n                        removeFileGracefully -fileName $errorFile;\r\n                        if (-not $stdErrInStdOut){\r\n                            throw (New-Object -TypeName System.IO.FileNotFoundException -ArgumentList $errstr);\r\n                        } else{\r\n                            write-output $errstr;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            # make sure we clean it\r\n            removeFileGracefully -fileName $errorFile;\r\n        }\r\n        # We got no StdOut and no StdErr\r\n        elseif (-not $isStdOut) {\r\n            $err = \"The result file $outputFile can't be fetched because it doesn't exist\"\r\n            if (-not $stdErrInStdOut) {\r\n                throw $err\r\n            }\r\n            SNCLog-DebugInfo \"$err\"\r\n            cleanup\r\n            return;\r\n        }\r\n    } else {\r\n        $err = \"Failed to launch process $command with error $processInfo\"\r\n        if (-not $stdErrInStdOut) {\r\n            throw $err\r\n        }\r\n        SNCLog-DebugInfo \"$err\"\r\n        return;\r\n    }\r\n    \r\n    if ($context) {\r\n        $context.Undo();\r\n        $context.Dispose();\r\n    }\r\n\r\n    cleanup\r\n    return;\r\n}\r\n\r\nfunction getProcess {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [string]$filter)\r\n\r\n    SNCLog-DebugInfo \"Running getProcess\"\r\n    \r\n    if ($SNC_session){\r\n        $proc = Get-CimInstance -CimSession $SNC_session -ClassName Win32_process -filter $filter\r\n    }\r\n    elseif ($cred) {\r\n        $proc = gwmi win32_process -computer $computer -credential $cred -filter $filter\r\n    } else {\r\n        $proc = gwmi win32_process -computer $computer -filter $filter\r\n    }\r\n    SNCLog-DebugInfo \"`t`$proc: $proc\"\r\n    \r\n    return $proc\r\n}\r\n\r\nfunction putFile {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [string]$srcPath, [string]$folderPath, [string]$fileName) \r\n\r\n    SNCLog-DebugInfo \"Put File\"\r\n\r\n    if ($cred) {\r\n        net use $folderPath $cred\r\n        New-Item -ItemType Directory -Force -Path $folderPath\r\n        Copy-Item -Path $srcPath -Destination $folderPath\\$fileName -Recurse -PassThru -Force\r\n        net use $folderPath /delete\r\n        return $folderPath\r\n    }\r\n    else {\r\n        net use $folderPath\r\n        New-Item -ItemType Directory -Force -Path $folderPath\r\n        Copy-Item -Path $srcPath -Destination $folderPath\\$fileName -Recurse -PassThru -Force\r\n        net use $folderPath /delete\r\n        return $folderPath\r\n    }\r\n\r\n}\r\n\r\nfunction putFileRemotePS {\r\n    param([System.Management.Automation.Runspaces.PSSession]$ps, [string]$srcPath, [string]$folderPath, [string]$fileName) \r\n\r\n    SNCLog-DebugInfo \"Put File\"\r\n    \r\n    if ($fileName){\r\n        $srcPath = Join-Path -path $srcPath -ChildPath $fileName\r\n    }\r\n\r\n    # Create the destination folder if it does not exist\r\n    if ($folderPath){\r\n        $output = invoke-command -session $ps -scriptblock {New-Item -ItemType Directory -Force -Path $args[0] } -ArgumentList $folderPath 2>&1  # Use a specific folder\r\n        if ($output -and $output.toString() -ne $folderPath){\r\n            throw \"Error: Could not create the desired folder: $folderPath\";\r\n        }\r\n        $remotePath = $folderPath;\r\n    } else{\r\n        # If no folder was passed: use the user temp folder\r\n        $remotePath = invoke-command -session $ps -scriptblock {write-output $env:TEMP;} -ErrorAction SilentlyContinue # Grab the user temp folder\r\n        \r\n        # if we got null/empty back - revert to old behavior and use c:\\temp\r\n        if (-not $remotePath -or -not ($remotePath.trim())){\r\n            return putFileRemotePS -ps $ps -srcPath $srcPath -folderPath \"c:\\temp\" -fileName $fileName;\r\n        }\r\n    }\r\n    \r\n    # If we cannot send the file - error and stop operation\r\n    try{\r\n        $sendFileOutput = Send-File -Path $srcPath -Destination $remotePath -Session $ps -ErrorAction \"stop\";\r\n    } catch {\r\n        throw \"Error: could not put file from $srcPath to $computer on $remotePath\";\r\n    }\r\n    \r\n    return $remotePath\r\n}\r\n    \r\nfunction Send-File\r\n{\r\n    <#\r\n    .SYNOPSIS\r\n        This function sends a file (or folder of files recursively) to a destination WinRm session. This function was originally\r\n        built by Lee Holmes (http://poshcode.org/2216) but has been modified to recursively send folders of files as well\r\n        as to support UNC paths.\r\n    .PARAMETER Path\r\n        The local or UNC folder path that you'd like to copy to the session. This also support multiple paths in a comma-delimited format.\r\n        If this is a UNC path, it will be copied locally to accomodate copying.  If it's a folder, it will recursively copy\r\n        all files and folders to the destination.\r\n    .PARAMETER Destination\r\n        The local path on the remote computer where you'd like to copy the folder or file.  If the folder does not exist on the remote\r\n        computer it will be created.\r\n    .PARAMETER Session\r\n        The remote session. Create with New-PSSession.\r\n    .EXAMPLE\r\n        $session = New-PSSession -ComputerName MYSERVER\r\n        Send-File -Path C:\\test.txt -Destination C:\\ -Session $session\r\n        This example will copy the file C:\\test.txt to be C:\\test.txt on the computer MYSERVER\r\n    .INPUTS\r\n        None. This function does not accept pipeline input.\r\n    .OUTPUTS\r\n        System.IO.FileInfo\r\n    #>\r\n    [CmdletBinding()]\r\n    param\r\n    (\r\n        [string[]]$Path,[string]$Destination, [System.Management.Automation.Runspaces.PSSession]$Session\r\n    )\r\n    process\r\n    {\r\n        foreach ($p in $Path)\r\n        {\r\n            try\r\n            {\r\n                if ($p.StartsWith('\\\\'))\r\n                {\r\n                    Write-Verbose -Message \"[$($p)] is a UNC path. Copying locally first\"\r\n                    Copy-Item -Path $p -Destination ([environment]::GetEnvironmentVariable('TEMP', 'Machine'))\r\n                    $p = \"$([environment]::GetEnvironmentVariable('TEMP', 'Machine'))\\$($p | Split-Path -Leaf)\"\r\n                }\r\n                if (Test-Path -Path $p -PathType Container)\r\n                {\r\n                    Write-Log -Source $MyInvocation.MyCommand -Message \"[$($p)] is a folder. Sending all files\"\r\n                    $files = Get-ChildItem -Path $p -File -Recurse\r\n                    $sendFileParamColl = @()\r\n                    foreach ($file in $Files)\r\n                    {\r\n                        $sendParams = @{\r\n                            'Session' = $Session\r\n                            'Path' = $file.FullName\r\n                        }\r\n                        if ($file.DirectoryName -ne $p) ## It's a subdirectory\r\n                        {\r\n                            $subdirpath = $file.DirectoryName.Replace(\"$p\\\", '')\r\n                            $sendParams.Destination = \"$Destination\\$subDirPath\"\r\n                        }\r\n                        else\r\n                        {\r\n                            $sendParams.Destination = $Destination\r\n                        }\r\n                        $sendFileParamColl += $sendParams\r\n                    }\r\n                    foreach ($paramBlock in $sendFileParamColl)\r\n                    {\r\n                        Send-File @paramBlock\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Write-Verbose -Message \"Starting WinRM copy of [$($p)] to [$($Destination)]\"\r\n                    # Get the source file, and then get its contents\r\n                    $sourceBytes = [System.IO.File]::ReadAllBytes($p);\r\n                    $streamChunks = @();\r\n                    \r\n                    # Now break it into chunks to stream.\r\n                    $streamSize = 1MB;\r\n                    for ($position = 0; $position -lt $sourceBytes.Length; $position += $streamSize)\r\n                    {\r\n                        $remaining = $sourceBytes.Length - $position\r\n                        $remaining = [Math]::Min($remaining, $streamSize)\r\n                        \r\n                        $nextChunk = New-Object byte[] $remaining\r\n                        [Array]::Copy($sourcebytes, $position, $nextChunk, 0, $remaining)\r\n                        $streamChunks +=, $nextChunk\r\n                    }\r\n                    $remoteScript = {\r\n                        if (-not (Test-Path -Path $using:Destination -PathType Container))\r\n                        {\r\n                            $null = New-Item -Path $using:Destination -Type Directory -Force\r\n                        }\r\n                        $fileDest = \"$using:Destination\\$($using:p | Split-Path -Leaf)\"\r\n                        ## Create a new array to hold the file content\r\n                        $destBytes = New-Object byte[] $using:length\r\n                        $position = 0\r\n                        \r\n                        ## Go through the input, and fill in the new array of file content\r\n                        foreach ($chunk in $input)\r\n                        {\r\n                            [GC]::Collect()\r\n                            [Array]::Copy($chunk, 0, $destBytes, $position, $chunk.Length)\r\n                            $position += $chunk.Length\r\n                        }\r\n                        \r\n                        [IO.File]::WriteAllBytes($fileDest, $destBytes)\r\n                        \r\n                        Get-Item $fileDest\r\n                        [GC]::Collect()\r\n                    }\r\n                    \r\n                    # Stream the chunks into the remote script.\r\n                    $Length = $sourceBytes.Length\r\n                    $streamChunks | Invoke-Command -Session $Session -ScriptBlock $remoteScript\r\n                    Write-Verbose -Message \"WinRM copy of [$($p)] to [$($Destination)] complete\"\r\n                }\r\n            }\r\n            catch\r\n            {\r\n                Write-Error $_.Exception.Message\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction cleanup{\r\n   if ([System.IO.File]::Exists( $errorFile) ) {\r\n                 removeFileGracefully -fileName $errorFile;\r\n     }\r\n\r\n    if ([System.IO.File]::Exists( $outputFile) ) {\r\n                 removeFileGracefully -fileName $outputFile;\r\n    }\r\n}\r\n\r\n\r\nfunction removeFileGracefully{\r\n    param([string] $fileName)\r\n\r\n    $triesNumber = 0\r\n     $maxTries = 2;\r\n     while  ($triesNumber -le  $maxTries){\r\n        try {\r\n            remove-item $fileName -ErrorAction Stop\r\n            return\r\n         } catch {\r\n            SNCLog-DebugInfo \"Warning, deleting $fileName failed: $($_.Exception.Message))\"\r\n            Start-Sleep -Seconds 3\r\n            $triesNumber = $triesNumber + 1\r\n            if ($triesNumber -le  $maxTries) {\r\n                  SNCLog-DebugInfo \"Retry to delete $fileName\"\r\n             } else {\r\n                  SNCLog-DebugInfo \"Failed to delete $fileName\"\r\n           }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction getConfigurableParm {\r\n   param([string]$variable, [string]$defaultValue)\r\n   $value = [Environment]::GetEnvironmentVariable($variable)\r\n   if (-not $value) {\r\n        $value = $defaultValue;\r\n    }\r\n    return $value;\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_1ed24b15376001006b882d465abe5dd1","name":"LaunchProc.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/0dc0eaff370002000e4d03488e41f11f","value":"0dc0eaff370002000e4d03488e41f11f"},"description":"","source":"","sys_updated_on":"2018-08-23 15:04:34","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"24d0eaff370002000e4d03488e41f13b","sys_updated_by":"nisan.barzion","sys_created_on":"2015-05-22 20:49:43","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"RegistryAPI.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"38","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"function Get-RegistryDataPS {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $RegistryKey\r\n    )\r\n\r\n    $keys = Get-RegistryKeysPS $RegistryKey\r\n    $values = Get-RegistryValuesPS $RegistryKey\r\n\r\n    $data = @()\r\n    \r\n    if (($keys | Group-Object Collection -NoElement).Count -gt 0) {\r\n        $data += $keys\r\n    }\r\n\r\n    if (($values | Group-Object Collection -NoElement).Count -gt 0) {\r\n        $data += $values\r\n    }\r\n\r\n    if (test-path env:\\SNC_remoteShell) {\r\n        return $data | format-list\r\n    }\r\n\r\n    return $data\r\n}\r\n\r\nfunction Get-RegistryValuesPS {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $RegistryKey\r\n    )\r\n\r\n    $data = @()\r\n\r\n    # lookup table to translate from given to actual reg types\r\n    $lt = @{\r\n        \"System.String\"                 = \"REG_SZ\";\r\n        \"System.Int32\"                  = \"REG_DWORD\";\r\n        \"System.Int64\"                  = \"REG_QWORD\";\r\n        \"System.Byte[]\"                 = \"REG_BINARY\";\r\n        \"Deserialized.System.String[]\"  = \"REG_MULTI_SZ\";\r\n    }\r\n\r\n    #get the properties of the given key\r\n    $key = Get-ItemProperty \"Registry::$RegistryKey\"\r\n    foreach($pr in $key.psobject.properties) {\r\n        if (!$pr.Name) {\r\n            continue\r\n        }\r\n\r\n        if ($pr.Name -eq \"PSPath\" -Or \r\n            $pr.Name -eq \"PSProvider\" -Or \r\n            $pr.Name -eq \"PSParentPath\" -Or \r\n            $pr.Name -eq \"PSChildName\" -Or \r\n            $pr.Name -eq \"PSComputerName\" -Or \r\n            $pr.Name -eq \"PSShowComputerName\" -Or \r\n            $pr.Name -eq \"RunspaceId\") {\r\n            continue\r\n        }\r\n        \r\n        $rv = 1 | Select-Object -Property Name, Type, Value\r\n        $rv.Name = $pr.Name\r\n        $rv.Type = $lt[$pr.TypeNameOfValue]\r\n        $rv.Value = [String]$pr.Value\r\n\r\n        $data += $rv\r\n    }\r\n\r\n    return $data\r\n}\r\n\r\nfunction Get-RegistryKeysPS {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $RegistryKey\r\n    )\r\n\r\n    $data = @()\r\n\r\n    #get the keys under the given key\r\n    $key = Get-ChildItem \"Registry::$RegistryKey\"\r\n    forEach ($pr in $key) {\r\n        if (!$pr.Name) {\r\n            continue\r\n        }\r\n\r\n        $tmp = 1 | Select-Object -Property Name, Type, Value\r\n        $tmp.Name = $pr.Name.split(\"\\\")[-1]\r\n        $tmp.Type = \"KEY\"\r\n\r\n        $data += $tmp\r\n    }\r\n\r\n    return $data\r\n}\r\n\r\n\r\n\r\n\r\nfunction Get-RegistryDataWMI {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $RegistryHive,\r\n        [Parameter(Mandatory=$true)] $RegistryKey\r\n    )\r\n\r\n    $wmi = Get-WmiObject -List \"StdRegProv\" -Namespace \"root\\default\" -ComputerName $computer -Credential $cred\r\n\r\n    $keys = Get-RegistryKeysWMI $wmi $RegistryHive $RegistryKey\r\n    $values = Get-RegistryValuesWMI $wmi $RegistryHive $RegistryKey\r\n\r\n    $data = @()\r\n\r\n    if (($keys | Group-Object Collection -NoElement).Count -gt 0) {\r\n        $data += $keys\r\n    }\r\n\r\n    if (($values | Group-Object Collection -NoElement).Count -gt 0) {\r\n        $data += $values\r\n    }\r\n\r\n    return $data | format-list\r\n}\r\n\r\nfunction Get-RegistryValuesWMI {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $WmiHandle,\r\n        [Parameter(Mandatory=$true)] $RegistryHive,\r\n        [Parameter(Mandatory=$true)] $RegistryKey\r\n    )\r\n\r\n    $data = @()\r\n\r\n    $reg = $WmiHandle.EnumValues($RegistryHive, $RegistryKey)\r\n    for ($i = 0; $i -lt $reg.sNames.Length; $i++) {\r\n        $rv = 1 | Select-Object -Property Name, Type, Value\r\n        $rv.Name = $reg.sNames[$i]\r\n        $rv.Value = Get-RegistryValueWMI $WmiHandle $RegistryHive $RegistryKey $rv.Name (Get-RegistryValueTypeWMI $reg.Types[$i])\r\n        $rv.Type = Get-RegistryValueTypeWMI $reg.Types[$i] $true\r\n\r\n        $data += $rv\r\n    }\r\n\r\n    return $data\r\n}\r\n\r\nfunction Get-RegistryValueWMI {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $WmiHandle,\r\n        [Parameter(Mandatory=$true)] $RegistryHive,\r\n        [Parameter(Mandatory=$true)] $RegistryKey,\r\n        [Parameter(Mandatory=$true)] $ValueName,\r\n        [Parameter(Mandatory=$true)] $Type\r\n    )\r\n\r\n    switch ($Type) {\r\n        REG_SZ { $tmp = $WmiHandle.getStringValue($RegistryHive, $RegistryKey, $ValueName) | Select-Object -ExpandProperty sValue; break; }\r\n        REG_EXPAND_SZ { $tmp = $WmiHandle.getExpandedStringValue($RegistryHive, $RegistryKey, $ValueName) | Select-Object -ExpandProperty sValue; break; }\r\n        REG_MULTI_SZ { $tmp = $WmiHandle.getMultiStringValue($RegistryHive, $RegistryKey, $ValueName) | Select-Object -ExpandProperty sValue; break; }\r\n        REG_BINARY { $tmp = $WmiHandle.getBinaryValue($RegistryHive, $RegistryKey, $ValueName) | Select-Object -ExpandProperty uValue; break; }\r\n        REG_DWORD { $tmp = $WmiHandle.getDwordValue($RegistryHive, $RegistryKey, $ValueName) | Select-Object -ExpandProperty uValue; break; }\r\n        REG_QWORD { $tmp = $WmiHandle.getQwordValue($RegistryHive, $RegistryKey, $ValueName) | Select-Object -ExpandProperty uValue; break; }\r\n    }\r\n\r\n    return [String]$tmp\r\n}\r\n\r\nAdd-Type -TypeDefinition @\"\r\n   public enum RegistryValueType\r\n   {\r\n        REG_SZ = 1,\r\n        REG_EXPAND_SZ = 2,\r\n        REG_BINARY = 3,\r\n        REG_DWORD = 4,\r\n        REG_MULTI_SZ = 7,\r\n        REG_QWORD = 11\r\n   }\r\n\"@\r\n\r\nfunction Get-RegistryValueTypeWMI {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $IntType,\r\n        [Parameter(Mandatory=$false)] $ResolveToBasicType = $true\r\n    )\r\n\r\n    $regType = \"\"\r\n\r\n    foreach ($rvt in [System.Enum]::GetValues([RegistryValueType])) {\r\n        if ($rvt -eq $IntType) {\r\n            $regType = [String]$rvt\r\n            break\r\n        }\r\n    }\r\n\r\n    if (!$ResolveToBasicType) {\r\n        return $regType\r\n    }\r\n\r\n    $basicRegTypes = @{\r\n        \"REG_SZ\"        = \"REG_SZ\";\r\n        \"REG_EXPAND_SZ\" = \"REG_SZ\";\r\n        \"REG_BINARY\"    = \"REG_BINARY\";\r\n        \"REG_DWORD\"     = \"REG_DWORD\";\r\n        \"REG_MULTI_SZ\"  = \"REG_MULTI_SZ\";\r\n        \"REG_QWORD\"     = \"REG_QWORD\"\r\n    }\r\n\r\n    return [String]$basicRegTypes[$regType]\r\n}\r\n\r\nfunction Get-RegistryKeysWMI {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] $WmiHandle,\r\n        [Parameter(Mandatory=$true)] $RegistryHive,\r\n        [Parameter(Mandatory=$true)] $RegistryKey\r\n    )\r\n\r\n    $data = @()\r\n\r\n    $reg = $WmiHandle.EnumKey($RegistryHive, $RegistryKey)\r\n    for ($i = 0; $i -lt $reg.sNames.Length; $i++) {\r\n        $rv = 1 | Select-Object -Property Name, Type, Value\r\n        $rv.Name = $reg.sNames[$i]\r\n        $rv.Type = \"KEY\"\r\n\r\n        $data += $rv\r\n    }\r\n\r\n    return $data\r\n}\r\n\r\nfunction Get-MultipleRegistryDataPS {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] [string]$RegistryKeys\r\n    )\r\n\r\n    $regHash = @{};\r\n    # Properties to ignore\r\n    $defaultProps = @(\"PSParentPath\",\"PSChildName\",\"PSProvider\", \"PSDrive\",\"PSComputerName\",\"PSShowComputerName\",\"RunspaceId\", \"PSPath\");\r\n    # Translation between Get-ItemProperty restuls types and expected types in sensor\r\n    $regTypes = @{\r\n        \"System.String\"                 = \"REG_SZ\";\r\n        \"System.Int32\"                  = \"REG_DWORD\";\r\n        \"System.Int64\"                  = \"REG_QWORD\";\r\n        \"System.Byte[]\"                 = \"REG_BINARY\";\r\n        \"Deserialized.System.String[]\"  = \"REG_MULTI_SZ\";\r\n    }\r\n    # Shorten PSDrive names as expected in Get-ItemProperty command\r\n    $driveNames = @{\r\n        \"HKEY_LOCAL_MACHINE\"  = \"HKLM\";\r\n        \"HKEY_CLASSES_ROOT\"   = \"HKCR\"\r\n        \"HKEY_CURRENT_USER\"   = \"HKCU\";\r\n        \"HKEY_USERS\"          = \"HKU\";\r\n        \"HKEY_CURRENT_CONFIG\" = \"HKCC\";\r\n    }\r\n\r\n    # Split input into an array\r\n    $regKeys = $RegistryKeys.split(\",\");\r\n\r\n    # Loop over all input values and create a hash of Registry bases to values.\r\n    # Input: HKEY_LOCAL_MACHINE/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*/DisplayName and HKEY_LOCAL_MACHINE/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*/InstallDate\r\n    # Output: regHash[\"HKLM:/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*\"] = \"DisplayName,InstallDate,\" (will get rid of the extra comma later)\r\n    foreach($regKey in $regKeys){\r\n        $regKey = $regKey.trim();\r\n        $lastSlash =$regKey.lastIndexOf(\"/\");\r\n\r\n        $attr = $regKey.substring($lastSlash+1 , $regKey.length-$lastSlash -1);\r\n        $base = $regKey.substring(0, $lastSlash);\r\n        \r\n        $firstSlash = $base.indexOf(\"/\");\r\n        $drive = $base.substring(0, $firstSlash);\r\n        \r\n        # Try and replace long name with short names\r\n        $drive = $driveNames[$drive];\r\n        if ($drive -ne $null -or $drive -ne \"\"){\r\n            $base = $drive + \":\" + $base.substring($firstSlash, $base.length-$firstSlash);\r\n        }\r\n\r\n        $regHash[$base] += $attr + \",\";\r\n    }\r\n    \r\n    # For every registry base, create a Get-ItemProperty command and run it.\r\n    # Input: regHash[\"HKLM:/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*\"] = \"DisplayName,InstallDate,\"\r\n    # Command: Get-ItemProperty -Path 'HKLM:/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*' -Name DisplayName,InstallDate -EA SilentlyContinue;\r\n    foreach($regBase in $regHash.keys){\r\n        # Prepare the command\r\n        $query = $regHash[$regBase];\r\n        $query = $query.substring(0, $query.length-1);\r\n        $command = \"Get-ItemProperty -Path \"\"$regBase\"\" -Name $query -EA SilentlyContinue;\"\r\n        # Run the command\r\n        $items = iex $command;\r\n        \r\n        # If no results - continue\r\n        if ($items -eq $null){\r\n            continue;\r\n        }\r\n        \r\n        $printPath = \"\";\r\n        # Results is an array of Objects - loop over the array\r\n        foreach ($item in $items){\r\n            # can have nulls...\r\n            if ($item -eq $null -and $item.PSPath -eq $null){\r\n                continue;\r\n            }\r\n            \r\n            # Only print path each time it is changing - This way we save transfer characters and processing\r\n            $path = $item.PSPath.replace(\"Microsoft.PowerShell.Core\\Registry::\",\"\");\r\n            if ($path -ne $printPah){\r\n                $printPath = $path;\r\n                write-host \"Path  :\" $printPath;\r\n            }\r\n            # Loop over each object\r\n            foreach ($key in $item.PSObject.Properties){\r\n                # In case we got nulls here too...\r\n                if ($key -eq $null){\r\n                    continue;\r\n                }\r\n                $keyName = $key.Name;\r\n                    \r\n                # Ignore default properties and dont print those out\r\n                if ($defaultProps -notcontains $keyName){\r\n                    # Convert to known type\r\n                    # Input: System.String\r\n                    # Output: REG_SZ\r\n                    $type = $key.Value.GetType().FullName;\r\n                    $type = $regTypes[$type];\r\n                    if ($type -eq $null -or $type -eq \"\"){\r\n                        $type = $key.Value.GetType();\r\n                    }\r\n                    \r\n                    # Print values for same path\r\n                    write-host \"Name  :\" $keyName;\r\n                    write-host \"Type  :\" $type;\r\n                    write-host \"Value :\" $key.Value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_24d0eaff370002000e4d03488e41f13b","name":"RegistryAPI.psm1","sys_policy":"","use_attachment":"false"},{"parent":"","description":"WMI scripting engine related files","source":"","sys_updated_on":"2013-05-31 23:06:22","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"38ed7937efa5010098d5925495c0fb0d","sys_updated_by":"aleck.lin","sys_created_on":"2013-05-31 23:06:22","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"WMI","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"aleck.lin","sys_mod_count":"0","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_38ed7937efa5010098d5925495c0fb0d","name":"WMI","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/af2f7456372331000e4d03488e41f1b1","value":"af2f7456372331000e4d03488e41f1b1"},"description":"Contains functions to support running remote PowerShell commands in a local PowerShell","source":"","sys_updated_on":"2019-09-04 17:30:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"3c88677c378331000e4d03488e41f1d5","sys_updated_by":"cong.thieu","sys_created_on":"2015-03-25 01:28:27","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"PSRemoteScript.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"18","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"<# \r\n .Synopsis\r\n  Create PowerShell session.\r\n\r\n .Description\r\n  Returns the created PowerShell session object to be used.\r\n  Uses env vars to get the hostname and credential\r\n\r\n .Example\r\n   # Create a powershell session.\r\n   Create-PSSession\r\n\r\n Requires -Version 2.0\r\n#>\r\nfunction Create-PSSession {\r\n    param([string]$ConfigurationName)\n    if (-not $ConfigurationName) {\n        $ConfigurationName = $env:SNC_ConfigurationName\n    }\n    return CreatePSSessionWithURI -host $computer -ConfigurationName $ConfigurationName\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_3c88677c378331000e4d03488e41f1d5","name":"PSRemoteScript.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/38ed7937efa5010098d5925495c0fb0d","value":"38ed7937efa5010098d5925495c0fb0d"},"description":"SNC WMI API -- Script used by discovery (via cscript) to gather WMI information","source":"","sys_updated_on":"2015-02-19 22:30:16","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"3d1e3dbbef65010098d5925495c0fb83","sys_updated_by":"josh.gerbasi","sys_created_on":"2013-05-31 23:07:10","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"WMIScanner.js","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"aleck.lin","sys_mod_count":"10","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"//\r\n// WMIScanner - SNC WMI API -- Script used by discovery (via cscript) to gather WMI information\r\n//\r\n\r\n/**\r\n * The piece of prototype.js that makes the initialize method work.\r\n */\r\nvar Class = {\r\n    create: function() {\r\n        return function() { this.initialize.apply(this, arguments); }\r\n    }\r\n}\r\n\r\n/**\r\n * Scans WMI specified tables and fields and returns their values. \r\n */\r\nWMIScanner = Class.create();\r\n\r\nWMIScanner.prototype = {\r\n    defaultRoot: 'root\\\\cimv2',\r\n    wbemFlagReturnImmediately: 0x10,\r\n    wbemFlagForwardOnly: 0x20,\r\n    PktPrivacy: 6,\r\n  \r\n    initialize: function(remoteHost) {\r\n        this.windowsMachine = remoteHost;\r\n        this.debugging = false;\r\n        this.debugCount = 0;\r\n        this.currentPath = '';\r\n        this.currentConnection = '';\r\n        this.registry = '';\r\n        this.fetchEntries = {};\r\n        this._initPayload();\r\n    },\r\n    \r\n    addError: function(msg) {\r\n        this.appendElement(this.getXMLRoot(), 'error', msg);\r\n    },\r\n    \r\n    addWarning: function(msg) {\r\n        this.appendElement(this.getXMLRoot(), 'warning', msg);\r\n    },\r\n    \r\n    convertWMIDateToStr: function(dtmDate) {\r\n        if (dtmDate == null)  {\r\n            return 'null date';\r\n        }\r\n    \r\n        var strDateTime;\r\n        if (dtmDate.substr(4, 1) == 0)  {\r\n            strDateTime = dtmDate.substr(5, 1) + '/';\r\n        } else  {\r\n            strDateTime = dtmDate.substr(4, 2) + '/';\r\n        }\r\n        \r\n        if (dtmDate.substr(6, 1) == 0)\r\n            strDateTime = strDateTime + dtmDate.substr(7, 1) + '/';\r\n        else\r\n            strDateTime = strDateTime + dtmDate.substr(6, 2) + '/';\r\n        \r\n        strDateTime = strDateTime + dtmDate.substr(0, 4)  + ' ' +\r\n                                    dtmDate.substr(8, 2)  + ':' +\r\n                                    dtmDate.substr(10, 2) + ':' +\r\n                                    dtmDate.substr(12, 2);\r\n        return strDateTime;\r\n    },\r\n    \r\n    /**\r\n     * Add the given path to the fetch entries.  The paths may take one of two forms, either:\r\n     *     HKEY_<registry key path>\r\n     * or\r\n     *     [<namespace>\\]<class>.property\r\n     * The first form fetches a registry key value; the second a WMI class property.\r\n     */\r\n    addFetch: function(path) {\r\n        var parser = /^(HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS)[\\\\\\/].*$/;\r\n        var parts = parser.exec(path);\r\n        if (parts)\r\n            this.addRegistryFetch(path);\r\n        else\r\n            this.addWMIFetch(path);\r\n    },\r\n    \r\n    addRegistryFetch: function(path) {\r\n        if (!this.fetchEntries['Registry'])\r\n            this.fetchEntries['Registry'] = new Object();\r\n        \r\n        this.fetchEntries['Registry'][path] = 1;\r\n    },\r\n    \r\n    /**\r\n     * Adds WMI fetch entries with a path of the following form: \r\n     *     [<namespace>\\]<class>.property\r\n     * If the optional namespace is missing, the default (root\\cimv2) is used.  All namespaces MUST begin with \"root\\\".\r\n     * \r\n     * path: the path to be fetched, in the form specified above.\r\n     */\r\n    addWMIFetch: function(path) {\r\n        var namespace = this.defaultRoot;\r\n        var tableName = '';\r\n        var fieldName = '';\r\n        var parser = /^(?:(root\\\\(?:.*))\\\\)?([^\\\\]*)[\\.\\\\\\/](.*)$/;\r\n        var parts = parser.exec(path);\r\n        if (!parts)\r\n            return;\r\n        if (parts[1])\r\n            namespace = parts[1];\r\n        tableName = parts[2];\r\n        fieldName = parts[3];\r\n        \r\n        if (!this.fetchEntries[namespace])\r\n            this.fetchEntries[namespace] = {};\r\n        var ns = this.fetchEntries[namespace];\r\n        \r\n        if (!ns[tableName])\r\n            ns[tableName] = {};\r\n        \r\n        ns[tableName][fieldName] = 1;\r\n    },\r\n    \r\n    /**\r\n     * Fetches all the entries previously added with addFetch();\r\n     */\r\n    fetch: function() {\r\n        for(var namespace in this.fetchEntries) {\r\n            if (namespace == 'Registry')\r\n                this.fetchRegistry(namespace);\r\n            else\r\n                this.fetchWMI(namespace);\r\n        }\r\n    },\r\n    \r\n    fetchRegistry: function(namespace) {\r\n        var node = this.getXMLPayload().createElement(namespace);\r\n\r\n        for(var regPath in this.fetchEntries[namespace]){\r\n            this.registryFetch(regPath, node);\r\n        }\r\n        \r\n        this.getXMLRoot().appendChild(node);\r\n    }, \r\n    \r\n     // This function is called when using the fingerprint \r\n    // toolkit framework in order to run any WQL query\r\n    wmiQuery: function(namespace, query) {\r\n        this._debug('Query from namespace: ' + namespace);\r\n        var items = new Array()\r\n        var connection = this.wmiConnect(namespace);\r\n        if (connection) {\r\n            var colItems = this._execQuery(connection, query);\r\n            var enumItems = new Enumerator(colItems);\r\n            var resultsNode = this.getXMLPayload().createElement(\"results\");\r\n            this.getXMLRoot().appendChild(resultsNode);\r\n            for (; !enumItems.atEnd(); enumItems.moveNext()) {\r\n                var resultNode = this.getXMLPayload().createElement(\"result\");\r\n                resultsNode.appendChild(resultNode);\r\n                var o = enumItems.item();\r\n                var properties = this.getPropertiesArray(o.Properties_);\r\n                for (var i = 0; i < properties.length; i++) {\r\n                \tif (properties[i] == \"null\")\r\n                \t\tcontinue;\r\n                \r\n                    var propertyMap = properties[i].split(\"=\");\t\t\r\n                    var key = propertyMap[0];\r\n                    var value = propertyMap[1];\r\n                    var keyNode = this.getXMLPayload().createElement(key);\r\n                    keyNode.appendChild(this.getXMLPayload().createTextNode(value));\r\n                    resultNode.appendChild(keyNode);\r\n                }\r\n            }\r\n        } else {\r\n            this._debug('Unable to fetch from given query: ' + query);\r\n        }\r\n    },\r\n    \r\n    fetchWMI: function(namespace) {\r\n        for (var tableName in this.fetchEntries[namespace]) {\r\n            var table = this.fetchEntries[namespace][tableName];\r\n            var items = this.fetchTable(tableName, namespace);\r\n        \r\n            for(var i = 0; i < items.length; i++) {\r\n                var item = items[i];\r\n                \r\n                var node = this.getXMLPayload().createElement(tableName);\r\n                this.getXMLRoot().appendChild(node);\r\n                for(var fieldName in table)\r\n                    this.appendElement(node, fieldName, item[fieldName]);\r\n            }\r\n        }\r\n    }, \r\n\r\n    getPropertiesArray: function(properties) {\r\n        this._debug('getPropertiesArray()');\r\n        try {\r\n            var props = [];\r\n            var enumValues = new Enumerator(properties);\r\n            for (; !enumValues.atEnd(); enumValues.moveNext()) {\r\n                var prop = enumValues.item();\r\n                var thisProp = this.getValueText(prop);\r\n                if (thisProp) {\r\n                    this._debug('Enumerated property: ' + thisProp);\r\n                    props.push(thisProp);\r\n                }\r\n            }\r\n            return props;\r\n        }\r\n        catch (err) {\r\n            this._debug('Was not a collection of properties: ' + err.message);\r\n            return null;\r\n        }\r\n    },    \r\n    \r\n    fetchTable: function(table, root) {\r\n        if (!root)\r\n            root = this.defaultRoot;\r\n        \r\n        this._debug('Fetching table: ' + root + '\\\\' + table);\r\n        \r\n        var items = new Array()\r\n        \r\n        var connection = this.wmiConnect(root);\r\n        if (connection) {\r\n            var colItems = this._execQuery(connection, 'SELECT * FROM ' + table);\r\n            var enumItems = new Enumerator(colItems);\r\n            for (; !enumItems.atEnd(); enumItems.moveNext()) {\r\n                var o = enumItems.item();\r\n                items.push(o);\r\n            }\r\n        } else {\r\n            this._debug('Unable to fetch table: ' + table);\r\n        }\r\n        \r\n        return items;\r\n    },\r\n    \r\n    fetchItem: function (table, root) {\r\n        var items = this.fetchTable(table, root);\r\n        if (items.length == 0)\r\n            items.push(new Object());\r\n        \r\n        return items[0];\r\n    },\r\n    \r\n    fetchRow: function(table, field, value, retv) {\r\n        value = new String(value);\r\n        var arItems = value.split('\\\\');\r\n        if (arItems.length > 1)\r\n            value = arItems.join('\\\\\\\\');\r\n        \r\n        var connection = this.wmiConnect(this.defaultRoot);\r\n        if (connection) {\r\n            var eQuery = 'SELECT ' + retv + ' FROM ' + table + ' WHERE ' + field + ' = \"' + value + '\"';\r\n            var colItems = this._execQuery(connection, eQuery);\r\n            var enumItems = new Enumerator(colItems);\r\n            for (; !enumItems.atEnd(); enumItems.moveNext()) {\r\n                var o = enumItems.item();       \r\n                if (o[retv] != null)\r\n                    return o[retv];\r\n            }\r\n        }\r\n    },\r\n    \r\n    getXMLPayload: function() {\r\n        return this.xmlPayload;\r\n    },\r\n    \r\n    getXMLRoot: function() {\r\n        return this.xmlRoot;\r\n    },\r\n    \r\n    getRegistry: function() {\r\n        if (!this.registry) {\r\n            this.registry = new Registry(this.windowsMachine); \r\n            this.registry.setWMIScanPointer(this);\r\n            this.registry.setDebugging(this.debugging);\r\n        }\r\n    \r\n        return this.registry;\r\n    },\r\n    \r\n    openRegistry: function() {\r\n        var r = this.getRegistry();\r\n        return r.open();\r\n    },\r\n    \r\n    registryFetch: function(path, node) {\r\n        return this.getRegistry().fetch(path, node);\r\n    },\r\n    \r\n    registryGetValue: function(path) {\r\n        return this.getRegistry().getValue(path);\r\n    },\r\n    \r\n    registryGetStringValue: function(key, name) {\r\n        return this.getRegistry().getStringValue(key, name);\r\n    },\r\n    \r\n    registryGetEnumValue: function(key) {\r\n        return this.getRegistry().enumKey(key);\r\n    },\r\n    \r\n    registryGetBinaryValue: function(key, name) {\r\n        return this.getRegistry().getBinaryValue(key, name);\r\n    },\r\n    \r\n    run: function(cmd) {\r\n        var objShell = new ActiveXObject('WScript.Shell');\r\n        var sCommand = 'cmd /c ' + cmd;\r\n        \r\n        this._debug('About to run: ' + sCommand);\r\n        var objShellJob = objShell.exec(sCommand);\r\n        \r\n        return objShellJob.stdOut.ReadAll();\r\n    },\r\n\r\n    setDebugging: function(d) {\r\n        this.debugging = d;\r\n    },\r\n    \r\n    winExec: function(cmd) {\r\n        var winExecCmd = 'lib\\\\WinExec.exe \\\\\\\\' + this.windowsMachine;\r\n        \r\n        if (this.debugging)\r\n            winExecCmd += ' -v';\r\n            \r\n        return this.run(winExecCmd + ' \"' + cmd + '\"');\r\n    },\r\n        \r\n    winExecApplication: function (cmd) {\r\n        var winExecCmd = \"lib\\\\WinExec.exe \\\\\\\\\" + this.windowsMachine;\r\n\r\n        if (this.debugging)\r\n            winExecCmd += ' -v';\r\n\r\n        return this.run(winExecCmd + ' -c ' + cmd);\r\n    },\r\n    \r\n    wmiConnect: function(path) {\r\n        var sLoc = new ActiveXObject('WbemScripting.SWbemLocator');\r\n        sLoc.Security_.AuthenticationLevel = this.PktPrivacy;\r\n        var sConnection;\r\n        \r\n        // if we are already connected, no reason to reconnect\r\n        if (this.currentConnection && this.currentPath == path)\r\n            return this.currentConnection;\r\n        \r\n        try {\r\n            sConnection = sLoc.ConnectServer(this.windowsMachine, path, '', '');\r\n        } catch (e) {\r\n            this.addWarning(\"Unable to connect to path: \" + path + \". Error: \" + e.message);\r\n        }\r\n        \r\n        this.currentConnection = sConnection;\r\n        this.currentPath = path;\r\n        \r\n        return sConnection;\r\n    },\r\n    \r\n    wmiOpen: function() {\r\n        if (this._wmiRunning())\r\n            return true;\r\n        \r\n        this._debug('WMI not running');\r\n        this.wmiClose();\r\n        \r\n        return false;\r\n    },\r\n    \r\n    wmiClose: function() {\r\n        // nothing\r\n    },\r\n    \r\n    appendToRoot: function (name, value) {\r\n        var root = this.getXMLRoot();\r\n        var i = root.getElementsByTagName(name);\r\n        \r\n        if (i.length) {\r\n            var child = i.item(0);\r\n            child.firstChild.nodeValue = value;\r\n        } else {\r\n            this.appendElement(root, name, value);\r\n        }\r\n    },\r\n    \r\n    /*\r\n     * Appends the given value to the given parent XML node, using the given name for the child node created.  The given value\r\n     * may be of any type returned by the WMI API, which is a broad range of JScript natives, VB object types, and arbitrary\r\n     * ActiveX/COM types.\r\n     * \r\n     * If the code in this method (and it's dependent methods) seems unusually defensive, that's because it really is -- and it \r\n     * seems to actually be necessary.  The need is provoked by Microsoft's deviation from JavaScript standards.  Two specific \r\n     * examples of this: (1) not all JScript objects have a toString() method, and (2) executing \"if (object.method)\" to test for \r\n     * the existence of a method will not necessarily behave as expected -- some classes will throw an exception with this code, \r\n     * even when the referenced method exists. I'm sure that's not the end of Microsoft's \"improvements\", but those two issues are \r\n     * the primary reason for the unreasonable-looking defensiveness of this code.\r\n     */\r\n    appendElement: function (parent, name, value) {\r\n        this._debug('Appending element: ' + name);\r\n        \r\n        // no matter what value we have (even null), we're going to make the child element...\r\n        var child = this.getXMLPayload().createElement(name);\r\n        \r\n        // get the text equivalent of whatever value we've been given, protecting against any Microsoft insanity...\r\n        var valueText = null;\r\n        try {\r\n            valueText = this.getValueText(value);\r\n        }\r\n        catch (err) {\r\n            this._debug('Problem getting text equivalent: ' + err.message);\r\n        }\r\n        \r\n        // and if we got any non-null value, we're going to append the child's text\r\n        // in all cases, we append the child to the parent...\r\n        if (valueText)\r\n            child.appendChild(this.getXMLPayload().createTextNode(valueText));\r\n        parent.appendChild(child);   \r\n        this._debug('Appended: ' + name + '; ' + valueText);\r\n        return child;\r\n    },\r\n    \r\n    /*\r\n     * Gets the text equivalent of the given value, no matter what type the given value is.  Returns null if the given value is \r\n     * null or is of some unknown type.\r\n     */\r\n    getValueText: function(value) {\r\n        this._debug('getValueText()');\r\n        if (value == null)\r\n            return null;\r\n        \r\n        // what type of value do we have?\r\n        var valueType = typeof value;\r\n        this._debug('valueType: ' + valueType);\r\n        switch (valueType) {\r\n            \r\n            case 'boolean':\r\n                return value ? '1' : '0';\r\n                break;\r\n                \r\n            case 'object':\r\n            case 'unknown':\r\n                var text = this.getObjectText(value);\r\n                var result = this.getRegistry().stripNonValidXMLCharacters(text);\r\n                return result;\r\n                break;\r\n                \r\n            default:\r\n                var result = this.getRegistry().stripNonValidXMLCharacters('' + value);\r\n                return result;\r\n                break;\r\n        }\r\n    },\r\n    \r\n    /*\r\n     * Gets the text equivalent of the given Object value, which can be any of a JavaScript Array, a VBArray, a Collection, or\r\n     * an object with a Properties_ instance.\r\n     */\r\n    getObjectText: function(value) {\r\n        this._debug('getObjectText()');\r\n        \r\n        // if we've got a VBArray, handle it...\r\n        var result = this.getVBArrayText(value);\r\n        if (result)\r\n            return result;\r\n        \r\n        // if we've got a Collection, handle it...\r\n        result = this.getCollectionText(value);\r\n        if (result)\r\n            return result;\r\n            \r\n        // if we've got a JavaScript Array, handle it...\r\n        if (value instanceof Array)\r\n            return value.join(',');\r\n       \r\n        // if we've got a properties element, handle it (safely)...\r\n        // this is here specifically to support MS_ClusterResource.PrivateProperties...\r\n        try {\r\n            var props = value.Properties_;\r\n            if (props != null)\r\n                return this.getValueText(props);\r\n            this._debug('Was not .Properties_');\r\n        }\r\n        catch (err) {\r\n            this._debug('Tried to get .Properties_, failed');\r\n        }\r\n        \r\n        // if we've got something that has name/value pairs, treat it like a property (safely)...\r\n        // this is here specifically to support MS_ClusterResource.PrivateProperties...\r\n        try {\r\n            // fish out any property values we might have...\r\n            var propName = value['Name'];\r\n            if (propName == null)\r\n                propName = value['name'];\r\n            var propValue = value['Value'];\r\n            if (propValue == null)\r\n                propValue = value['value'];\r\n            \r\n            // if we've got name/value properties, turn 'em into text...\r\n            if (propName != null && propValue != null) {\r\n                var propNameText  = this.getValueText(propName);\r\n                var propValueText = this.getValueText(propValue);\r\n                \r\n                // if we got name/value text, turn 'em into <name>=<value> string and return it...\r\n                if (propNameText && propValueText)\r\n                    return propNameText + '=' + propValueText;\r\n            }\r\n            this._debug('Could not evaluate as a property');\r\n        }\r\n        catch (err) {\r\n            this._debug('Could not evaluate as property: ' + err.message);\r\n        }\r\n        \r\n        // if it's nothing else we know, let's see if we can turn it into a string...\r\n        try {\r\n            var toStr = '' + value;\r\n            if (toStr)\r\n                return toStr;\r\n        }\r\n        catch (err) {\r\n            this._debug('Could not evaluate with toString()');\r\n        }\r\n        \r\n        // we don't know what we've got, so just bail out...\r\n        this._debug('Unknown value type');\r\n        return null;\r\n    },\r\n    \r\n    /*\r\n     * Get the text equivalent of a VBArray, safely (meaning that an element that is null or is an instance of some type we don't\r\n     * understand will not fail; it just won't be included in the result).  If the argument wasn't a VBArray, returns null.\r\n     */\r\n    getVBArrayText: function(vbarray) {\r\n        this._debug('getVBArrayText()');\r\n        try {\r\n            var jsArray = vbarray.toArray();\r\n            var safeArray = [];\r\n            for (var i = 0; i < jsArray.length; i++) {\r\n                var elemText = this.getValueText(jsArray[i]);\r\n                if (elemText)\r\n                    safeArray.push(elemText);\r\n            }\r\n            return safeArray.join(',');\r\n        }\r\n        catch (err) {\r\n            this._debug('Was not a VBArray: ' + err.message);\r\n            return null;\r\n        }\r\n    },\r\n    \r\n    /*\r\n     * Get the text equivalent of a VB Collection, safely (meaning that an element that is null or is an instance of some type we \r\n     * don't understand will not fail; it just won't be included in the result).  If the given value wasn't a collection, \r\n     * returns null.\r\n     */\r\n    getCollectionText: function(collection) {\r\n        this._debug('getCollectionText()');\r\n        try {\r\n            var props = [];\r\n            var enumValues = new Enumerator(collection);\r\n            for (; !enumValues.atEnd(); enumValues.moveNext()) {\r\n                var prop = enumValues.item();\r\n                var thisProp = this.getValueText(prop);\r\n                if (thisProp) {\r\n                    this._debug('Enumerated property: ' + thisProp);\r\n                    props.push(thisProp);\r\n                }\r\n            }\r\n            return props.join(',');\r\n        }\r\n        catch (err) {\r\n            this._debug('Was not a collection: ' + err.message);\r\n            return null;\r\n        }\r\n    },\r\n    \r\n    _execQuery: function(connection, query) {\r\n        this._debug('QUERY: ' + query);\r\n        return connection.ExecQuery(query);\r\n    },\r\n    \r\n    _wmiRunning: function() {\r\n        var name;\r\n        \r\n        this._debug('Testing WMI connection to ' + this.windowsMachine);\r\n        \r\n        try {\r\n            var objWMIService = GetObject('winmgmts:\\\\\\\\' + this.windowsMachine + '\\\\root\\\\CIMV2');\r\n            var colItems = objWMIService.ExecQuery('SELECT * FROM Win32_ComputerSystem', 'WQL',\r\n            this.wbemFlagReturnImmediately | this.wbemFlagForwardOnly);\r\n            \r\n            var enumItems = new Enumerator(colItems);\r\n            for (; !enumItems.atEnd(); enumItems.moveNext()) {\r\n                var objItem = enumItems.item();\r\n                \r\n                name = objItem.Name\r\n            }\r\n            \r\n        } catch (e) {\r\n            this.addError(\"Connection failed to WMI service. Error: \" + e.message);\r\n        }       \r\n        \r\n        return name && name.length > 0;\r\n    },\r\n    \r\n    _initPayload: function() {\r\n        this.xmlPayload = new ActiveXObject('Microsoft.XMLDOM');\r\n        this.xmlRoot = this.xmlPayload.createElement('wmi'); \r\n        this.xmlPayload.appendChild(this.xmlRoot);\r\n    },\r\n    \r\n    _debug: function(msg) {\r\n        if (!this.debugging)\r\n            return;\r\n        \r\n        WScript.StdErr.Write(Date() + ' DEBUG: ' + msg + '\\n');\r\n    },\r\n    \r\n    //\r\n    // end of WMI routines\r\n    //\r\n    type : 'WMIScanner'\r\n}\r\n\r\n/*\r\n * Registry things\r\n */\r\nRegistry = Class.create();\r\n\r\nRegistry.prototype = {\r\n    REG_UNKNOWN: 0, \r\n    REG_SZ: 1, \r\n    REG_EXPAND_SZ: 2, \r\n    REG_BINARY: 3, \r\n    REG_DWORD: 4, \r\n    REG_MULTI_SZ: 7,\r\n    priKey: {\r\n        HKCR: 0x80000000, HKEY_CLASSES_ROOT:  0x80000000,\r\n        HKCU: 0x80000001, HKEY_CURRENT_USER:  0x80000001,\r\n        HKLM: 0x80000002, HKEY_LOCAL_MACHINE: 0x80000002,\r\n        HKU:  0x80000003, HKEY_USERS:         0x80000003\r\n    },\r\n    \r\n    initialize: function(windowsMachine) {\r\n        this.windowsMachine = windowsMachine;\r\n        this.registryProvider = '';\r\n        this.wsPointer;\r\n        this.invalidXMLDetection = \"detectedInvalidXMLCharacter\";\r\n    },\r\n    \r\n    open: function() {\r\n        if (!this.registryProvider) {\r\n            this._debug('Connecting to registry');\r\n            this.registryProvider = this._connect('root\\\\default');\r\n        }\r\n        \r\n        if (!this.registryProvider) {\r\n            this._debug('Connection to registry failed');\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    },\r\n    \r\n    getType: function(key) {\r\n        this._debug('getType(), key=' + key);\r\n        var path = key.substring(0, key.lastIndexOf('\\\\'));\r\n        var name = key.substring(path.length+1);\r\n\r\n        var type = this.getTypeForKey(path, name);\r\n        return '' + type;\r\n    },\r\n    \r\n    getValue: function(key) {\r\n        this._debug('getValue(), key=' + key);\r\n        var path = key.substring(0, key.lastIndexOf('\\\\'));\r\n        var name = key.substring(path.length+1);\r\n        var type = this.getTypeForKey(path, name);\r\n        return this.getStringValueByType(type, path, name);\r\n    },\r\n    \r\n    getStringValueByType: function(type, path, name) {\r\n        if (type == this.REG_EXPAND_SZ) {\r\n            return this.getExpandedStringValue(path, name);\r\n        } else if (type == this.REG_BINARY) {\r\n            var v = this.getBinaryValue(path, name);\r\n            v = v.toArray();\r\n            v = v.toString();\r\n            return v;\r\n        } else if (type == this.REG_DWORD) {\r\n            return this.getDWORDValue(path, name);\r\n        } else if (type == this.REG_MULTI_SZ) {\r\n            return this.getMultiStringValue(path, name);\r\n        } else if (type == this.REG_SZ) {\r\n            return this.getStringValue(path, name);\r\n        }\r\n        \r\n        return null;\r\n    },\r\n    \r\n    getTypeForKey: function(path, key) {\r\n        var values = this.enumValues(path);\r\n        \r\n        for(value in values) {\r\n            if (value.toLowerCase() == key.toLowerCase())\r\n                return values[value];\r\n        }\r\n        \r\n        return this.REG_UNKNOWN;\r\n    },\r\n    \r\n    enumKey: function(key) {\r\n        var ret = this._get('EnumKey', key);\r\n        if (typeof(ret.sNames) != 'undefined' && ret.sNames != null)\r\n            return ret.sNames.toArray();\r\n        \r\n        return new Array();\r\n    },\r\n    \r\n    enumValues: function(key) {\r\n        var values = new Object();\r\n        var ret = this._get('EnumValues', key);\r\n        \r\n        if (typeof(ret.sNames) != 'undefined' && ret.sNames != null) {\r\n            var types = ret.Types.toArray();\r\n            var items = ret.sNames.toArray();\r\n            for(var i = 0; i < items.length; i++) {\r\n                var name = items[i];\r\n                var type = types[i];\r\n                values[name] = type;\r\n            }\r\n        }\r\n        \r\n        return values;\r\n    },\r\n    \r\n    fetch: function(path, node) {\r\n        var keys = new Array();\r\n\r\n        if (!this.open())\r\n            return;\r\n        \r\n        path = path.replace(/\\//g, '\\\\');\r\n        keys.push(path);\r\n        keys = this._expandKeys(keys);\r\n        \r\n        for(var i = 0; i < keys.length;i++) {\r\n            var name = keys[i];\r\n            var value = this.getValue(name);\r\n            if (value != null)\r\n                this._storeValues(name, value, node);\r\n        }\r\n    },\r\n    \r\n    getBinaryValue: function(key, name) {\r\n        var ret = this._get('GetBinaryValue', key, name);\r\n        return ret.uValue;\r\n    },\r\n    \r\n    getDWORDValue: function(key, name) {\r\n        var ret = this._get('GetDWORDValue', key, name);\r\n        return ret.uValue;\r\n    },\r\n    \r\n    getExpandedStringValue: function(key, name) {\r\n        var ret = this._get('GetExpandedStringValue', key, name);\r\n        return ret.sValue;\r\n    },\r\n    \r\n    getMultiStringValue: function(key, name) {\r\n        var ret = this._get('GetMultiStringValue', key, name);\r\n        return ret.sValue.toArray();\r\n    },\r\n    \r\n    getStringValue: function(key, name) {\r\n        var ret = this._get('GetStringValue', key, name);\r\n        return this.stripNonValidXMLCharacters(ret.sValue);\r\n    },\r\n\r\n    setWMIScanPointer: function(wsPointer) {\r\n        this.wsPointer = wsPointer;\r\n    },\r\n    \r\n    setDebugging: function(d) {\r\n        this.debugging = d;\r\n    },\r\n    \r\n    stripNonValidXMLCharacters: function(value) {\r\n        if (value == null || value == \"\")\r\n            return \"\";\r\n\r\n        var output = \"\";\r\n        for (var i = 0; i < value.length; i++) {\r\n            var current = value.charCodeAt(i);\r\n   \r\n            if (current == 0x9 || current == 0xA || current == 0xD || (current >= 0x20 && current <= 0xD7FF) || (current >= 0xE000 && current <= 0xFFFD) || (current >= 0x10000 && current <= 0x10FFFF))\r\n                output += String.fromCharCode(current);\r\n            else { //Detected invalid xml characters\r\n                return this.invalidXMLDetection;\r\n            }\r\n        }\r\n  \r\n        return output;    \r\n    },\r\n    \r\n    _connect: function(path) {\r\n        var sLoc = new ActiveXObject('WbemScripting.SWbemLocator');\r\n        var arch = new ActiveXObject('WbemScripting.SWbemNamedValueSet');\r\n        arch.Add('__ProviderArchitecture', 64);\r\n        var sConnection;\r\n        \r\n        try {\r\n            this._debug('Connection string ' + this.windowsMachine + '\\\\' + path);\r\n            sConnection = sLoc.ConnectServer(this.windowsMachine, path, '', '', null, null, null, arch);\r\n            sConnection = sConnection.Get('StdRegProv');\r\n        } catch (e) {\r\n            this._debug('Connection problem: ' + e.message);\r\n        }\r\n        \r\n        this._debug('Connected to registry');\r\n        \r\n        return sConnection;\r\n    },\r\n    \r\n    _expandKeys: function(keys) {\r\n        var expanded = false;\r\n        \r\n        for(var i = keys.length - 1; i >= 0; i--) {\r\n            var key = keys[i];\r\n            \r\n            if (key.indexOf('*') > -1) {\r\n                expanded = true;\r\n                \r\n                var left = key.substring(0, key.indexOf('*'));\r\n                var right = key.substring(key.indexOf('*')+1);\r\n                keys.splice(i, 1);\r\n                \r\n                var keyList = this.enumKey(left);\r\n                for(var k=0; k < keyList.length; k++) {\r\n                    var childKey = keyList[k];\r\n                    keys.push(left + childKey + right);\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (expanded)\r\n            keys = this._expandKeys(keys);\r\n        \r\n        return keys;\r\n    },\r\n    \r\n    _get: function(funcName, key, value) {\r\n        if (!this.open())\r\n        return {};\r\n        \r\n        this._debug(funcName + '()');\r\n        \r\n        var rPath = this._getRealPath(key);\r\n        var mfunc = this.registryProvider.Methods_.Item(funcName);\r\n        var funcParams = mfunc.InParameters.SpawnInstance_();\r\n        funcParams.hDefKey = rPath[0];\r\n        funcParams.sSubKeyName = rPath[1];\r\n        \r\n        this._debug('defKey: ' + rPath[0]);\r\n        this._debug('subKey: ' + rPath[1]);\r\n        \r\n        if (value && value.length > 0) {\r\n            funcParams.sValueName = value;\r\n            this._debug('valueName: ' + value);\r\n        }\r\n        \r\n        // protect against unknown keys with try / catch\r\n        try {\r\n            return this.registryProvider.ExecMethod_(funcName, funcParams);\r\n        } catch (e) {\r\n            this._debug('Get problem: ' + e.errorText);\r\n        }\r\n        \r\n        return {};\r\n    },\r\n    \r\n    _getRealPath: function(path) {\r\n        var rPath = [];\r\n        \r\n        rPath[0] = this.HKLM;\r\n        rPath[1] = path;\r\n        \r\n        var parser = /^(.*?)\\\\(.*)$/;\r\n        var parts = parser.exec(path);\r\n        if (!parts)\r\n            return rPath;\r\n            \r\n        var key = this.priKey[parts[1]];\r\n        if (!key)\r\n            return rPath;\r\n        \r\n        rPath[0] = key;\r\n        rPath[1] = parts[2];\r\n        \r\n        return rPath;\r\n    },\r\n    \r\n    _storeValues: function(name, value, node) {\r\n        var parts = name.split('\\\\');\r\n        var currentNode = node;\r\n        var found = false;\r\n        var key;    \r\n        var childNode;\r\n        var ENTRY = \"entry\";\r\n        var KEY = \"key\";\r\n        var VALUE = \"value\";\r\n        var PATH = \"path\";\r\n        var TYPE = \"type\";\r\n        for(var p = 0; p < parts.length; p++) {\r\n            found = false;\r\n            key = parts[p];\r\n            for(var i=0; i<currentNode.childNodes.length; i++) {\r\n                childNode = currentNode.childNodes[i]; \r\n                if (childNode.nodeType != 1)\r\n                    continue;\r\n\r\n                if (childNode.getAttribute(KEY) == key) {\r\n                    currentNode = childNode;\r\n                    found = true;\r\n                    break;\r\n                }  \r\n            }\r\n            if (!found) { \r\n                currentNode = this.wsPointer.appendElement(currentNode, ENTRY, \"\");\r\n                currentNode.setAttribute(KEY, key);\r\n            }\r\n        }\r\n        currentNode = this.wsPointer.appendElement(currentNode, VALUE, value);\r\n        currentNode.setAttribute(TYPE, this.getType(name));\r\n    },\r\n\r\n    _debug: function(msg) {\r\n        if (!this.debugging)\r\n            return;\r\n        \r\n        WScript.StdErr.Write(Date() + ' DEBUG: ' + msg + '\\n');\r\n    },\r\n\r\n    type: 'Registry'\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_3d1e3dbbef65010098d5925495c0fb83","name":"WMIScanner.js","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Manages credential testing to see if there is proper access to a target system","source":"","sys_updated_on":"2025-05-01 19:53:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"3f234355376001006b882d465abe5de8","sys_updated_by":"now.midserver","sys_created_on":"2013-04-04 16:42:01","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"Credentials.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"jimmy.yuan","sys_mod_count":"58","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"$executingScriptDirectory = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent\r\nimport-module  \"$executingScriptDirectory\\DiagnosticsUtil\" -DisableNameChecking\r\n\r\n<######################\r\n #\tIf protected with DPAPI so that it can be passed securely from java process to PowerShell process, unprotect it\r\n #  and optionally convert it to a secure string, so that it can be used to create the credential object. \r\n ######################>\r\n function unprotect {\r\n\tparam([string]$protectedText, [Switch]$AsSecureString)\r\n\r\n\t# when protected, the text has the format of \"ENC_VAL[base64_encoding]\"\r\n\t# use regex to detect the pattern and pluck out the base64_ecoding part\r\n\tAdd-Type -AssemblyName System.Security\r\n\tif (-Not ($protectedText -match \"^ENC_VAL\\[((?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?)\\]$\")) {\r\n\t\t$unprotectedText = $protectedText\r\n\t} else {\r\n\t\t$base64String = $Matches[1]\r\n\t\t$protectedBytes = [Convert]::FromBase64String($base64String)\r\n\t\t$unprotectedBytes = [Security.Cryptography.ProtectedData]::Unprotect($protectedBytes, $null, 'CurrentUser')\r\n\t\t$unprotectedText = [Text.Encoding]::UTF8.GetString($unprotectedBytes)\r\n\t\t$unprotectedBytes.Clear()\r\n\t}\n\r\n\tif ($AsSecureString) {\r\n\t\t$secureString = New-Object 'Security.SecureString'\r\n\t\t$chars = $unprotectedText.ToCharArray();\r\n\t\tfor($idx = 0; $idx -lt $chars.Count ; $idx++ ) {\r\n\t\t\t$secureString.AppendChar($chars[$idx])\r\n\t\t\t$chars[$idx] = 0\r\n\t\t}\r\n\t\t$secureString.MakeReadOnly()\r\n\t\t$unprotectedText = $null\r\n\t\treturn $secureString\r\n\t}\r\n\treturn $unprotectedText;\r\n}\r\n \r\n<######################\r\n #\tTurn user/password into a credential object for use in cmdlets that take a credential\r\n ######################>\r\nfunction getCredential {\r\n\tparam([string]$user, [string]$password)\r\n\r\n\t$user = unprotect $user\r\n\tif ($password) {\r\n\t\t$passwordSecure = unprotect $password -AsSecureString;\r\n\t} else {\r\n\t\t# If no password was supplied, use an empty instance of SecureString\r\n\t\t$passwordSecure = new-object System.Security.SecureString;\r\n\t\tSNCLog-DebugInfo \"`tNo password was supplied\"\r\n\t}\r\n\t\r\n\t$cred = new-object -typename System.Management.Automation.PSCredential -argumentlist \"$user\",$passwordSecure;\r\n\r\n\treturn $cred;\r\n}\r\n\r\n<######################\r\n #\tTest the given user and password on the given computer using a get-WMIobject \r\n #\tcall to fetch the operating system information.  It uses EA (ErrorAction) Stop to force\r\n #\tthe exception handling to handle the error.  This is particularly useful for the error\r\n #\t0x800706BA - The RPC server is unavailable which normally does not get caught in the\r\n #\texception handling.  If the user and password authenticate successfully against the system,\r\n #  return a credential object for that user/password\r\n ######################>\r\nfunction testCredentialWMI {\r\n\tparam([string]$computer, [string]$user, [string]$password, [boolean]$debug)\r\n\tSNCLog-DebugInfo \"Running testCredentialWMI with user $user\"\r\n\r\n\t$cred = getCredential $user $password;\r\n\r\n\ttry {\r\n\t\t#Just eat the results - mostly concerned with capturing errors\r\n\t\t$results = gwmi win32_operatingsystem -computer $computer -credential $cred -impersonation 3 -authentication 6 -EA \"Stop\";\r\n\t\tSNCLog-DebugInfo \"`tCredential created for WMI\"\r\n\t\treturn $cred;\r\n\t} catch [System.UnauthorizedAccessException] {\r\n\t\tSNCLog-DebugInfo \"`tInvalid credential for WMI, unauthorized access exception\"\r\n\t\texit 1;\r\n\t} catch [System.Exception] {\r\n\t\tSNCLog-DebugInfo \"`tSystem.Exception : $_.Exception.Message\"\r\n\t\t[Console]::Error.WriteLine($_.Exception.Message)\r\n\t\tif ($debug) {\r\n\t\t\t[Console]::Error.WriteLine(\"`r`n Stack Trace: \" + $_.Exception.StackTrace)\r\n\t\t}\r\n\t\texit 2;\t\r\n\t}\r\n}\r\n\r\nfunction testNoCredentialWMI {\r\n\tparam([string]$computer, [boolean]$debug)\r\n\tSNCLog-DebugInfo \"Running testNoCredentialWMI without explicit credential\"\r\n\r\n\ttry {\r\n\t\t#Just eat the results - mostly concerned with capturing errors\r\n\t\t$results = gwmi win32_operatingsystem -computer $computer -impersonation 3 -authentication 6 -EA \"Stop\";\r\n\t\tSNCLog-DebugInfo \"`tWMI access allowed without credential\"\r\n\t} catch [System.UnauthorizedAccessException] {\r\n\t\tSNCLog-DebugInfo \"`tWMI access denied without credential, unauthorized access exception\"\r\n\t\texit 1;\r\n\t} catch [System.Exception] {\r\n\t\tSNCLog-DebugInfo \"`tSystem.Exception : $_.Exception.Message\"\r\n\t\t[Console]::Error.WriteLine($_.Exception.Message)\r\n\t\tif ($debug) {\r\n\t\t\t[Console]::Error.WriteLine(\"`r`n Stack Trace: \" + $_.Exception.StackTrace)\r\n\t\t}\r\n\t\texit 2;\t\r\n\t}\r\n}\r\n\r\n<######################\r\n #  Test the given user and password on the given computer with the DirectoryEntry object, assuming we're logging\r\n #  into an Active Directory server\r\n ######################>\r\nfunction testCredentialAD {\r\n\tparam([string]$computer, [string]$user, [string]$password, [boolean]$debug)\r\n\r\n\t$user = unprotect $user\r\n\tSNCLog-DebugInfo \"Running testCredentialAD with user $user\"\r\n\r\n\t$rootEntry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$computer\", $user, (unprotect $password);\r\n\tif ($rootEntry.Properties -eq $null) {\r\n\t\tSNCLog-DebugInfo \"`tInvalid credential for AD, unauthorized access exception\"\r\n\t\texit 1;\r\n\t}\r\n\r\n\tSNCLog-DebugInfo \"`tCredential created for AD\"\r\n\t# we succeeded, so pass back a PSCredential object \r\n\treturn getCredential $user $password\r\n}\r\n\r\n<######################\r\n #  Test the given user and password on the given computer with the DirectoryEntry object, assuming we're logging\r\n #  into an Exchange server\r\n ######################>\r\nfunction testCredentialExchange {\r\n\tparam([string]$computer, [string]$user, [string]$password, [boolean]$debug)\r\n\r\n\t$cred = getCredential -user $user -password $password;\r\n\r\n\tSNCLog-DebugInfo \"Running testCredentialExchange with user $cred.UserName\"\r\n\tSNCLog-DebugInfo \"`CreatePSSessionWithURI -Host $computer -ConfigurationName Microsoft.Exchange -UriPath `\"/powershell`\" -Credential `$cred\"\r\n\t$session = CreatePSSessionWithURI -Host $computer -ConfigurationName Microsoft.Exchange -UriPath \"/powershell\" -Credential $cred\r\n\tif ($session -eq $null) {\r\n\t\tSNCLog-DebugInfo \"`tInvalid credential for Exchange, unauthorized access exception\"\r\n\t\texit 1;\r\n\t}\r\n\r\n\t# Release the resources\r\n\tGet-PSSession | Remove-PSSession;\r\n\r\n\tSNCLog-DebugInfo \"`tCredential created for Exchange\"\r\n\t# we succeeded, so pass back the PSCredential object \r\n\t$cred;\r\n}\r\n\r\nfunction testNoCredentialAccessExchange {\r\n\tSNCLog-DebugInfo \"Running testNoCredentialAccessExchange\"\r\n\texit 3;\r\n}\r\n\r\n<######################\r\n #  Test the given user and password to create a session on SCCM server, assuming we're logging\r\n #  into SCCM server\r\n ######################>\r\nfunction testCredentialSCCM {\r\n\tparam([string]$computer, [string]$user, [string]$password)\r\n\r\n\tSNCLog-DebugInfo \"Running testCredentialSCCM\"\r\n\r\n\t$cred = getCredential -user $user -password $password;\r\n\tSNCLog-DebugInfo \"`tCreatePSSessionWithComputerName -Host $computer -ConfigurationName Microsoft.PowerShell32 -Credential `$cred\"\r\n\t$session = CreatePSSessionWithComputerName -Host $computer -ConfigurationName Microsoft.PowerShell32 -Credential $cred;\r\n\tif ($session -eq $null) {\r\n\t\tSNCLog-DebugInfo \"`tFailed to create remote session to the  SCCM server: $computer\"\r\n\t\texit 1;\r\n\t} else {\r\n\t\t#Successfully connected to sccm server using winRM now try to connect to the SCCM site\r\n\tTry {\r\n\t\t$ErrorActionPreference = 'Stop'\r\n\t\tSNCLog-DebugInfo \"`tInvoking Invoke-Command with script block \"\r\n\t\tInvoke-Command -Session $session -ScriptBlock{ Import-Module -Name \"$(split-path $Env:SMS_ADMIN_UI_PATH)\\ConfigurationManager.psd1\"; Set-Location -path \"$(Get-PSDrive -PSProvider CMSite):\\\"}\r\n\t} catch [System.Exception] {\r\n\t\tSNCLog-DebugInfo \"`tInvalid credential for SCCM, system exception\"\r\n\t\tRemove-PSSession -session $session\r\n\t\texit 1\r\n\t}\r\n\r\n\t# Release the resources\r\n\tRemove-PSSession -session $session \r\n\tSNCLog-DebugInfo \"`tCredential created for SCCM\"\r\n\t# we succeeded, so pass back the PSCredential object \r\n\t$cred\r\n\t}\r\n}\r\n\r\nfunction testNoCredentialAccessSCCM {\r\n\tSNCLog-DebugInfo \"Running testNoCredentialAccessSCCM\"\r\n\texit 3;\r\n}\r\n\r\n<######################\r\n #\tTest the ability to reach a given computer without credentials using a get-WMIobject \r\n #\tcall to fetch the operating system information.  It uses EA (ErrorAction) Stop to force\r\n #\tthe exception handling to handle the error.  This is particularly useful for the error\r\n #\t0x800706BA - The RPC server is unavailable which normally does not get caught in the\r\n #\texception handling.  Bail out of the script if the computer can't be reached.\r\n ######################>\r\nfunction testNoCredentialAccessWMI {\r\n\tparam([string]$computer, [boolean]$debug)\r\n\r\n\tSNCLog-DebugInfo \"Running testNoCredentialAccessWMI\"\r\n\r\n\ttry {\r\n\t\t#Just eat the results - mostly concerned with capturing errors\r\n\t\t$results = gwmi win32_operatingsystem -computer $computer -impersonation 3 -authentication 6 -EA \"Stop\";\r\n\t} catch [System.Exception] {\r\n\t\tSNCLog-DebugInfo \"`tInvalid credential for WMI, exception: $_.Exception.Message\"\r\n\t\t[Console]::Error.WriteLine(\"Failed to access target system.  Please check credentials and firewall settings on the target system to ensure accessibility: \" + $_.Exception.Message)\r\n\r\n\t\tif ($debug) {\r\n\t\t\t[Console]::Error.WriteLine(\"`r`n Stack Trace: \" + $_.Exception.StackTrace)\r\n\t\t}\r\n\t\texit 3;\r\n\t}\r\n}\r\n\r\n<######################\r\n #  Test trying to access the given computer with the DirectoryEntry object without credentials, \r\n #  assuming we're trying to access an Active Directory server\r\n ######################>\r\nfunction testNoCredentialAccessAD {\r\n\tparam([string]$computer, [boolean]$debug)  \r\n\r\n\tSNCLog-DebugInfo \"Running testNoCredentialAccessAD\"\r\n\tSNCLog-DebugInfo \"`tInvoking New-Object for DirectoryEntry with LDAP://$computer\"\r\n\t$rootEntry = New-Object System.DirectoryServices.DirectoryEntry \"LDAP://$computer\";\r\n\tif ($rootEntry.Properties -eq $null) {\r\n\t\tSNCLog-DebugInfo \"`trootEntry.Properties is null\"\r\n\t\texit 3;\r\n\t}\r\n}\r\n\r\n<######################\r\n #\tStart an impersonation context where script code executed between this call and the EndImpersonate call is executed\r\n #\tin the security context of the given credential\r\n #\r\n #\tReturn: a context that should be passed to EndImpersonation when the security context of the given credential\r\n #\tis not needed anymore\r\n ######################>\r\nfunction startImpersonation {\r\n\tparam([System.Management.Automation.PSCredential]$cred)\r\n    \r\n\tSNCLog-DebugInfo \"Running startImpersonation\"\r\n\t$context = $null\r\n\r\n\tif ($cred) {\r\n\t\t$signature = \"[DllImport(\"\"advapi32.dll\"\", SetLastError = true)] `\r\n\t\tpublic static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, `\r\n\t\tint dwLogonType, int dwLogonProvider, ref IntPtr phToken);\";\r\n\r\n\t\t$LogOnUser = Add-Type -memberDefinition $signature -name \"Win32LogOnUser\" -passThru;\r\n\r\n\t\t[IntPtr]$userToken = [Security.Principal.WindowsIdentity]::GetCurrent().Token;\r\n\r\n\t\t# The 9 means LOGON32_LOGON_NEW_CREDENTIALS: See definition at http://msdn.microsoft.com/en-us/library/aa378184%28VS.85%29.aspx\r\n\t\tif ($LogOnUser::LogOnUser($cred.GetNetworkCredential().UserName, $cred.GetNetworkCredential().Domain,\r\n\t\t\t$cred.GetNetworkCredential().Password, 9, 0, [ref]$userToken)) {\r\n\t\t\t$Identity = new-object security.Principal.WindowsIdentity $userToken\r\n\t\t\t$context = $Identity.Impersonate();\r\n\t\t}\r\n\t}\r\n\treturn $context;\r\n}\r\n\r\n<######################\r\n #    End a given impersontation context that was started with StartImpersonation\r\n ######################>\r\nfunction endImpersonation {\r\n\tparam([System.Security.Principal.WindowsImpersonationContext]$context)\r\n\r\n\tSNCLog-DebugInfo \"Running endImpersonation\"\r\n\tif ($context) {\r\n\t\t$context.Undo();\r\n\t\t$context.Dispose();\r\n\t}\r\n}\r\n\r\n<######################\r\n #\tCreates the user and password variables that need are passed to a powershell script. \r\n ######################>\r\nfunction testCredentialGetCred {\r\n\tparam([string]$user, [string]$password)\r\n\r\n\tSNCLog-DebugInfo \"Running testCredentialGetCred\"\r\n\t\r\n\t$cred = getCredential $user $password;\r\n\r\n\treturn $cred;\r\n} \r\n\r\nfunction CreateNewCimSession {\r\n    param([string]$Host, [System.Management.Automation.PSCredential]$Credential, [uint32]$OperationTimeoutSec)\r\n\r\n    # if host is not explicitly specified, use the global variable $computer\r\n    if (-not ($Host)) {\r\n        $Host = $computer;\r\n    }\r\n\r\n    # if credential is not explicitly specified, use the global variable $cred\r\n    if (-not ($Credential)) {\r\n        $Credential = $cred;\r\n    }\r\n\r\n    $so = New-CimSessionOption -Protocol Dcom\r\n\r\n    # care must be taken in using single quote here: $so, $Credential, and $OperationTimeoutSec are objects\r\n    # they will be expanded when the script block is created\r\n    $cmd = 'New-CimSession -ComputerName $Host -SessionOption $so'\r\n    if ($Credential) {\r\n        $cmd += ' -Credential $Credential'\r\n    }\r\n\r\n    if ($OperationTimeoutSec) {\r\n        $cmd += ' -OperationTimeoutSec $OperationTimeoutSec'\r\n    }\r\n\r\n    SNCLog-DebugInfo (\"Running create CIM session script: \" + $ExecutionContext.InvokeCommand.ExpandString($cmd))\r\n    $sb = [Scriptblock]::Create($cmd)\r\n    & $sb\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_3f234355376001006b882d465abe5de8","name":"Credentials.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/f81b00b1f711020028f47d78ac99d9be","value":"f81b00b1f711020028f47d78ac99d9be"},"description":"","source":"","sys_updated_on":"2021-10-28 09:38:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"49dadb4037e102000e4d03488e41f180","sys_updated_by":"cong.thieu","sys_created_on":"2015-07-24 22:59:41","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"ScriptAPI.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"37","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"$tmpDriveName = \"\"\r\n$remoteDriveLetter = \"C\"\r\n\r\nfunction launchProcess {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [string]$command)\r\n    # Don't add the cmd prefix if this is a JEA connection\r\n    if ([string]::isNullOrEmpty($env:SNC_ConfigurationName)) {\r\n        $command = 'cmd /c \"' + $command +'\"'\r\n    }\r\n    SNCLog-DebugInfo \"ScriptAPI launchProcess with the command `\"$command`\"\";\r\n    executeRemote -computer $computer -scriptBlock $command -wmi $false;\r\n}\r\n\r\nfunction handleExit {\r\n    param([int]$exitCode)\r\n\r\n    $output = \"\"\r\n\r\n    if ($exitCode -ne 0) {\r\n        $output = \"$env:SNC_cmdFail $exitCode\"\r\n    } else {\r\n        $output = \"$env:SNC_cmdCmpl $exitCode\"\r\n    }\r\n\r\n    write-host $output\r\n}\r\n\r\nfunction getFileContentWinRM {\r\n    param([string]$path)\r\n\r\n    $command = 'Get-Content \"' + $path + '\"';\r\n    executeRemote -computer $computer -scriptBlock $command -wmi $false;\r\n}\r\n\r\nfunction getFilePropertiesWinRM {\r\n    param([string]$path)\r\n\r\n    $command = 'Get-ItemProperty \"' + $path + '\" | select *;';\r\n    executeRemote -computer $computer -scriptBlock $command -wmi $false;\r\n}\r\n\r\nfunction convertPathToUnc {\r\n    param([string]$path)\r\n\r\n    $pathArr = $path.split(':')\r\n    $remoteDriveLetter = $pathArr[0]\r\n    $tmp = $path -replace ':', '$'\r\n\r\n    return '\\\\' + $computer + '\\' + $tmp\r\n}\r\n\r\nfunction removeDrive {\r\n    #Remove-PSDrive -Name $tmpDriveName >$null\r\n    net use /delete \\\\$computer\\$remoteDriveLetter$ >$null\r\n}\r\n\r\nfunction getTrustedHostsAuthority {\r\n    $xml = Get-WSManInstance -ResourceURI winrm/config/client | select -expandproperty OuterXml\r\n    $ns = @{cfg=\"http://schemas.microsoft.com/wbem/wsman/1/config/client\"}\r\n    $n = select-xml -XPath '/cfg:Client/cfg:TrustedHosts' -Content $xml -Namespace $ns\r\n    $out = 'GPO'\r\n    if ([string]::isNullOrEmpty($n.node.source)) {\r\n        $out = 'HOST'\r\n    }\r\n\r\n    return $out\r\n}\r\n\r\nfunction getTrustedHosts {\r\n    $xml = Get-WSManInstance -ResourceURI winrm/config/client | select -expandproperty OuterXml\r\n    $ns = @{cfg=\"http://schemas.microsoft.com/wbem/wsman/1/config/client\"}\r\n    $n = select-xml -XPath '/cfg:Client/cfg:TrustedHosts' -Content $xml -Namespace $ns\r\n\r\n    return $n.node.'#text'\r\n}\r\n\r\nfunction hostInDomain {\r\n    if ((Get-WmiObject win32_computersystem).partofdomain) {\r\n        write-host true\r\n    } else {\r\n        write-host false\r\n    }\r\n}\r\n\r\nfunction testRemoteHostRunningWinRM {\r\n    param([System.Management.Automation.PSCredential]$credential)\r\n\r\n    $cmd = 'test-wsman -computer $computer -port $env:SNC_targetPort'\r\n\r\n    if ($env:SNC_useSSL -eq \"true\") {\r\n        $cmd += ' -UseSSL'\r\n    }\r\n\r\n    $cmd += ' -ErrorAction stop'\r\n    $sb = [Scriptblock]::Create($cmd)\r\n    try {\r\n        SNCLog-DebugInfo (\"Running test script: \" + $ExecutionContext.InvokeCommand.ExpandString($cmd))\r\n        & $sb\r\n        SNCLog-DebugInfo \"`tWinRM service is running on $computer\"\r\n    } catch [System.InvalidOperationException] {\r\n        # Note that if we get an SSL certificate error, WinRM service is most likely running.\r\n\t\t# Unfortunately, Test-WSMan does not provide a way to skip SSL certificate check so we have to assume that it is running.\r\n        if ($_.Exception.Message -NotMatch \"SSL certificate\") {\r\n            SNCLog-DebugInfo \"`tWinRM access error\"\r\n            throw\r\n        }\r\n    }\r\n}\r\n\r\nfunction testRemoteHostConnection {\r\n    $dummyCred = getDummyCredential \"TestUser\" \"TestPassword\"\r\n    testRemoteHostRunningWinRM -credential $dummyCred\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_49dadb4037e102000e4d03488e41f180","name":"ScriptAPI.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/0e991bcf53456010347cddeeff7b1287","value":"0e991bcf53456010347cddeeff7b1287"},"description":"Utilities for Just Enough Administration (JEA) Discovery ","source":"","sys_updated_on":"2024-09-17 00:33:41","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"4e040b0753456010347cddeeff7b12a2","sys_updated_by":"now.midserver","sys_created_on":"2020-12-17 18:23:12","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"JEAUtils.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"cong.thieu","sys_mod_count":"6","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"<#\r\n    This function creates an ordered dictionary from a given hashtable. It also filters out the elements that are not a string, bool or int data type.\r\n#>\r\nfunction hashToSortedDict {\r\n    param( [HashTable] $hash )\r\n\r\n    $dict = [ordered]@{}\r\n    if ($hash) {\r\n        $keys = $hash.keys | sort;\r\n        foreach ($key in $keys ) { \r\n            if ($hash[$key] -is [String] -or $hash[$key] -is [int] -or $hash[$key] -is [bool] -or $hash[$key] -is [Byte[]]) {\r\n                $dict.add($key, $hash[$key])\r\n            }\r\n       }\r\n    }\r\n    return $dict\r\n}\r\n\r\n<#\r\n    This function checks if the signing certificate is already available in a global variable; If not, it will be retrieved from the machine certificate store.\r\n#>\r\nfunction retrieveSigningCert  {\r\n    if (-not $global:SNC_jea_disco_cert) {\r\n        $mycert = Get-ChildItem Cert:\\LocalMachine\\My\\ | Where {$_.Issuer -eq 'CN=jea-disco@servicenow.com'  -and $_.Subject -eq 'CN=jea-disco@servicenow.com'}\r\n        if ($mycert -is [Array]) {\r\n            SNCLog-DebugInfo \"Only ONE jea-disco certificate is allowed in the local machine cert store. Please fix the issue and retry\"\r\n        } elseif (-not $mycert) {\r\n            SNCLog-DebugInfo \"No jea-disco certificate found in the local machine cert store.\"\r\n        } else {\r\n            $global:SNC_jea_disco_cert = $mycert\r\n            SNCLog-DebugInfo \"SNC_jea_disco_cert is now available!\"\r\n        }\r\n    }\r\n}\r\n\r\n<#\r\n    This function checks if JEA discovery is enabled and the code signing certificate is available.\r\n#>\r\nfunction isJEACodeSigning  {\r\n    return ($env:SNC_ConfigurationName -and  $global:SNC_jea_disco_cert)\r\n}\r\n\r\n<#\r\n    This function signs a script or any string content together with a hashtable parameter using jea-disco certificate and \r\n     returns the signature as Base64 string. If the certificate is not available yet, it tries to load it from the local machine cert store.\r\n#>\r\nfunction signContent {\r\n    param( [String] $content, [HashTable] $params )\r\n\r\n    if  ($global:SNC_jea_disco_cert -and $global:SNC_jea_disco_cert.PrivateKey) {\r\n        $sortedParams = hashToSortedDict $params\r\n        $paramsAsStr = convertTo-Json $sortedParams -Compress\r\n        $raw_input_data = [System.Text.Encoding]::UTF8.GetBytes($content + $paramsAsStr)\r\n        $sign_data = $global:SNC_jea_disco_cert.PrivateKey.SignData($raw_input_data, $SNC_HASH_ALGORITHM)\r\n        return [System.Convert]::ToBase64String($sign_data)\r\n    } else {\r\n        SNCLog-DebugInfo \"jea-disco certificate or private key not found\"\r\n    }\r\n    return \"\"\r\n}\r\n\r\n<#\r\n    This function signs and sends a script to execute on the target via JEAExecute-Script function\r\n#>\r\nfunction invokeJEAExecuteScript {\r\n    [CmdletBinding()]\r\n    Param([System.Management.Automation.Runspaces.PSSession] $remotePs, \r\n                   [String][Parameter(Mandatory = $true)] $script,\r\n                   [HashTable][Parameter(Mandatory = $false)] $params)\r\n    \r\n    $signature = signContent $script $params\r\n    $output = Invoke-Command -Session $remotePs -ScriptBlock { JEAExecute-Script $using:script $using:signature $using:params }\r\n    return $output\r\n}\r\n\r\n# Code Signing Algorithm\r\n$SNC_HASH_ALGORITHM = \"SHA512\"\r\n\r\n# Load signing certificate\r\nretrieveSigningCert","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_4e040b0753456010347cddeeff7b12a2","name":"JEAUtils.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/b0c9a9a3370002000e4d03488e41f113","value":"b0c9a9a3370002000e4d03488e41f113"},"description":"","source":"","sys_updated_on":"2018-06-15 22:28:14","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"5adc4a4073f213005581b7385ef6a7bc","sys_updated_by":"benjamin.phan","sys_created_on":"2018-06-15 01:33:14","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"ExecuteRemote","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"benjamin.phan","sys_mod_count":"1","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_5adc4a4073f213005581b7385ef6a7bc","name":"ExecuteRemote","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/e97f7010777333000e846558981061fa","value":"e97f7010777333000e846558981061fa"},"description":"Long running command script file","source":"","sys_updated_on":"2019-09-05 23:59:35","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"6d7b2454773333000e846558981061cc","sys_updated_by":"tim.broberg","sys_created_on":"2019-09-05 22:34:39","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"lr.sh","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"tim.broberg","sys_mod_count":"1","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"#!/bin/sh\r\n#\r\n# Service-now.com Long Running Script Wrapper\r\n#\r\n\r\nRUNDIR=\".run.%SSH_LONG_ID%\"\r\nTMPDIR=\"/tmp/$RUNDIR\"\r\nTIMEOUT=%TIMEOUT% # Placeholder for future timeout development\r\n\r\nmkdir $TMPDIR\r\ncd $TMPDIR\r\numask 0077 # Let's keep the files we create to ourselves\r\n\r\n####################\r\n# Create 'stub2' script\r\n####################\r\n\r\nsed 's/^   //' >stub2 << 'MARKITEIGHTDUDE'\r\n   #!/bin/sh\r\n   #\r\n   \r\n   TMPDIR=`pwd`\r\n   touch running\r\n   sh ./command\r\n   echo $?\r\n   cd $TMPDIR\r\n   rm -f running\r\nMARKITEIGHTDUDE\r\n\r\n####################\r\n# Create 'command' script\r\n####################\r\n\r\nsed 's/^   //' >command << 'MARKITEIGHTDUDE'\r\n   #!/bin/sh\r\n   #\r\n   TMPDIR=`pwd`\r\n   %SNCCOMMAND%\r\nMARKITEIGHTDUDE\r\n\r\n####################\r\n# Create 'complete' script\r\n####################\r\n\r\nsed 's/^   //' >complete << 'MARKITEIGHTDUDE'\r\n   #!/bin/sh\r\n   #\r\n   SEPARATOR=\"XXX.run.%SSH_LONG_ID%.XXX\"\r\n\r\n   case \"$0\" in\r\n       \"/\"*)\r\n           TMPDIR=\"`dirname $0`\" ;;\r\n       *)\r\n           TMPDIR=\"`pwd`\"/\"`dirname $0`\" ;;\r\n   esac\r\n\r\n   STATUS=`tail -1 $TMPDIR/nohup.out`\r\n\r\n   sed '$d' < $TMPDIR/nohup.out\r\n   echo $SEPARATOR\r\n   cat $TMPDIR/nohup.out2\r\n\r\n   rm -f $TMPDIR/nohup.out2\r\n   rm -f $TMPDIR/nohup.out\r\n   rm -f $TMPDIR/stub2\r\n   rm -f $TMPDIR/complete\r\n   rm -f $TMPDIR/command\r\n%ADDITIONALFILES_REMOVE%\r\n   rmdir $TMPDIR\r\n   exit $STATUS\r\nMARKITEIGHTDUDE\r\n\r\n####################\r\n# Create additional scripts\r\n####################\r\n\r\n%ADDITIONALFILES_ADD%\r\n\r\n##\r\n\r\nRESULT=`nohup sh ./stub2 1>$TMPDIR/nohup.out 2>$TMPDIR/nohup.out2 3>/dev/null &`\r\nsleep 1\r\necho \"sncrun:$RUNDIR\"\r\nexit 0\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_6d7b2454773333000e846558981061cc","name":"lr.sh","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Main wrapper script for all PowerShell scripts run by the MID Server","source":"","sys_updated_on":"2022-03-18 22:33:25","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"7042cf15376001006b882d465abe5d0b","sys_updated_by":"admin","sys_created_on":"2013-04-04 16:38:42","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"PSScript.ps1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"jimmy.yuan","sys_mod_count":"126","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"Param([string]$computer, [string]$script, [boolean]$useCred, [boolean]$isMid, [boolean]$isDiscovery, [boolean]$debug, [boolean]$logInfo, [string]$logLevel, [boolean]$skipTest, [boolean]$executeRemote, [int]$processTimeout, [boolean]$copyScriptToTarget)\r\n\r\n$global:AutomaticVariables = Get-Variable\r\n\r\n$executingScriptDirectory = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent\r\n$midScriptDirectory = $executingScriptDirectory -replace \"\\\\[\\w]*$\", \"\"\r\n$global:logInfo=$logInfo\r\n$global:logLevel=$logLevel\r\n\r\nimport-module \"$executingScriptDirectory\\Credentials\"  -DisableNameChecking\r\nimport-module \"$executingScriptDirectory\\WMIFetch\"\r\nimport-module \"$executingScriptDirectory\\WMIRunner\"\r\nimport-module \"$executingScriptDirectory\\XMLUtil\"\r\nimport-module \"$executingScriptDirectory\\LaunchProc\"\r\nimport-module \"$executingScriptDirectory\\DiagnosticsUtil\" -DisableNameChecking\r\nimport-module \"$executingScriptDirectory\\PSRemoteSession\" -Global\r\nimport-module \"$executingScriptDirectory\\WinRMAPI\\ExecuteRemote\\ExecuteRemote\"\r\nimport-module \"$executingScriptDirectory\\IH\\Logging\" -DisableNameChecking\r\n\r\nif (Test-Path Env:SNCExecuteRemoteVars) {\r\n    try {\r\n        $remoteVarsVariable = Get-ChildItem -Path Env:SNCExecuteRemoteVars -ErrorAction Stop\r\n    } catch {\r\n        SNCLog-DebugInfo \"Error getting remote variables: $_\"\r\n    }\r\n} else {\r\n    SNCLog-DebugInfo 'SNCExecuteRemoteVars not found in the environment variables'\r\n}\r\n\r\n# translate powershell_param_ environment variables to normal variables\r\nif ($remoteVarsVariable) {\r\n    $paramNamesString = $remoteVarsVariable.Value\r\n    $paramNames = ($paramNamesString -split \",\")\r\n    $paramNames = $paramNames | ForEach-Object {\"Env:$_\"}\r\n    $vars = Get-ChildItem -Path $paramNames\r\n\r\n    Foreach ($var in $vars) {\r\n        $name = $var.Name\r\n        $value = $var.Value\r\n        Set-Variable -Name $name -Value $value -Scope Global\r\n    }\r\n}\r\n\r\n# Copy the environment variables to the params\r\nif (test-path env:\\SNCUser) {\r\n    $Private:userProtected = $env:SNCUser\r\n    $Private:passwordProtected = $env:SNCPass\r\n    $env:SNCUser=''\r\n    $env:SNCPass=''\r\n    $global:encryptedVars=$env:SNCEncryptedVars\r\n}\r\n\r\n# Debugging information ...\r\nSNCLog-PowershellVersion\r\nSNCLog-EnvironmentVars\r\nSNCLog-ParameterInfo @(\"Executing PSScript.ps1\", $computer, $script, $useCred, $isMid, $isDiscovery)\r\n\r\n# This part exposes any arguments that are in addition to the parameters to the current scope\r\nfor ($i = 0; $i -lt $args.count; $i += 2) {\r\n    $value = ''\r\n    if ($i + 1 -lt $args.count) {\r\n        $value = $args[$i + 1]\r\n    }\r\n    if ($value -eq $null) {\r\n        new-variable -name $args[$i] -value $null\r\n    } elseif ($value.getType().Name -eq \"Boolean\") {\r\n        if ($value) {\r\n            new-variable -name $args[$i] -value $true\r\n        } else {\r\n            new-variable -name $args[$i] -value $false\r\n        }\r\n    } else {\r\n        new-variable -name $args[$i] -value $value\r\n    }\r\n\r\n    remove-variable -name value\r\n}\r\n\r\nWrite-SNCGeneralLogs\r\nWrite-SNCLog DEBUG \"`$PSScriptRoot = $PSScriptRoot\"\r\n\r\n# This part attempts to access the target system, just to see if we have access - if using credentials, it tries to figure out\r\n# the appropriate credential checking mechanism by looking for a $credType in the argument list - if it is not set, assume\r\n# WMI\r\nif($credType -eq $null) {\r\n  if(test-path env:\\SNC_credType) {\r\n    $credType=$env:SNC_credType\r\n  }\r\n}\r\n\r\n$cred = $null\r\nif ($credType -eq $null) {\r\n    SNCLog-DebugInfo \"`t`$credType is undefined, defaulting to WMI\"\r\n    $credType = \"WMI\"\r\n}\r\n\r\n$credTestFunc = \"testCredential\" + $credType\r\n$noCredTestFunc = \"testNoCredentialAccess\" + $credType\r\n\r\n#\r\n# This part checks to see if the target host is the mid and if the usecred variable is set to true.  If both are correct the testCredentialGetCred is called in the \r\n# credentials.psm1 module.\r\n#\r\nif($isMid -and $useCred) {\r\n\t$credType = \"GetCred\"\r\n\t$credTestFunc = \"testCredential\" + $credType\r\n} \r\ntry {\r\n    if ($useCred) {\r\n        if ($skipTest) {\r\n            $cred = getCredential $Private:userProtected $Private:passwordProtected\r\n        }\r\n        else {\r\n            $cred = & $credTestFunc -computer $computer -user $Private:userProtected -password $Private:passwordProtected -debug $debug\r\n        }\r\n    } else {\r\n        & $noCredTestFunc -computer $computer -debug $debug\r\n    }\r\n} catch [System.Exception] {\r\n\tWrite-SNCLog ERROR (Format-SNCError $_)\r\n\t[Console]::Error.WriteLine($_.Exception.Message)\r\n\tWrite-SNCLog TRACE \"exit 2\"\r\n\texit 2;\r\n}\r\n\r\n# make $computer and $cred globally available\r\n$global:computer = $computer\r\n$global:cred = $cred\r\n\r\n# This part actually sets up to run the real script\r\n# Format the result in XML for the payload parser - if asked for\r\nif (!$isDiscovery) {\r\n    write-host \"<powershell>\"\r\n    write-host \"<output>\"\r\n}\r\n\r\n# We will attempt to capture any available HRESULT\r\n$hresult = $null\r\n# Run the script file passed in and attempt to catch any exception in the script content \r\n# so the error will be reported on stderr\r\ntry {\r\n\t $ErrorActionPreference = 'Stop'\r\n    # Copy ALL the SNC_* environment variables to PowerShell variables, don't burden users with knowing about environment variable magic\r\n    dir env: | ForEach-Object {\r\n        if ($_.name.StartsWith(\"SNC_\")) {\r\n             # Force it so that we do not get the name clash. It won't overwrite any read-only variable (http://technet.microsoft.com/en-us/library/hh849913.aspx)\r\n             New-Variable -name $_.name.Replace(\"SNC_\", \"\") -value $_.value -Force  \r\n        }\r\n    }\r\n\r\n\t# Show all the variables available (debugging info)\r\n\tSNCLog-Variables\r\n\r\n    if ((!$isMid -and $executeRemote) -or ($script -clike '*filebaseddiscovery*')) {\r\n        executeRemote -computer $computer -filePath $script -wmi $true -cred $cred -copyScriptToTarget:$copyScriptToTarget -launchProcessWaitTime $processTimeout\r\n    } else {\r\n        & $script\r\n    }\r\n} catch [System.UnauthorizedAccessException] {\r\n    # If the credential passed the credential check for logging into the target system, but doesn't have rights to commit\r\n    # the changes (for example: The user can log into AD but cannot create new account), we want to try the next credential. \r\n    Write-SNCLog ERROR (Format-SNCError $_)\r\n    if ($useCred) { \r\n        Write-SNCLog TRACE \"exit 1\"\r\n        exit 1;\r\n    } else {\r\n        Write-SNCLog TRACE \"exit 3\"\r\n        exit 3; // MID Server service user\r\n    }\r\n} catch [System.Exception] {\r\n    Write-SNCLog ERROR (Format-SNCError $_)\r\n    [Console]::Error.WriteLine($_.Exception.Message)\r\n    if ($_.Exception.ErrorCode) {           # Attempt to read HRESULT provided by an ExternalException\r\n        $hresult = $_.Exception.ErrorCode\r\n    } elseif ($_.Exception.HResult) {      # Attempt to read HRESULT provided by an Exception\r\n        $hresult = $_.Exception.HResult\r\n    }\r\n    if ($hresult) {\r\n        [Console]::Error.WriteLine(\"HRESULT: [\" + $hresult + \"]\")\r\n    }\r\n    if ($debug) {\r\n        [Console]::Error.WriteLine(\"`r`n Stack Trace: \" + $_.Exception.StackTrace)\r\n    }\r\n    if ($isMid) {\r\n         if($useCred) {\r\n         Write-SNCLog TRACE \"exit 1\"\r\n         exit 1\r\n        } else {\r\n         Write-SNCLog TRACE \"exit 4\"\r\n         exit 4\r\n        }\r\n    } else {\r\n        Write-SNCLog TRACE \"exit 4\"\r\n        exit 4\r\n    }\r\n} finally {\r\n    if (!$isDiscovery) {\r\n        write-host \"</output>\"\r\n        if ($hresult) {\r\n            write-host \"<hresult>$hresult</hresult>\"\r\n        }\r\n        write-host \"</powershell>\"\r\n    }\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_7042cf15376001006b882d465abe5d0b","name":"PSScript.ps1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/b0c9a9a3370002000e4d03488e41f113","value":"b0c9a9a3370002000e4d03488e41f113"},"description":"","source":"","sys_updated_on":"2015-05-21 22:12:04","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"72c33456372331000e4d03488e41f101","sys_updated_by":"will.swift","sys_created_on":"2015-04-23 00:30:49","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"Credentials","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"3","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_72c33456372331000e4d03488e41f101","name":"Credentials","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/a3644866ff614110ab35224b793bf1c3","value":"a3644866ff614110ab35224b793bf1c3"},"description":"Manages logging","source":"","sys_updated_on":"2022-03-18 22:24:49","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"88a44c66ff614110ab35224b793bf1ad","sys_updated_by":"admin","sys_created_on":"2022-02-11 04:05:37","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"Logging.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"admin","sys_mod_count":"14","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"$executingScriptDirectory = Split-Path -Path $PSScriptRoot -Parent\r\nImport-Module  \"$executingScriptDirectory\\DiagnosticsUtil\" -DisableNameChecking\r\n\r\n<# \r\n.SYNOPSIS\r\n\r\nLog message at log level.\r\n\r\n.DESCRIPTION\r\n\r\nCompares the Level parameter to global log level and logs Message parameter if necessary.\r\nIf there is no global log level set, no messages at any level will be logged.\r\n\r\n.PARAMETER Message\r\nSpecifies the message to log.\r\n\r\n.PARAMETER Level\r\nSpecifies the log level of ERROR, WARN, INFO, DEBUG, or TRACE.\r\n\r\n.EXAMPLE\r\n\r\n# Log an error message.\r\n# If the global log level is ERROR, WARN, INFO, DEBUG, or TRACE the message will be logged.\r\nWrite-SNCLog -Level ERROR -Message \"message\"\r\n\r\n.EXAMPLE\r\n\r\n# Log a warning message.\r\n# If the global log level is WARN, INFO, DEBUG, or TRACE the message will be logged.\r\nWrite-SNCLog -Level WARN -Message \"message\"\r\n\r\n.EXAMPLE\r\n\r\n# Log an informational message.\r\n# If the global log level is INFO, DEBUG, or TRACE the message will be logged.\r\nWrite-SNCLog -Level INFO -Message \"message\"\r\n\r\n.EXAMPLE\r\n\r\n# Log a debug message.\r\n# Only if the global log level is DEBUG or TRACE will the message be logged.\r\nWrite-SNCLog -Level DEBUG -Message \"message\"\r\n\r\n.EXAMPLE\r\n\r\n# Log a trace message.\r\n# Only if the global log level is TRACE will the message be logged.\r\nWrite-SNCLog -Level TRACE -Message \"message\"\r\n\r\n#>\r\nFunction Write-SNCLog {\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Parameter(Mandatory = $True, HelpMessage = \"Level: ERROR, WARN, INFO, DEBUG, or TRACE\")]\r\n        [ValidateSet('ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE')]\r\n        [string]$Level,\r\n        [Parameter(Mandatory = $False)]\r\n        [string]$Message\r\n    )\r\n\r\n    $InternalObfuscated = \"[snc_internal]\"\r\n\r\n    $LOG_LEVELS = @{'ERROR' = 1; 'WARN' = 2; 'INFO' = 3; 'DEBUG' = 4; 'TRACE' = 5}\r\n\r\n    if ([string]::IsNullOrEmpty($message)) {\r\n        return\r\n    }\r\n\r\n    if ([string]::IsNullOrEmpty($Global:LogLevel) -or (-not ($Global:LogLevel -in $LOG_LEVELS.keys))) {\r\n        return\r\n    }\r\n\r\n    if ($LOG_LEVELS.$Level -le $LOG_LEVELS.$Global:LogLevel) {\r\n        $Message = $Message.replace($global:SncLogPrefix, $InternalObfuscated);\r\n        $Message = $Message.replace($global:SncLogSuffix, $InternalObfuscated);\r\n        SNCLog-DebugInfo (\"{0}: {1}\" -f $Level.ToUpper(), $Message)\r\n    }\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\n\r\nFormats PowerShell ErrorRecord.\r\n\r\n.DESCRIPTION\r\n\r\nWhen an exception is caught, the automatic variable $_ or $PSItem\r\nis a PowerShell ErrorRecord. You can pass this ErrorRecord to\r\nthis function to get a formatted string suitable for logging.\r\n\r\nExample:\r\n\r\nInvoke-CmdLetNotThere : The term 'Invoke-CmdLetNotThere' is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\r\nAt [path_to_mid]\\agent\\scripts\\PowerShell\\Custom\\Custom.ps1:14 char:1\r\n+ Invoke-CmdLetNotThere\r\n+ ~~~~~~~~~~~~~~~~~~~~~\r\n+ CategoryInfo          : ObjectNotFound: (Invoke-CmdLetNotThere:String) [], CommandNotFoundException\r\n+ FullyQualifiedErrorId : CommandNotFoundException\r\n\r\n+ HRESULT               : [-2146233087]\r\n+ Stacktrace            :\r\nat System.Management.Automation.CommandDiscovery.LookupCommandInfo(String commandName, CommandTypes commandTypes, SearchResolutionOptions searchResolutionOptions, CommandOrigin commandOrigin, ExecutionContext context)\r\nat System.Management.Automation.CommandDiscovery.LookupCommandProcessor(String commandName, CommandOrigin commandOrigin, Nullable`1 useLocalScope)\r\nat System.Management.Automation.ExecutionContext.CreateCommand(String command, Boolean dotSource)\r\nat System.Management.Automation.PipelineOps.AddCommand(PipelineProcessor pipe, CommandParameterInternal[] commandElements, CommandBaseAst commandBaseAst, CommandRedirection[] redirections, ExecutionContext context)\r\nat System.Management.Automation.PipelineOps.InvokePipeline(Object input, Boolean ignoreInput, CommandParameterInternal[][] pipeElements, CommandBaseAst[] pipeElementAsts, CommandRedirection[][] commandRedirections, FunctionContext funcContext)\r\nat System.Management.Automation.Interpreter.ActionCallInstruction`6.Run(InterpretedFrame frame)\r\nat System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction.Run(InterpretedFrame frame)\r\n\r\n.PARAMETER CaughtError\r\n\r\nThe instance of ErrorRecord that you wish to format.\r\n\r\n.OUTPUTS\r\n\r\nThe formatted string representing the ErrorRecord.\r\n#>\r\nFunction Format-SNCError {\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Parameter(Mandatory = $True)]\r\n        [System.Management.Automation.ErrorRecord]$CaughtError\r\n    )\r\n\r\n    $ErrorFormat =\r\n    \"{0}\" +\r\n    \"    + HRESULT               : [{1}]`n\" +\r\n    \"    + Stacktrace            :`n{2}`n\"\r\n\r\n    $ErrorInfo =\r\n        ($CaughtError | Out-String),\r\n        $CaughtError.Exception.HResult,\r\n        $CaughtError.Exception.StackTrace\r\n\r\n    $ErrorFormat -f $ErrorInfo\r\n}\r\n\r\n<#\r\n.SYNOPSIS\r\n\r\nLog general messages related to ServiceNow PowerShell execution.\r\n#>\r\nFunction Write-SNCGeneralLogs {\r\n    [CmdletBinding()]\r\n    Param ()\r\n\r\n    $originalErrorActionPreference = $ErrorActionPreference\r\n    # Don't halt functionality if logging error occurs.\r\n    $ErrorActionPreference = 'SilentlyContinue'\r\n\r\n    # PowerShell\r\n    $VersionTableString = $PSVersionTable.GetEnumerator() | % { \"$($_.Name) = [$($_.Value)] `n\" }\r\n    Write-SNCLog DEBUG \"`$PSVersionTable: `n$VersionTableString\"\r\n    Write-SNCLog DEBUG \"`$ErrorActionPreference = $originalErrorActionPreference\"\r\n    Write-SNCLog DEBUG \"`$PID = $PID\"\r\n\r\n    # MID\r\n    Write-SNCLog DEBUG \"`$env:WRAPPER_WORKING_DIR = $env:WRAPPER_WORKING_DIR\"\r\n\r\n    # Env\r\n    Write-SNCLog DEBUG \"`$env:UserName = $env:UserName\"\r\n    Write-SNCLog DEBUG \"`$env:UserDomain = $env:UserDomain\"\r\n    Write-SNCLog DEBUG \"`$env:ComputerName = $env:ComputerName\"\r\n    Write-SNCLog DEBUG \"`$env:LogonServer = $env:LogonServer\"\r\n\r\n    $WinId = [System.Security.Principal.WindowsIdentity]::GetCurrent()\r\n    $WinPrincipal = [System.Security.Principal.WindowsPrincipal]$WinId\r\n    Write-SNCLog DEBUG (\"User = [{0}], System = {1}, Administrator = {2}\" -f\r\n        $WinId.Name,\r\n        $WinId.IsSystem,\r\n        $WinPrincipal.IsInRole('Administrators'))\r\n\r\n    $ErrorActionPreference = $originalErrorActionPreference\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_88a44c66ff614110ab35224b793bf1ad","name":"Logging.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Nmap Installation","source":"","sys_updated_on":"2022-04-12 00:00:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"8e1694209f3803005581decf857fcf5e","sys_updated_by":"christopher.thompson","sys_created_on":"2017-08-21 23:54:58","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"NmapInstallation.ps1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"thanh.phan","sys_mod_count":"13","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"Param(\r\n    [string]$operation,\r\n    [string]$nmap_root_path,\r\n    [string]$nmap_self_installer,\r\n    [string]$nmap_command,\r\n    [string]$nmap_uninstall_command,\r\n    [string]$nmap_npcap_version,\r\n    [string]$nmap_safe_scripts\r\n)\r\n\r\n# PowerShell seems to have a lot of delay in when the installed files are actually accessible.\r\n# These variables control the number of retries and delay while waiting for them.\r\n$retries = 60\r\n$retryDelay = 2;\r\n\r\n# Remove the Nmap directory and its contents. \r\n# In the case that Nmap was installed it uninstalls Nmap first.\r\nFunction clean-nmap-folder {\r\n    Write-Host \"Checking for existing Nmap installation at $nmap_root_path\"\r\n    if (Test-Path -Path $nmap_root_path) {\r\n        Write-Host \"...found existing Nmap installation at $nmap_root_path\"\r\n        Write-Host \"Checking for existing Nmap uninstaller $nmap_uninstall_command\"\r\n        if (Test-Path -Path $nmap_uninstall_command) {\r\n            Write-Host \"...found existing Nmap uninstaller, executing uninstaller\"\r\n            & $nmap_uninstall_command /S > $null \r\n        }\r\n\r\n        delete-nmap-folder\r\n\r\n    } else {\r\n        Write-Host \"...$nmap_root_path not found\"\r\n    }\r\n }\r\n\r\n# Delete the Nmap directory and its contents. \r\n# In the case that Nmap was installed it uninstalls Nmap first.\r\nFunction delete-nmap-folder {\r\n    Write-Host \"Deleting Nmap directory $nmap_root_path\"\r\n    for ($i=0; $i -le $retries; $i++) {\r\n        try {   \r\n            Remove-Item -Recurse -Force $nmap_root_path\r\n            if ($?) {\r\n                Write-Host \"Nmap directory $nmap_root_path deleted\"\r\n                return\r\n            }\r\n        } catch {\r\n            Write-Host \"Error removing $nmap_root_path, $_\"\r\n        }\r\n\r\n        Write-Host \"Unable to remove $nmap_root_path, waiting $retryDelay seconds...\"\r\n        Start-Sleep -s $retryDelay\r\n    }\r\n\r\n    Write-Host \"Unable to delete $nmap_root_path\"\r\n }\r\n\r\nFunction install-nmap { \r\n    Write-Host \"Checking free space on $(get-location).Drive.Name\"\r\n    $free_size = $($(get-psdrive $(get-location).Drive.Name).Free)/1MB\r\n    if ($free_size -le 10) {\r\n        Write-Error  \"Unable to install Nmap: Not enough disk space to install Nmap with $free_size MB remaining\"\r\n        clean-nmap-folder\r\n        Exit 4\r\n    }\r\n    Write-Host \"...enough disk space to install Nmap\"\r\n\r\n    $nmap_installer_params = \"/S /REGISTERPATH=NO /ZENMAP=NO\"\r\n    # Checks if a higher version of Npcap is installed on the machine then adds NPCAP=NO to prevent re-installing Npcap\r\n    $def_version = [System.Version] \"0.0\"\r\n    if ($nmap_npcap_version -ne $def_version) {\r\n        if (npcap-was-installed) {\r\n             $nmap_installer_params = \"$nmap_installer_params  /NPCAP=NO\"\r\n         }\r\n     }\r\n    # Install Nmap in the silent mode&\r\n    $installer_cmd = \"& `\"$nmap_self_installer`\" $nmap_installer_params /D=$nmap_root_path\"\r\n\r\n    Write-Host \"Installing Nmap: $installer_cmd\"\r\n\r\n    Invoke-Expression $installer_cmd\r\n    if (-Not $?) {\r\n        Write-Error \"Unable to install Nmap: $Error[0].ToString()\"\r\n        clean-nmap-folder\r\n        Exit 4\r\n    }\r\n\r\n    # Verify Nmap installation\r\n    $nv = verify-nmap\r\n\r\n    # Select safe scripts\r\n    provide-safe-db\r\n\r\n    Write-Host \"Nmap $nv was installed successfully \"\r\n}\r\n\r\n#Check if a higher version of npcap was installed on the machine\r\nFunction npcap-was-installed {\r\n    $registery_path = \"HKLM:\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\NpcapInst\"\r\n    \r\n    # Verify if Npcap was installed\r\n    if (-Not (Test-Path -Path $registery_path)) {\r\n        return $false\r\n    }\r\n   \r\n    # Verify if a higher verion of Npcap is available \r\n    $npcap_version = [String](Get-ItemProperty $registery_path -Name \"DisplayVersion\").\"DisplayVersion\"\r\n    if (-Not (compatible-npcap-version  $npcap_version $nmap_npcap_version)) {\r\n        return $false\r\n    }\r\n \r\n    Write-Host \"Npcap$nmap_npcap_version is not installed: Npcap$npcap_version was already installed\"\r\n    return $true\r\n}\r\n\r\n# Compare two npcap versions. Npcap version format follows the system format xx.xx.xx or\r\n# some times is like xx.xx.xx-rx. the following funtion returns\r\n# It returns true if version1 is the same as/ higher than version2 otherwise it returns false\r\nFunction compatible-npcap-version($version1, $version2) {\r\n    $version1_parts = $version1.Split(\"-r\", [System.StringSplitOptions]::RemoveEmptyEntries)\r\n    $version2_parts = $version2.Split(\"-r\", [System.StringSplitOptions]::RemoveEmptyEntries)\r\n\r\n    # Compare the first part of the version that follows Standard Version format\r\n    if ([System.Version]$version1_parts[0] -gt [System.Version]$version2_parts[0]) {\r\n         return $true\r\n     }\r\n     if ([System.Version]$version1_parts[0] -lt [System.Version]$version2_parts[0]) {\r\n        return $false\r\n     }\r\n\r\n     # If one of versions doesn't have -r part\r\n     if ($version1_parts.length -gt $version2_parts.length) {\r\n        return $true\r\n     }\r\n     if ($version1_parts.length -lt $version2_parts.length) {\r\n        return $false\r\n     }\r\n\r\n     # Compare the second part of the version after -r (not Standard Version)\r\n     if ([convert]::ToInt32($version1_parts[1], 10) -ge [convert]::ToInt32($version2_parts[1], 10)) {\r\n         return $true\r\n     }\r\n     return $false\r\n }\r\n\r\nFunction verify-nmap {\r\n    # Because of directory caching, the Nmap executable may not appear yet so wait for it\r\n    for ($i=0; $i -le $retries; $i++) {\r\n        if (Test-Path \"$nmap_command\") {\r\n            Write-Host \"$nmap_command ready\"\r\n            break\r\n        }\r\n        Write-Host \"$nmap_command does not exist yet, waiting $retryDelay seconds...\"\r\n        Start-Sleep -s $retryDelay\r\n    }\r\n\r\n    # Verify Nmap version\r\n    Write-Host \"Verifying Nmap installation\"\r\n    for ($i=0; $i -le $retries; $i++) {\r\n        $version_info = & \"$nmap_command\" --version\r\n        if ($?) {\r\n            #Success, return version\r\n            Write-Host $version_info\r\n            # For 7.92 OEM Version, first line has value like this below\r\n            # Nmap OEM version 7.92 ( https://nmap.org )\r\n            $version_number = $version_info[0].split()[3]\r\n            if(-not ($version_number)) {\r\n                # For 7.50 Version, first line is empty and second line is like below\r\n                # Nmap version 7.50 ( https://nmap.org )\r\n                $version_number = $version_info[1].split()[2]\r\n            }\r\n            return $version_number\r\n        }\r\n\r\n        Write-Host \"Unable to verify Nmap installed version, waiting $retryDelay seconds...\"\r\n        Start-Sleep -s $retryDelay\r\n    }\r\n\r\n    # If we got here, it failed after all retries\r\n    Write-Error \"Timeout: Unable to verify Nmap installed version\"\r\n    clean-nmap-folder\r\n    Exit 4\r\n}\r\n\r\n\r\nFunction provide-safe-db {\r\n    $script_path = $nmap_root_path + \"\\scripts\\*\"\r\n    $safe_script_path = $nmap_root_path + \"\\safeScripts\"\r\n\r\n    $safe_db = delete-unsafe-scripts $script_path\r\n\r\n    $lastStatus = $false \r\n    for ($i=0; $i -le $retries; $i++) {\r\n        & $nmap_command --script-updatedb > $null\r\n        $lastStatus = $?\r\n        if ($lastStatus) {\r\n            Write-Host  \"Nmap safe scripts DB updated\"\r\n            break\r\n        }\r\n\r\n        Write-Host \"Unable to update the script database with safe scripts, waiting $retryDelay seconds...\"\r\n        Start-Sleep -s $retryDelay\r\n    }\r\n\r\n    if (-Not $lastStatus) {\r\n            Write-Error  \"Timeout: Unable to update the script database with safe scripts: $Error[0].ToString()\"\r\n            clean-nmap-folder\r\n            Exit 4\r\n    }\r\n\r\n    try {\r\n        New-Item -ItemType directory -Path $safe_script_path > $null\r\n    } catch {\r\n        Write-Error  \"Unable to create nmap directory under agent directory for this MID Server. $_\"\r\n        clean-nmap-folder         \r\n        Exit 4\r\n    }\r\n\r\n    Copy-Item -Path \"$script_path\" -Destination \"$safe_script_path\"\r\n    Write-Host \"Safe scripts compiled to $safe_script_path\"\r\n}\r\n\r\n\r\n\r\nFunction delete-unsafe-scripts ($db_scripts_path) {\r\n    $safe_script_names = $nmap_safe_scripts.split(\", \")\r\n    $scripts = Get-ChildItem -Path \"$db_scripts_path\" -Filter *.nse\r\n\r\n    for ($i=0 ; $i -le $retries; $i++) {\r\n        foreach ($file in $scripts) {\r\n            if (-Not ($safe_script_names -contains $file.Name)) {\r\n                Remove-Item -Path \"$file\"\r\n            }\r\n        }\r\n        $scripts = Get-ChildItem -Path \"$db_scripts_path\" -Filter *.nse\r\n        if (unsafe-db $safe_script_names $scripts) {\r\n            Write-Host \"Unable to delete all unsafe scripts from database, waiting $retryDelay seconds...\"\r\n            Start-Sleep -s $retryDelay\r\n        } else {\r\n            return $true; \r\n        }\r\n    }\r\n    # If we got here, it failed after all retries\r\n    Write-Error \"Timeout: Unable to delete all unsafe scripts\"\r\n    clean-nmap-folder\r\n    Exit 4\r\n\r\n}\r\n\r\nFunction unsafe-db ($script_names, $scripts) {\r\n    foreach ($file in $scripts) {\r\n        if (-not ($script_names -contains $file.Name)) {\r\n             return $true\r\n        }\r\n    }\r\n    return $false\r\n}\r\n\r\n# Uninstall Nmap in the silent mode and remove the Nmap folder in the agent folder. \r\nFunction uninstall-nmap {\r\n    Write-Host \"Checking for existing Nmap installation at $nmap_root_path\"\r\n    if (-Not (Test-Path -Path \"$nmap_root_path\")) {\r\n        Write-Error \"Unable to uninstall Nmap. $nmap_root_path does not exist\"\r\n        Exit 4\r\n    }\r\n\r\n    Write-Host \"Checking for existing Nmap uninstaller $nmap_uninstall_command\"\r\n    if (-Not (Test-Path -Path \"$nmap_uninstall_command\")) {\r\n        Write-Error \"Unable to uninstall Nmap. $nmap_uninstall_command does not exist\"\r\n        Exit 4\r\n    }\r\n\r\n    Write-Host \"Executing Nmap uninstaller $nmap_uninstall_command\"\r\n    & $nmap_uninstall_command /S\r\n    if (-Not $?) {\r\n        Write-Error \"Unable to uninstall Nmap: $Error[0].ToString()\"\r\n        Exit 4\r\n    }\r\n\r\n    delete-nmap-folder\r\n}\r\n\r\nswitch ($operation) {\r\n    \"clean\" { clean-nmap-folder }\r\n    \"install\" { install-nmap }\r\n    \"uninstall\" { uninstall-nmap }\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_8e1694209f3803005581decf857fcf5e","name":"NmapInstallation.ps1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Collection of methods for managing XML content, primarily used to construct a payload to send to the instance","source":"","sys_updated_on":"2019-08-19 18:21:37","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"9ba30755376001006b882d465abe5d0b","sys_updated_by":"tyler.woodard","sys_created_on":"2013-04-04 16:44:11","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"XMLUtil.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"jimmy.yuan","sys_mod_count":"1","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"function createXmlDocument {\r\n    return new-object System.Xml.XmlDocument\r\n}\r\n\r\nfunction createElement {\r\n    param([System.Xml.XmlDocument]$xmlDocument, [string]$name, [string]$value = \"\")\r\n\r\n    if (!$xmlDocument) {\r\n        return $null\r\n    }\r\n    \r\n    $newElement = $xmlDocument.createElement($name)\r\n    $newElement.InnerText = $value\r\n    return $newElement\r\n}\r\n\r\nfunction createElementWithAttribute {\r\n    param([System.Xml.XmlDocument]$xmlDocument, [string]$name, [string]$attributeName, [string]$attributeValue)\r\n\r\n    if (!$xmlDocument) {\r\n        return $null;\r\n    }\r\n    \r\n    $newElement = $xmlDocument.createElement($name);\r\n    $newElement.SetAttribute($attributeName, $attributeValue);\r\n    return $newElement\r\n}\r\n\r\nfunction addAttribute {\r\n    param([System.Xml.XmlElement]$xmlElement, [string]$attributeName, [string]$attributeValue)\r\n    \r\n    $xmlElement.SetAttribute($attributeName, $attributeValue);\r\n}\r\n\r\nfunction getChild {\r\n    param([System.Xml.XmlNode]$xmlNode, [string]$name)\r\n    \r\n    if (!$xmlNode.HasChildNodes) {\r\n        return $null;\r\n    }\r\n    \r\n    $children = $xmlNode.ChildNodes;\r\n    foreach ($child in $children) {\r\n        if ($child.Name -eq $name) {\r\n            return $child;\r\n        }\r\n    }\r\n    \r\n    return $null;\r\n}\r\n\r\nfunction getChildWithNameAndAttribute {\r\n    param([System.Xml.XmlNode]$xmlNode, [string]$name, [string]$attributeName, [string]$attributeValue)\r\n    \r\n    if (!$xmlNode.HasChildNodes) {\r\n        return $null;\r\n    }\r\n    \r\n    $children = $xmlNode.ChildNodes;\r\n    foreach ($child in $children) {\r\n        if ($child.Name -eq $name -and $child.Attributes.Count -ne 0) {\r\n            $value = $child.Attributes.ItemOf($attributeName);\r\n\r\n            if ($value -and $value.Value -eq $attributeValue) {\r\n                return $child;\r\n            }\r\n        }\r\n    }\r\n    \r\n    return $null;\r\n}\r\n\r\nfunction appendChild {\r\n    param([System.Xml.XmlNode]$parent, [System.Xml.XmlNode]$child)\r\n    \r\n    if ($parent -and $child) {\r\n        $ignore = $parent.appendChild($child)\r\n    }\r\n}\r\n\r\nfunction getXmlString {\r\n    param([System.Xml.XmlDocument]$xmlDocument)\r\n    \r\n    if (!$xmlDocument) {\r\n        return \"\"\r\n    }\r\n        \r\n    $stringWriter = new-object System.IO.StringWriter\r\n    $xmlTextWriter = new-object System.Xml.XmlTextWriter($stringWriter)\r\n    $xmlDocument.WriteTo($xmlTextWriter)\r\n    return $stringWriter.toString()\r\n}\r\n\r\nfunction addNewLineToNode {\r\n    param([System.Xml.XmlNode]$parent, [System.Xml.XmlDocument]$xmlDocument)\r\n    \r\n    $newLineNode = $xmlDocument.CreateWhitespace(\"`n\");\r\n    appendChild -parent $parent -child $newLineNode;\r\n}\r\n\r\nfunction addNewLineToDocument {\r\n    param([System.Xml.XmlDocument]$xmlDocument)\r\n    \r\n    $newLineNode = $xmlDocument.CreateWhitespace(\"`n\");\r\n    appendChild -parent $xmlDocument -child $newLineNode;\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_9ba30755376001006b882d465abe5d0b","name":"XMLUtil.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Contains the logic for running a WMIRunner probe.","source":"","sys_updated_on":"2024-08-28 11:34:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"9de98e40736300102535b7385ef6a757","sys_updated_by":"now.midserver","sys_created_on":"2020-03-09 20:41:06","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"WMIRunner.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"benjamin.phan","sys_mod_count":"9","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"function executeWMIRunner {\r\n    param([bool]$useTargetPowerShell=$(throw 'The useTargetPowerShell boolean parameter is required'),\r\n          [string]$wmiFetchData=$(throw 'The wmiFetchData parameter is required.'),\r\n          [bool]$filterHotfix=$(throw 'The filterHotfix boolean parameter is required'),\r\n          # default outputFormat is xml\r\n          [string]$outputFormat='xml', [int]$launchProcessWaitTime = 300)\r\n\r\n    SNCLog-DebugInfo \"WMIRunner useTargetPowerShell: $useTargetPowerShell\";\r\n    SNCLog-DebugInfo \"WMIRunner wmiFetchData: $wmiFetchData\";\r\n    SNCLog-DebugInfo \"WMIRunner filterHotfix: $filterHotfix\";\r\n    SNCLog-DebugInfo \"WMIRunner launchProcessWaitTime: $launchProcessWaitTime\";\r\n    \r\n    filterHotfix -value $filterHotfix;\r\n    if ($useTargetPowerShell) {\r\n        # new WMI discovery path\r\n        SNCLog-DebugInfo 'Running WMIRunner new path';\r\n        SNCLog-DebugInfo \"WMIRunner new WMI discovery outputFormat: $outputFormat\";\r\n\r\n        # new WMI discovery uses target's PowerShell to fetch all WMI fields/registry values at once\r\n        fetchMultipleWMI -WMI_FetchData $wmiFetchData -wmi $true -output_format $outputFormat -computer $computer -cred $cred -launchProcessWaitTime $launchProcessWaitTime;\r\n        return;\r\n    }\r\n\r\n    # legacy WMI discovery\r\n    SNCLog-DebugInfo 'Running WMIRunner legacy path';\r\n    $wmiFetchData -split ',' | ForEach-Object {\r\n        addFetch -entry $_;\r\n    }\r\n    fetch -computer $computer -cred $cred;\r\n}\r\n\r\nfunction executeWindowsClassify {\r\n    param([string]$wmiFetchData=$(throw 'The wmiFetchData parameter is required.'),\r\n          [bool]$filterHotfix=$(throw 'The filterHotfix boolean parameter is required'),\r\n          [string]$outputFormat='xml', [int]$launchProcessWaitTime = 300)\r\n    # Windows Classify needs to check and output the remoting capabilities\r\n    SNCLog-DebugInfo 'Windows Classify testing remoting capabilities';\r\n    testRemotingCapabilities;\r\n    SNCLog-DebugInfo 'Windows Classify performing WMIRunner fetches';\r\n    executeWMIRunner -useTargetPowerShell $powerShellAccess -wmiFetchData $wmiFetchData -filterHotfix $filterHotfix -outputFormat $outputFormat -launchProcessWaitTime $launchProcessWaitTime;\r\n}\r\n\r\n\r\nfunction testRemotingCapabilities {\r\n    # test target admin share access and target's PowerShell capabilities\r\n    if ($cred) {\r\n        if (-not $cred.GetNetworkCredential().Domain) {\r\n            SNCLog-DebugInfo \"Credential has no domain, formatting credential user to 'fqdn\\user'\";\r\n            $username = formatUser -cred $cred;\r\n            if($username -ne $cred.username) {\r\n                SNCLog-DebugInfo \"Rebuild credential with $username\";\r\n                $global:cred = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $cred.password;\r\n            }\r\n        }\r\n        SNCLog-DebugInfo \"Beginning admin share access test with cred: $($cred.username)\";\r\n        # impersonate credential to access network path\r\n        $context = startImpersonation -cred $cred;\r\n        # test admin share access\r\n        $global:adminShareAccess = Test-Path -Path \"\\\\$computer\\admin$\" -ErrorAction SilentlyContinue;\r\n        endImpersonation -context $context;\r\n    } else {\r\n        SNCLog-DebugInfo 'Beginning admin share access test with no cred';\r\n        # test admin share access\r\n        $global:adminShareAccess = Test-Path -Path \"\\\\$computer\\admin$\" -ErrorAction SilentlyContinue;\r\n    }\r\n    SNCLog-DebugInfo \"admin share access: $adminShareAccess\";\r\n\r\n    if ($adminShareAccess) {\r\n        $testString = 'execute remote test passed';\r\n        $testScript = \"& { '$testString' }\";\r\n        # test PowerShell access\r\n        try {\r\n            SNCLog-DebugInfo 'Beginning PowerShell access test';\r\n            $res = executeRemote -computer $computer -cred $cred -wmi $true -scriptBlock $testScript -ErrorAction SilentlyContinue;\r\n        } catch {} finally {\r\n            $global:powerShellAccess = $res -ne $null -and ($res.Trim() -eq $testString);\r\n        }\r\n    } else {\r\n        $global:powerShellAccess = $False;\r\n    }\r\n    SNCLog-DebugInfo \"PowerShell access: $powerShellAccess\";\r\n\r\n    # output remoting capability values\r\n    \"__SNC_ADMIN_SHARE{$($adminShareAccess.ToString().ToLower())}SNC_ADMIN_SHARE__\";\r\n    \"__SNC_POWERSHELL{$($powerShellAccess.ToString().ToLower())}SNC_POWERSHELL__\";\r\n}\r\n<######################\r\n # Read FQDN (Fully Qualified Domain Name) without hostname of target host\r\n ######################>\r\nfunction getFqdnByWmi {\r\n\tparam([System.Management.Automation.PSCredential]$cred)\r\n\tSNCLog-DebugInfo \"WMI Reading $computer FQDN with user: $($cred.username) and isMid: $global:isMid\";\r\n\ttry {\r\n\t\tif($global:isMid -eq $False) {\r\n\t\t\t$fqdn = (get-wmiobject -computer $computer -credential $cred -query 'select * from win32_computersystem').Domain;\r\n\t\t} else {\r\n\t\t\t$fqdn = (get-wmiobject -computer $computer -query 'select * from win32_computersystem').Domain;\r\n\t\t}\r\n\t\tSNCLog-DebugInfo \"Target host $computer FQDN=$fqdn\";\r\n\t\treturn $fqdn;\r\n\t} catch [System.UnauthorizedAccessException] {\r\n\t\tSNCLog-DebugInfo \"`tInvalid credential for WMI, unauthorized access exception\";\r\n\t\treturn '';\r\n\t} catch [System.Exception] {\r\n\t\tSNCLog-DebugInfo \"`tSystem.Exception : $_.Exception.Message\";\r\n\t\treturn '';\r\n\t}\r\n}\r\n<######################\r\n # For user in format 'user' or 'user@domain', change to FQDN format 'FQDN\\user'\r\n ######################>\r\nfunction formatUser {\r\n\tparam([System.Management.Automation.PSCredential]$cred)\r\n\t$creduser = $cred.username;\r\n\tSNCLog-DebugInfo \"WMI Input credential user=$creduser\";\r\n\tif ($creduser.IndexOf(\"\\\") -gt 0 -Or $creduser.IndexOf(\"@\") -eq 0) {\r\n\t    return $creduser;\r\n    }\r\n    $UserArray = $null;\r\n    if($creduser.IndexOf(\"@\") -gt 0) {\r\n        $UserArray = $creduser.Split(\"@\");\r\n\t\tif($UserArray.Length -ne 2 -Or -not $UserArray[0]) {\r\n\t\t\treturn $creduser;\r\n\t\t}\r\n    }\r\n\t$fqdn = getFqdnByWmi -cred $cred;\r\n\tif(-not $fqdn) {\r\n\t\t # Check with customer if FQDN is not set for target host or exception during reading\r\n\t\tSNCLog-DebugInfo \"FQDN is empty for $computer\";\r\n\t\treturn $creduser;\r\n\t} \r\n    if($creduser.IndexOf(\"@\") -lt 0) {\r\n\t\t$creduser = $fqdn + \"\\\" + $creduser;\r\n\t} else {\r\n\t\t$creduser = $fqdn + \"\\\" + $UserArray[0];\r\n\t} \r\n\tSNCLog-DebugInfo \"WMI changed user=$creduser\";\r\n\treturn $creduser;\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_9de98e40736300102535b7385ef6a757","name":"WMIRunner.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Folder containing script files for IntegrationHub","source":"","sys_updated_on":"2022-02-11 04:02:07","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"a3644866ff614110ab35224b793bf1c3","sys_updated_by":"admin","sys_created_on":"2022-02-11 04:02:07","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"IH","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"admin","sys_mod_count":"0","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_a3644866ff614110ab35224b793bf1c3","name":"IH","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/b0c9a9a3370002000e4d03488e41f113","value":"b0c9a9a3370002000e4d03488e41f113"},"description":"","source":"","sys_updated_on":"2015-05-21 22:11:48","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"af2f7456372331000e4d03488e41f1b1","sys_updated_by":"will.swift","sys_created_on":"2015-04-23 01:20:20","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"PSRemoteScript","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"2","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_af2f7456372331000e4d03488e41f1b1","name":"PSRemoteScript","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"","source":"","sys_updated_on":"2015-05-21 22:10:50","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"b0c9a9a3370002000e4d03488e41f113","sys_updated_by":"will.swift","sys_created_on":"2015-05-21 22:10:21","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"WinRMAPI","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"1","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_b0c9a9a3370002000e4d03488e41f113","name":"WinRMAPI","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/38ed7937efa5010098d5925495c0fb0d","value":"38ed7937efa5010098d5925495c0fb0d"},"description":"A wrapper to include WMIScanner","source":"","sys_updated_on":"2013-06-01 00:07:38","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"b6fdf97bef65010098d5925495c0fb57","sys_updated_by":"aleck.lin","sys_created_on":"2013-05-31 23:06:46","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"WMIRunner.js","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"aleck.lin","sys_mod_count":"1","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"//\r\n// WMIRunner - main class for running WMI stuff.  This is used as a wrapper\r\n// to include WMIScanner before any scripts are run. That way we have a API\r\n// for WMI related things\r\n//\r\n// Bow Ruggeri\r\n//\r\n\r\nvar WMISCANNER = \"scripts\\\\WMI\\\\WMIScanner.js\";\r\n\r\nvar gScanner;\r\nvar gCurrentFile;\r\nvar gCurrentMachine;\r\nvar gDebug;\r\n\r\nvar args = getOpts();\r\nincludeJS(WMISCANNER);\r\n\r\ntry {\r\n\tif (getScanner().wmiOpen()) {\r\n    \r\n\t\t// Include the files\r\n\t\tfor(var i = 0; i < args.length; i++)\r\n\t\t    includeJS(args[i]);\r\n\t\r\n\t\tgetScanner().wmiClose();\r\n\t}\r\n} catch (e) {\r\n\tgetScanner().addError(e.message);\r\n}\r\n\r\nWScript.Echo(getScanner().getXMLPayload().xml)\r\n\r\n\r\n// ********************* Function definitions **********************************\r\n//\r\n// The arguements could potentially look like the following\r\n// \"-debug 10.10.10.10 WMI_FetchData.js\"\r\n// \r\n// Returns the js file(s) that need to be processed.  \r\n//\r\nfunction getOpts() {\r\n\tvar items = new Array();\r\n\tvar pastOpts = false;\r\n\tvar machineNext = false;\r\n\t\r\n\tfor(var i = 0; i < WScript.Arguments.length; i++) {\r\n\t\tvar arg = WScript.Arguments.Item(i);\r\n\t\t\r\n\t\tif (!pastOpts && arg.substring(0, 1) != '-') {\r\n\t\t\tpastOpts = true;\r\n\t\t\tmachineNext = true;\r\n\t\t}\r\n\t\t\r\n\t\t// if we are still processing opts, lets pass them\r\n\t\t// along to our processOpt function\r\n\t\tif (!pastOpts) {\r\n\t\t\tprocessOpt(arg);\r\n\t\t} else {\r\n\t\t\t// we are done with opts, if we don't have a machine\r\n\t\t\t// set, then we'll assume its the first argument. And\r\n\t\t\t// the rest are files to include\r\n\t\t\tif (machineNext) {\r\n\t\t\t\tgCurrentMachine = arg;\r\n\t\t\t\tmachineNext = false;\r\n\t\t\t} else {\r\n\t\t\t\titems.push(arg);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn items;\r\n}\r\n\r\n// This evaluates the JS file that's passed in. A typical example of the script would be\r\n//    scanner = getScanner();\r\n//    if (scanner) {\r\n//        scanner.addFetch('Win32_Process.Caption');\r\n//        scanner.fetch();\r\n//    }\r\n    \r\nfunction includeJS(file) {\r\n\tgCurrentFile = file;\r\n\tvar data = getContents(file);\r\n\t\r\n\ttry {\r\n\t\teval(data);\r\n\t} catch(e) {\r\n\t\tif (file != WMISCANNER)\r\n\t\t\tgetScanner().addError(\"Error evaling \" + file + \": \" + e.description);\r\n\t}\r\n}\r\n\r\nfunction getContents(file) {\r\n\tvar data = \"\";\r\n\r\n\ttry {\r\n\t\tvar forReading = 1;\r\n\t\tvar objFSO = new ActiveXObject(\"Scripting.FileSystemObject\");\r\n\t\tvar f = objFSO.GetFile(file);\r\n\t\tvar objTempFile = f.OpenAsTextStream(forReading, 0);\r\n\r\n\t\twhile( !objTempFile.AtEndOfStream )\r\n\t\t\tdata += objTempFile.ReadLine() + \"\\n\";\r\n\t\t\t\r\n\t} catch(e) {\r\n\t\tgetScanner().addError(gCurrentFile + \": Unable to get contents\");\r\n\t}\r\n\r\n\treturn data;\r\n}\r\n\r\n//\r\n// return the scanner object -- create if one doesn't exist\r\n//\r\nfunction getScanner() {\r\n\tif (!gScanner)\r\n\t\tgScanner = new WMIScanner(gCurrentMachine);\r\n\r\n\tgScanner.setDebugging(gDebug);\r\n\t\r\n\treturn gScanner;\r\n}\r\n\r\nfunction processOpt(opt) {\r\n\tif (opt == \"-debug\")\r\n\t\tgDebug = true;\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_b6fdf97bef65010098d5925495c0fb57","name":"WMIRunner.js","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/72c33456372331000e4d03488e41f101","value":"72c33456372331000e4d03488e41f101"},"description":"Manages credential testing to see if there is proper access to a target system","source":"","sys_updated_on":"2025-05-01 19:49:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"e0343456372331000e4d03488e41f149","sys_updated_by":"now.midserver","sys_created_on":"2015-04-23 00:32:13","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"Credentials.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"52","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"<######################\r\n #\tIf protected with DPAPI so that it can be passed securely from java process to PowerShell process, unprotect it\r\n #  and optionally convert it to a secure string, so that it can be used to create the credential object. \r\n ######################>\r\nfunction unprotect {\r\n\tparam([string]$protectedText, [Switch]$AsSecureString)\r\n\r\n\t# when protected, the text has the format of \"ENC_VAL[base64_encoding]\"\r\n\t# use regex to detect the pattern and pluck out the base64_ecoding part\r\n\tAdd-Type -AssemblyName System.Security\r\n\tif (-Not ($protectedText -match \"^ENC_VAL\\[((?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?)\\]$\")) {\r\n\t\t$unprotectedText = $protectedText\r\n\t} else {\r\n\t\t$base64String = $Matches[1]\r\n\t\t$protectedBytes = [Convert]::FromBase64String($base64String)\r\n\t\t$unprotectedBytes = [Security.Cryptography.ProtectedData]::Unprotect($protectedBytes, $null, 'CurrentUser')\r\n\t\t$unprotectedText = [Text.Encoding]::UTF8.GetString($unprotectedBytes)\r\n\t\t$unprotectedBytes.Clear()\r\n\t}\r\n\r\n\tif ($AsSecureString) {\r\n\t\t$secureString = New-Object 'Security.SecureString'\r\n\t\t$chars = $unprotectedText.ToCharArray();\r\n\t\tfor($idx = 0; $idx -lt $chars.Count ; $idx++ ) {\r\n\t\t\t$secureString.AppendChar($chars[$idx])\r\n\t\t\t$chars[$idx] = 0\r\n\t\t}\r\n\t\t$secureString.MakeReadOnly()\r\n\t\t$unprotectedText = $null\r\n\t\treturn $secureString\r\n\t}\r\n\treturn $unprotectedText;\r\n}\r\n\r\n<######################\r\n #\tTurn password into a SecureString, with the convenience of handling null password or password protected with DPAPI.\r\n ######################>\r\nfunction securePassword {\r\n\tparam([string]$password)\r\n\r\n\tif ($password) {\r\n\t\t$passwordSecure = unprotect $password -AsSecureString\r\n\t} else {\r\n\t\t# If no password was supplied, use an empty instance of SecureString\r\n\t\t$passwordSecure = new-object System.Security.SecureString;\r\n\t\tSNCLog-DebugInfo \"`tNo password was supplied\"\r\n\t}\r\n\r\n\treturn $passwordSecure;\r\n}\r\n\r\n<######################\r\n #\tTurn user/secure password into a credential object for use in cmdlets that take a credential\r\n ######################>\r\nfunction getSecureCredential {\r\n\tparam([string]$user, [System.Security.SecureString]$passwordSecure)\r\n\t\r\n\treturn new-object -typename System.Management.Automation.PSCredential -argumentlist \"$user\",$passwordSecure;\r\n}\r\n\r\n<######################\r\n #\tTurn user/password into a credential object for use in cmdlets that take a credential\r\n ######################>\r\nfunction getCred {\r\n\tparam([string]$user, [string]$password)\r\n\r\n\t$user = unprotect $user\r\n    $passwordSecure = securePassword $password\r\n    return getSecureCredential $user $passwordSecure\r\n}\r\n\r\n<######################\r\n #  Turn user/password into a credential object for use in cmdlets that take a credential\r\n ######################>\r\nfunction getCredential {    \r\n    $cred = getCred $env:SNC_username $env:SNC_password\r\n    return $cred;\r\n}\r\n\r\nfunction getDummyCredential {\r\n    param([string]$username, [string]$password)\r\n\r\n    $passwordSecure = unprotect $password -AsSecureString\r\n    $cred = new-object -typename System.Management.Automation.PSCredential -argumentlist \"$username\",$passwordSecure;\r\n\r\n    return $cred;\r\n}\r\n\r\n<######################\r\n #  Test the given user and password on the given computer using the test-wsman cmdlet.\r\n ######################>\r\nfunction testCredentialWinRM {\r\n    $cred = getCredential\r\n    try {\r\n        $results = testRemoteHostRunningWinRM -credential $cred\r\n    } catch [InvalidOperationException] {\r\n        handleExit 1\r\n    }\r\n\r\n    return $cred;\r\n}\r\n\r\nfunction testNoCredentialWinRM {\r\n    try {\r\n        $results = testRemoteHostRunningWinRM\r\n    } catch [InvalidOperationException] {\r\n        handleExit 1\r\n    }\r\n}\r\n\r\n<######################\r\n #  Test the given user and password on the given computer using a get-WMIobject \r\n #  call to fetch the operating system information.  It uses EA (ErrorAction) Stop to force\r\n #  the exception handling to handle the error.  This is particularly useful for the error\r\n #  0x800706BA - The RPC server is unavailable which normally does not get caught in the\r\n #  exception handling.  If the user and password authenticate successfully against the system,\r\n #  return a credential object for that user/password\r\n ######################>\r\nfunction testCredentialWMI {\r\n    param([boolean]$debug)\r\n    \r\n    $cred = getCredential\r\n    SNCLog-DebugInfo \"Running testCredentialWMI: gwmi win32_operatingsystem -computer $computer -credential $($cred.UserName) -impersonation 3 -authentication 6 -EA Stop\"\r\n\r\n    try {\r\n        # just eat the results - mostly concerned with capturing errors\r\n        $null = gwmi win32_operatingsystem -computer $computer -credential $cred -impersonation 3 -authentication 6 -EA Stop;\r\n        return $cred;\r\n    } catch {\r\n        throw $_\r\n    }\r\n}\r\n\r\nfunction testNoCredentialWMI {\r\n    param([boolean]$debug)\r\n\r\n    SNCLog-DebugInfo \"Running testNoCredentialWMI without explicit credential: gwmi win32_operatingsystem -computer $computer -impersonation 3 -authentication 6 -EA Stop\"\r\n\r\n    # just eat the results - mostly concerned with capturing errors\r\n    $null = gwmi win32_operatingsystem -computer $computer -impersonation 3 -authentication 6 -EA Stop;\r\n}\r\n\r\n<######################\r\n #  Test the ability to reach a given computer without credentials using a get-WMIobject \r\n #  call to fetch the operating system information.  It uses EA (ErrorAction) Stop to force\r\n #  the exception handling to handle the error.  This is particularly useful for the error\r\n #  0x800706BA - The RPC server is unavailable which normally does not get caught in the\r\n #  exception handling.  Bail out of the script if the computer can't be reached.\r\n ######################>\r\nfunction testNoCredentialAccessWMI {\r\n    param([boolean]$debug)\r\n    \r\n    try {\r\n        #Just eat the results - mostly concerned with capturing errors\r\n        $results = gwmi win32_operatingsystem -computer $computer -impersonation 3 -authentication 6 -EA \"Stop\";\r\n    } catch [System.Exception] {\r\n        [Console]::Error.WriteLine(\"Failed to access target system.  Please check credentials and firewall settings on the target system to ensure accessibility: \" + $_.Exception.Message)\r\n\r\n        if ($debug) {\r\n            [Console]::Error.WriteLine(\"`r`n Stack Trace: \" + $_.Exception.StackTrace)\r\n        }\r\n        handleExit 3;\r\n    }\r\n}\r\n\r\n<######################\r\n #  Start an impersonation context where script code executed between this call and the EndImpersonate call is executed\r\n #  in the security context of the given credential\r\n #\r\n #  Return: a context that should be passed to EndImpersonation when the security context of the given credential\r\n #  is not needed anymore\r\n ######################>\r\nfunction startImpersonation {\r\n    $context = $null\r\n    \r\n    if ($cred) {\r\n        $signature = \"[DllImport(\"\"advapi32.dll\"\", SetLastError = true)] `\r\n                public static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, `\r\n                int dwLogonType, int dwLogonProvider, ref IntPtr phToken);\";\r\n\r\n        $LogOnUser = Add-Type -memberDefinition $signature -name \"Win32LogOnUser\" -passThru;\r\n\r\n        [IntPtr]$userToken = [Security.Principal.WindowsIdentity]::GetCurrent().Token;\r\n\r\n        # The 9 means LOGON32_LOGON_NEW_CREDENTIALS: See definition at http://msdn.microsoft.com/en-us/library/aa378184%28VS.85%29.aspx\r\n        if ($LogOnUser::LogOnUser($cred.GetNetworkCredential().UserName, $cred.GetNetworkCredential().Domain, \r\n                    $cred.GetNetworkCredential().Password, 9, 0, [ref]$userToken)) {\r\n            $Identity = new-object security.Principal.WindowsIdentity $userToken\r\n            $context = $Identity.Impersonate();\r\n        }\r\n    }\r\n\r\n    return $context;\r\n}\r\n\r\n\r\n<######################\r\n #  End a given impersontation context that was started with StartImpersonation\r\n ######################>\r\nfunction endImpersonation {\r\n    param([System.Security.Principal.WindowsImpersonationContext]$context)\r\n\r\n    if ($context) {\r\n        $context.Undo();\r\n        $context.Dispose();\r\n    }\r\n}\r\n\r\nfunction CreateNewCimSession {\r\n    param([string]$Host, [System.Management.Automation.PSCredential]$Credential, [uint32]$OperationTimeoutSec)\r\n\r\n    # if host is not explicitly specified, use the global variable $computer\r\n    if (-not ($Host)) {\r\n        $Host = $computer;\r\n    }\r\n\r\n    # if credential is not explicitly specified, use the global variable $cred\r\n    if (-not ($Credential)) {\r\n        $Credential = $cred;\r\n    }\r\n\r\n    $so = New-CimSessionOption -Protocol Dcom\r\n\r\n    # care must be taken in using single quote here: $so, $Credential, and $OperationTimeoutSec are objects\r\n    # they will be expanded when the script block is created\r\n    $cmd = 'New-CimSession -ComputerName $Host -SessionOption $so'\r\n    if ($Credential) {\r\n        $cmd += ' -Credential $Credential'\r\n    }\r\n\r\n    if ($OperationTimeoutSec) {\r\n        $cmd += ' -OperationTimeoutSec $OperationTimeoutSec'\r\n    }\r\n\r\n    SNCLog-DebugInfo (\"Running create CIM session script: \" + $ExecutionContext.InvokeCommand.ExpandString($cmd))\r\n    $sb = [Scriptblock]::Create($cmd)\r\n    & $sb\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_e0343456372331000e4d03488e41f149","name":"Credentials.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Collection of functions used to fetch data from a target system through WMI","source":"","sys_updated_on":"2024-09-18 17:55:00","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"e1634355376001006b882d465abe5dd5","sys_updated_by":"now.midserver","sys_created_on":"2013-04-04 16:43:16","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"WMIFetch.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"jimmy.yuan","sys_mod_count":"179","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"$fetchListType = [system.collections.generic.dictionary[string, system.collections.generic.dictionary[string, system.collections.generic.list[string]]]]; \r\n$fetchedWMIEntriesType = [system.collections.generic.dictionary[string, system.collections.generic.dictionary[string, system.collections.generic.list[system.collections.generic.dictionary[string, object]]]]];\r\n$fetchedRegistryEntriesType = [system.collections.generic.dictionary[string, system.collections.generic.dictionary[string, system.collections.generic.dictionary[string, string]]]];\r\n\r\n$registryHives = @{\"HKEY_CLASSES_ROOT\" = [uint32]\"0x80000000\"; \"HKEY_CURRENT_USER\" = [uint32]\"0x80000001\"; \"HKEY_LOCAL_MACHINE\" = [uint32]\"0x80000002\"; \"HKEY_USERS\" = [uint32]\"0x80000003\"; \"HKEY_CURRENT_CONFIG\" = [uint32]\"0x80000005\"; \"HKEY_DYN_DATA\" = [uint32]\"0x80000006\"}\r\n$SNC_SEPERATOR = \"---SNC-SEPERATOR---\";\r\n$SNC_SEPERATOR_REGISTRY = $script:SNC_SEPERATOR + \"REGISTRY-SECTION---\";\r\n$EXTEND_TAG = \"_EXTENDED_\";\r\n$EXTENDED_TAG_END = $EXTEND_TAG + \"END!\";\r\n$EXTENDED_TAG_START = $EXTEND_TAG + \"START:\";\r\n\r\nfunction filterHotfix {\r\n    param([string]$value)\r\n    if ($value){\r\n        $script:shouldFilterHotfix = $value;\r\n    }\r\n    else{\r\n        $script:shouldFilterHotfix = \"false\";\r\n    }\r\n}\r\n\r\n#####\r\n# Initializes script scope variables in this module to their default values\r\n#####\r\nfunction initializeWmiFetchModule {\r\n\t$script:wmiEntriesToFetch = $null\r\n\t$script:fetchedWMIEntries = $null\r\n\t$script:registryEntriesToFetch = $null\r\n\t$script:fetchedRegistryEntries = $null\r\n\t$script:shouldFilterHotfix = \"false\";\r\n\t[System.Xml.XmlDocument]$script:xmlDocument = $null;\r\n    [System.Xml.XmlElement]$script:xmlResult = $null;\r\n}\r\n\r\n# invoke the initialization function immediately\r\ninitializeWmiFetchModule\r\n\r\n#####\r\n# Add the given path to the fetch entries.  The paths may take one of two forms, either:\r\n#     HKEY_&lt;registry key path&gt;\r\n# or\r\n#     [&lt;namespace&gt;\\]&lt;class&gt;.property\r\n# The first form fetches a registry key value; the second a WMI class property.\r\n#####\r\nfunction addFetch {\r\n    param([string]$entry)\r\n\r\n    if ($script:shouldFilterHotfix -eq \"true\"){\r\n        $packagesIndex = $entry.indexOf(\"/Component Based Servicing/Packages/Package\");\r\n        if ($packagesIndex -ne -1){\r\n            return;\r\n        }\r\n    }\r\n       \r\n    $parser = [regex]\"(?i)^(HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS)[\\\\\\/].*$\";\r\n    $parts = $parser.match($entry);\r\n    if ($parts.Success) {\r\n        addRegistryFetch($entry);\r\n    } else {\r\n        addWMIFetch($entry);\r\n    }\r\n}\r\n\r\n#####\r\n# Adds WMI fetch entries with a path of the following form: \r\n#     [&lt;namespace&gt;\\]&lt;class&gt;.property\r\n# If the optional namespace is missing, the default (root\\cimv2) is used.  All namespaces MUST begin with \"root\\\".\r\n# \r\n# path: the path to be fetched, in the form specified above.\r\n#####\r\nfunction addWMIFetch {\r\n    param([string]$entry)\r\n\r\n    if (!$script:wmiEntriesToFetch) {\r\n        # Dictionary for namespace and collection of tables which is dictionary for table name and list of fields\r\n        $script:wmiEntriesToFetch = new-object $fetchListType;\r\n    }\r\n       \r\n    $namespace = \"root\\cimv2\";\r\n    $tableName = \"\";\r\n    $fieldName = \"\";\r\n    $parser = [regex]\"^(?:(root\\\\(?:.*))\\\\)?([^\\\\]*)[\\.\\\\\\/](.*)$\";\r\n    $parts = $parser.match($entry);\r\n\r\n    if (!$parts.Success) {\r\n        return;\r\n    }\r\n       \r\n    if ($parts.Groups[1].Value.Length -gt 0) {\r\n        $namespace = $parts.Groups[1].Value;\r\n    }\r\n   \r\n    $tableName = [string]$parts.Groups[2].Value;\r\n    $tableName = $tableName.Trim();\r\n    $fieldName = [string]$parts.Groups[3].Value;\r\n    $fieldName = $fieldName.Trim();\r\n       \r\n    if (!$script:wmiEntriesToFetch.ContainsKey($namespace)) {\r\n        [system.collections.generic.dictionary[string, system.collections.generic.list[string]]]$ns = \r\n            new-object \"system.collections.generic.dictionary[string, system.collections.generic.list[string]]\";\r\n        $script:wmiEntriesToFetch.Add($namespace, $ns);\r\n    }\r\n    \r\n    if (!$script:wmiEntriesToFetch[$namespace].ContainsKey($tableName)) {\r\n        [system.collections.generic.list[string]]$fields = new-object \"system.collections.generic.list[string]\";\r\n        $script:wmiEntriesToFetch[$namespace].Add($tableName, $fields);\r\n    } \r\n\r\n    $script:wmiEntriesToFetch[$namespace][$tableName].Add($fieldName);    \r\n}\r\n\r\nfunction fetch {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred)\r\n\r\n    $script:xmlDocument = createXmlDocument;\r\n    $script:xmlResult = createElement -xmlDocument $script:xmlDocument -name \"wmi\"\r\n    appendChild -parent $script:xmlDocument -child $script:xmlResult\r\n    fetchWMI -computer $computer -cred $cred\r\n    fetchRegistry -computer $computer -cred $cred\r\n    outputFetchedItems\r\n}\r\n\r\nfunction initRegistryVariables {\r\n\r\n    $script:registryEntriesToFetch = $null\r\n    $script:fetchedRegistryEntries = $null\r\n    $registryEntriesToFetch = $null\r\n    $fetchedRegistryEntries = $null\r\n    [System.Xml.XmlDocument]$xmlDocument = $null\r\n    [System.Xml.XmlElement]$xmlResult = $null\r\n}\r\n\r\nfunction fetchWMI {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred)\r\n\r\n    if (!$script:wmiEntriesToFetch) {\r\n        return;\r\n    }\r\n        \r\n    if (!$script:fetchedWMIEntries) {\r\n        $script:fetchedWMIEntries = new-object $fetchedWMIEntriesType;\r\n    }\r\n    \r\n    foreach ($namespace in $script:wmiEntriesToFetch.Keys) {\r\n        [system.collections.generic.dictionary[string, system.collections.generic.list[system.collections.generic.dictionary[string, object]]]]$ns = \r\n            new-object \"system.collections.generic.dictionary[string, system.collections.generic.list[system.collections.generic.dictionary[string, object]]]\";\r\n        $script:fetchedWMIEntries.Add($namespace, $ns);\r\n    \r\n        foreach ($table in $script:wmiEntriesToFetch[$namespace].Keys) {\r\n            [system.collections.generic.list[system.collections.generic.dictionary[string, object]]]$fetchedTableList = \r\n                new-object \"system.collections.generic.list[system.collections.generic.dictionary[string, object]]\";\r\n            $script:fetchedWMIEntries[$namespace].Add($table, $fetchedTableList);\r\n\r\n            try {\r\n                if (($global:isMid -eq $False) -and $cred) {\r\n                    SNCLog-DebugInfo \"WMIFetch.psm1 fetchWMI with credential computer: $computer namespace: $namespace table: $table isMid: $global:isMid\";\n                    $wmiClass = gwmi -namespace $namespace -class $table -computer $computer -credential $cred -impersonation impersonate -authentication packetprivacy  -EA \"Stop\"\r\n                } else {\r\n                    SNCLog-DebugInfo \"WMIFetch.psm1 fetchWMI with no credential computer: $computer table: $table namespace: $namespace isMid: $global:isMid\";\n                    $wmiClass = gwmi -namespace $namespace -class $table -computer $computer -impersonation impersonate -authentication packetprivacy -EA \"Stop\"                    \r\n                }\r\n                \r\n                if (!$wmiClass) {\r\n                    continue;\r\n                }\r\n            \r\n                if ($wmiClass -is [array]) {\r\n                    foreach ($obj in $wmiClass) {\r\n                        [system.collections.generic.dictionary[string, object]]$fetchedTable = new-object \"system.collections.generic.dictionary[string, object]\";\r\n                        foreach ($entry in $script:wmiEntriesToFetch[$namespace][$table]) {\r\n                            $value = $obj[$entry];\r\n                            if ($entry.equals(\"CommandLine\") -and $value -and ($value -like '*password*')) {\r\n                                $value = $value -replace 'password\\s*={0,1}\\s*\\S+', '******';\r\n                            }\r\n                            $fetchedTable.Add($entry, $value);\r\n                        }\r\n                        $script:fetchedWMIEntries[$namespace][$table].Add($fetchedTable);                        \r\n                    }\r\n                } else {\r\n                    [system.collections.generic.dictionary[string, object]]$fetchedTable = new-object \"system.collections.generic.dictionary[string, object]\";\r\n                    foreach ($entry in $script:wmiEntriesToFetch[$namespace][$table]) {\r\n                        $fetchedTable.Add($entry, $wmiClass[$entry]);\r\n                    }\r\n                    $script:fetchedWMIEntries[$namespace][$table].Add($fetchedTable);\r\n                }\r\n            } catch [System.UnauthorizedAccessException] {\r\n                continue;\r\n            } catch [System.Exception] {\r\n                # 0x800706D9 is an endpoint mapper exception we'll skip because it is most likely from requesting cluster info from \r\n                # a machine that is not part of a cluster\r\n                if ($_.Exception -is [System.Runtime.InteropServices.COMException] -and $_.Exception.ErrorCode -eq 0x800706D9) {\r\n                    continue;\r\n                }\r\n\r\n                # since we are targeting namespaces and classes that may not always exist, we shouldn't throw a warning\r\n                if ($_.Exception.Message -like \"Invalid Namespace*\" -or $_.Exception.Message -like \"Invalid Class*\") {\r\n                    continue;\r\n                }\r\n\r\n                addWarning($_.Exception.Message);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction outputFetchedItems {\r\n    outputFetchedWMIItems\r\n    outputFetchedRegistryItems\r\n    $outputStr = getXmlString($script:xmlDocument)\r\n    write-host $outputStr\r\n}\r\n\r\nfunction outputFetchedWMIItems {\r\n    if ($script:fetchedWMIEntries) {\r\n        foreach ($namespace in $script:fetchedWMIEntries.Keys) {\r\n            foreach ($table in $script:fetchedWMIEntries[$namespace].Keys) {\r\n                $tableObj = $script:fetchedWMIEntries[$namespace][$table];\r\n                if ($tableObj -and $tableObj.Count -gt 0) {\r\n                    foreach ($listEntry in $script:fetchedWMIEntries[$namespace][$table]) {\r\n                        $tableElement = createElement -xmlDocument $script:xmlDocument -name $table\r\n                        appendChild -parent $script:xmlResult -child $tableElement\r\n                        foreach ($entry in $listEntry.Keys) {\r\n                            $value = $listEntry[$entry]\r\n                            \r\n                            if ($value -ne $null) {\r\n                                # handle SecureBinding and ServerBinding fields from IIsWebServerSettting class\r\n                                if ($value -is [System.Management.ManagementBaseObject]) {\r\n                                    $value = getManagementBaseObjectString -srcObject $value;\r\n                                } elseif ($value -is [System.Management.ManagementBaseObject[]]) {\r\n                                   if ($value.count -eq 0) {\r\n                                      $value = \"\";\r\n                                   } else {\r\n                                      $newValue = \"\";\r\n                                      foreach ($element in $value) {\r\n                                         $string = getManagementBaseObjectString -srcObject $element;\r\n                                         $newValue = $newValue + \",\" + $string;\r\n                                      }\r\n                                      # remove leading comma and save\r\n                                      $value = $newValue.SubString(1);\r\n                                   }\r\n                                } elseif ($value -is [Array]) {\r\n                                    $value = getArrayString -srcArray $value;\r\n                                } else {\r\n                                    $value = $value.ToString();\r\n                                }\r\n                            } else {\r\n                                $value = \"\";\r\n                            }\r\n                            \r\n                            if ($value -ne $null -and ($value -eq [char] 0x0 -or $value -eq \"&#x0;\")) {\r\n                                 $value = \"\";\r\n                            }\r\n                            \r\n                            $valueElement = createElement -xmlDocument $script:xmlDocument -name $entry -value $value\r\n                            appendChild -parent $tableElement -child $valueElement\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction nextXmlNode {\r\n    param([System.Xml.XmlNode]$currentElement, [string]$name)\r\n    \r\n    $previousElement = $currentElement;\r\n    $currentElement = getChildWithNameAndAttribute -xmlNode $currentElement -name \"entry\" -attributeName \"key\" -attributeValue $name\r\n    if (!$currentElement) {\r\n        $newElement = createElementWithAttribute -xmlDocument $script:xmlDocument -name \"entry\" -attributeName \"key\" -attributeValue $name\r\n        appendChild -parent $previousElement -child $newElement\r\n        $currentElement = $newElement;       \r\n    }\r\n    \r\n    return $currentElement;\r\n}\r\n\r\nfunction getManagementBaseObjectString {\r\n    param([System.Management.ManagementBaseObject]$srcObject)\r\n    \r\n    $props = @{};\r\n    foreach ($property in $srcObject.Properties) {\r\n        $value = $srcObject.GetPropertyValue($property.Name);\r\n        if ($value -eq $null) {\r\n            continue;\r\n        }\r\n\r\n        if ($value -is [array]) {\r\n            $value = getArrayString -srcArray $value\r\n        }\r\n\r\n        if ($value.ToString().Length -gt 0) {\r\n            $props.Add($property.Name, $value);\r\n        }\r\n    }\r\n    \r\n    $outputStr = getHashtableString -srcHashtable $props;\r\n    return $outputStr;\r\n}\r\n\r\nfunction getHashtableString {\r\n    param([HashTable]$srcHashtable)\r\n    \r\n    if ($srcHashtable.Count -eq 0) {\r\n        return \"\";\r\n    }\r\n        \r\n    $outputStr = \"\";\r\n    $index = 0;\r\n    foreach($key in $srcHashtable.Keys) {\r\n        if ($index -ne 0) {\r\n            $outputStr += \",\";\r\n        }\r\n        \r\n        $outputStr += $key + \"=\" + $srcHashtable[$key];\r\n        $index++;\r\n    }\r\n    \r\n    return $outputStr;\r\n}\r\n\r\nfunction getArrayString {\r\n    param([array]$srcArray)\r\n\r\n    return [string]::Join(\",\", $srcArray);\r\n}\r\n\r\nfunction addWarning {\r\n    param([string]$warningStr)\r\n    \r\n    $warningElement = createElement -xmlDocument $script:xmlDocument -name 'Warning' -value $warningStr\r\n    appendChild -parent $script:xmlResult -child $warningElement\r\n}\r\n\r\n\r\n#################################\r\n# REGISTRY FUNCTIONS\r\n#################################\r\nfunction clearRegistryFetchArrays{\r\n    $script:registryEntriesToFetch = $null;\r\n    $script:fetchedRegistryEntries = $null;\r\n}\r\nfunction addRegistryFetch {\r\n    param([string]$entry)\r\n\r\n    if (!$script:registryEntriesToFetch) {\r\n        $script:registryEntriesToFetch = new-object 'system.collections.generic.dictionary[string, system.collections.generic.dictionary[string, system.collections.generic.list[string]]]';\r\n    }\r\n    \r\n    $parser = [regex]\"(?i)^(HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS)[\\\\\\/](.*)[\\\\\\/](.*)$\";\r\n    $parts = $parser.match($entry);\r\n\r\n    if (!$parts.Success) {\r\n        return;\r\n    }\r\n\r\n    $hive = getHiveString($parts.Groups[1].Value);\r\n    \r\n    if (!$script:registryEntriesToFetch.ContainsKey($hive)) {\r\n        $registryKeys = new-object 'system.collections.generic.dictionary[string, system.collections.generic.list[string]]';\r\n        $script:registryEntriesToFetch.Add($hive, $registryKeys);\r\n    }\r\n    \r\n    if (!$script:registryEntriesToFetch[$hive].ContainsKey($parts.Groups[2].Value)) {\r\n        $registryValues = new-object 'system.collections.generic.list[string]';\r\n        $script:registryEntriesToFetch[$hive].Add($parts.Groups[2].Value, $registryValues);\r\n    }\r\n\r\n    $script:registryEntriesToFetch[$hive][$parts.Groups[2].Value].Add($parts.Groups[3].Value);\r\n}\r\n\r\nfunction getHiveString() {\r\n    param([string]$hive)\r\n    \r\n    $hiveStr = $null;\r\n    \r\n    if ($parts.Groups[1].Value -eq \"HKCR\" -or $parts.Groups[1].Value -eq \"HKEY_CLASSES_ROOT\") {\r\n        $hiveStr = \"HKEY_CLASSES_ROOT\";\r\n    }\r\n\r\n    if ($parts.Groups[1].Value -eq \"HKCU\" -or $parts.Groups[1].Value -eq \"HKEY_CURRENT_USER\") {\r\n        $hiveStr = \"HKEY_CURRENT_USER\";\r\n    }\r\n    \r\n    if ($parts.Groups[1].Value -eq \"HKLM\" -or $parts.Groups[1].Value -eq \"HKEY_LOCAL_MACHINE\") {\r\n        $hiveStr = \"HKEY_LOCAL_MACHINE\";\r\n    }\r\n    \r\n    if ($parts.Groups[1].Value -eq \"HKU\" -or $parts.Groups[1].Value -eq \"HKEY_USERS\") {\r\n        $hiveStr = \"HKEY_USERS\";\r\n    }\r\n    if ($parts.Groups[1].Value -eq \"HKCC\" -or $parts.Groups[1].Value -eq \"HKEY_CURRENT_CONFIG\") {\r\n        $hiveStr = \"HKEY_CURRENT_CONFIG\";\r\n    }\r\n    \r\n    return $hiveStr;\r\n}\r\n\r\n# Get the StdRegProv object, and use it to fetch requested registry entries.  Call EnumValues to figure out the type of value - the function to call to fetch the value is based on the type.\r\nfunction fetchRegistry {\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [bool]$outputForWMIProvider)\r\n    \r\n    if (!$script:registryEntriesToFetch) {\r\n        return;\r\n    }\r\n        \r\n    if (!$script:fetchedRegistryEntries) {\r\n        $script:fetchedRegistryEntries = new-object $fetchedRegistryEntriesType;\r\n    }\r\n    \r\n    if (-not $SNC_session){\r\n        $SNC_session = CreateNewCimSession;\r\n    }\r\n    \r\n    foreach ($hiveStr in $script:registryEntriesToFetch.Keys) {\r\n        $fetchedKeys = new-object \"system.collections.generic.dictionary[string, system.collections.generic.dictionary[string, string]]\";\r\n        # Adding to a dictionary a key that already exist, causes an error - this avoids this\r\n        try{\r\n            $script:fetchedRegistryEntries.Add($hiveStr, $fetchedKeys);\r\n        } catch {}\r\n \r\n        if ($SNC_session) {\r\n            $reg = Get-CimClass -Namespace \"root\\default\" -ClassName \"StdRegProv\" -CimSession $SNC_session\r\n        } else {\r\n            $reg = Get-CimClass -Namespace \"root\\default\" -ClassName \"StdRegProv\";         \r\n        }\r\n \r\n        $hive = $script:registryHives[$hiveStr];\r\n     \r\n        foreach ($key in $script:registryEntriesToFetch[$hiveStr].Keys) {\r\n            $keysToFetch = new-object 'system.collections.generic.list[string]';\r\n            # Replace forward slashes with backslashes - forward slashes cause the opening of the key to fail\r\n            $r = [regex]\"/\";\r\n            $updatedKey = $r.Replace($key, \"\\\");\r\n            expandRegistryKey -computer $computer -reg $reg -hive $hive -key $updatedkey -expandedKeys $keysToFetch;\r\n       \r\n            foreach ($keyToFetch in $keysToFetch) {\r\n                $fetchedValues = new-object \"system.collections.generic.dictionary[string, string]\";\r\n                # Adding to a dictionary a key that already exist, causes an error - this avoids this\r\n                try{\r\n                    $script:fetchedRegistryEntries[$hiveStr].Add($keyToFetch, $fetchedValues);\r\n                } catch {}\r\n                \r\n                if ($SNC_session){\r\n                    $names = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"EnumValues\" -Arguments @{hDefKey=$hive; sSubKeyName=$keyToFetch; } -ErrorAction Stop;\r\n                } else {\r\n                    $names = $reg | Invoke-CimMethod -MethodName \"EnumValues\" -Arguments @{hDefKey=$hive; sSubKeyName=$keyToFetch; } -ErrorAction Stop;\r\n                }\r\n                if ($names.ReturnValue -ne 0) {\r\n                    continue;\r\n                }\r\n                \r\n\r\n                # normalize value names\r\n                $values = $script:registryEntriesToFetch[$hiveStr][$key] | ForEach-Object {\r\n                    # match returns sName value if $_ equals the sName value, case insensitive\r\n                    $normalizedName = $names.sNames -match \"^$_$\";\r\n                    if ($normalizedName) {\r\n                        $normalizedName;\r\n                    } else {\r\n                        $_;\r\n                    }\r\n                }\r\n                \r\n                $types = new-object \"system.collections.generic.dictionary[string, Int32]\";\r\n                \r\n                for ($i = 0; $i -lt $names.sNames.Length; $i++) {\r\n                    $types.Add($names.sNames[$i], $names.Types[$i]);\r\n                }\r\n\r\n                foreach ($value in $values) {\r\n                    try {\r\n                        if ($value -eq \"''\"){\r\n                            $fetchedValue = getExpandedStringValue -reg $reg -hive $hive -key $keyToFetch -value \"\"\r\n                        } elseif ($types[$value] -eq 1) {\r\n                            $fetchedValue = getStringValue -reg $reg -hive $hive -key $keyToFetch -value $value\r\n                        } elseif ($types[$value] -eq 2) {\r\n                            $fetchedValue = getExpandedStringValue -reg $reg -hive $hive -key $keyToFetch -value $value\r\n                        } elseif ($types[$value] -eq 3) {\r\n                            $fetchedValue = getBinaryValue -reg $reg -hive $hive -key $keyToFetch -value $value\r\n                        } elseif ($types[$value] -eq 4) {\r\n                            $fetchedValue = getDWORDValue -reg $reg -hive $hive -key $keyToFetch -value $value\r\n                        } elseif ($types[$value] -eq 11) {\r\n                            $fetchedValue = getQWORDValue -reg $reg -hive $hive -key $keyToFetch -value $value\r\n                        } else {\r\n                            $fetchedValue = getMultiStringValue -reg $reg -hive $hive -key $keyToFetch -value $value -outputForWMIProvider $outputForWMIProvider\r\n                        }\r\n\r\n                        # successfully fetched value, add (value, data) mapping to fetchedRegistryEntries\r\n                        # Adding to a dictionary a key that already exist, causes an error - this avoids this\r\n                        try{\r\n                            $script:fetchedRegistryEntries[$hiveStr][$keyToFetch].Add($value, $fetchedValue);\r\n                        } catch {}\r\n                    } catch {\r\n                        # could not fetch registry value\r\n\r\n                        # if we are fetching for the WMIProvider, we should filter out non existent values\r\n                        # do not add to fetchedRegistryEntries\r\n                        if ($outputForWMIProvider) {\r\n                            continue;\r\n                        }\r\n\r\n                        # add (value, '') mapping to fetchedRegistryEntries\r\n                        $fetchedValue = '';\r\n                        # Adding to a dictionary a key that already exist, causes an error - this avoids this\r\n                        try{\r\n                            $script:fetchedRegistryEntries[$hiveStr][$keyToFetch].Add($value, $fetchedValue);\r\n                        } catch {}\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction expandRegistryKey {\r\n    param([string]$computer, $reg, [uint32]$hive, [string]$key, [system.collections.generic.list[string]]$expandedKeys)\r\n  \r\n    $starIndex = $key.indexOf(\"*\");\r\n    # If not contains a * then return\r\n    if ($starIndex -eq -1) {\r\n        $expandedKeys.Add($key);\r\n        return;\r\n    }\r\n    \r\n    \r\n    # Replace * with .* and make into a regex.\r\n    # Input: Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\r\n    # Output: Software\\\\Wow6432Node\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\\\\.*\r\n    $regexForKey = $key -replace \"(?<!\\.)\\*\", \".*\";\r\n    $regexForKey = $regexForKey.replace(\"\\\", \"\\\\\");\r\n    \r\n    # Split the registry path to before the slash of the start and after - so we can rebuild it later\r\n    $keyUpToStar = $key.Substring(0,$starIndex);\r\n    $leftSlashIndex = $keyUpToStar.lastIndexOf(\"\\\");\r\n    $subkey = \"\";\r\n    if ($leftSlashIndex -ge 0) {\r\n        $subkey = $key.SubString(0, $leftSlashIndex);\r\n    }\r\n\r\n    # $hive will have the hexa code of the, $reg is the registry representation\r\n    if ($SNC_session){\r\n        $openRegKey = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"EnumKey\" -Arguments @{hDefKey=$hive; sSubKeyName=$subkey} -ErrorAction Stop;\r\n    } else {\r\n        $openRegKey = $reg | Invoke-CimMethod -MethodName \"EnumKey\" -Arguments @{hDefKey=$hive; sSubKeyName=$subkey} -ErrorAction Stop;\r\n    }\r\n \r\n    if ($openRegKey.ReturnValue -ne 0 ) {\r\n        return;\r\n    }\r\n\r\n    [regex]$pattern = \"[^\\\\]*\\*[^\\\\]*\"\r\n    foreach ($expandedKey in $openRegKey.sNames) {\r\n        # Replace the first star section with the expanded key\r\n        # input: Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\s*18\\Products\\1*0\\InstallProperties\r\n        # output: Software\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData\\S-1-5-18\\Products\\1*0\\InstallProperties\r\n        $newKey = $pattern.replace($key, ($expandedKey + \"\\\") , 1);\r\n        # In case of an extra \"\\\" due to repalce above\r\n        $newKey = $newKey.replace(\"\\\\\", \"\\\");\r\n        \r\n        # Only if the registry path matches the regex then add it to the list to be queried.\r\n        if ($newKey -match $regexForKey){\r\n            $s = $newKey.indexOf(\"*\");\r\n            if ($s -ne -1) {\r\n                expandRegistryKey -computer $computer -reg $reg -hive $hive -key $newKey -expandedKeys $expandedKeys;\r\n            } else {\r\n                $expandedKeys.Add($newKey);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n# Getter functions for each of the registry value types\r\nfunction getStringValue {\r\n    param($reg, [uint32]$hive, [string]$key, [string]$value)\r\n\r\n    if ($SNC_session){\r\n        $fetchedValue = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"GetStringValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    } else {\r\n        $fetchedValue = $reg | Invoke-CimMethod -MethodName \"GetStringValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    }\r\n    if ($fetchedValue.ReturnValue -ne 0) {\r\n        throw \"failed to get registry $hive\\$key\\$value\";\r\n    }\r\n\r\n    return $fetchedValue.sValue;\r\n}\r\n\r\nfunction getExpandedStringValue {\r\n    param($reg, [uint32]$hive, [string]$key, [string]$value)\r\n    \r\n    if ($SNC_session){\r\n        $fetchedValue = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"GetExpandedStringValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    } else {\r\n        $fetchedValue = $reg | Invoke-CimMethod -MethodName \"GetExpandedStringValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    }\r\n    if ($fetchedValue.ReturnValue -ne 0) {\r\n        throw \"failed to get registry $hive\\$key\\$value\";\r\n    }\r\n    return $fetchedValue.sValue;\r\n}\r\n\r\nfunction getMultiStringValue {\r\n    param($reg, [uint32]$hive, [string]$key, [string]$value, [bool]$outputForWMIProvider)\r\n    \r\n    if ($SNC_session){\r\n        $fetchedValue = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"GetMultiStringValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    } else {\r\n        $fetchedValue = $reg | Invoke-CimMethod -MethodName \"GetMultiStringValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    }\r\n    if ($fetchedValue.ReturnValue -ne 0) {\r\n        throw \"failed to get registry $hive\\$key\\$value\";\r\n    }\r\n    $strs = $fetchedValue.sValue;\r\n\r\n    # use new lines for WMIProvider, commas for probes\r\n    $separator = if ($outputForWMIProvider) { \"`n\" } else { ',' };\r\n    return [string]::Join($separator, $strs);\r\n}\r\n\r\nfunction getBinaryValue {\r\n    param($reg, [uint32]$hive, [string]$key, [string]$value)\r\n    \r\n    if ($SNC_session){\r\n        $fetchedValue = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"GetBinaryValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    } else {\r\n        $fetchedValue = $reg | Invoke-CimMethod -MethodName \"GetBinaryValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    }\r\n    if ($fetchedValue.ReturnValue -ne 0) {\r\n        throw \"failed to get registry $hive\\$key\\$value\";\r\n    }\r\n    \r\n    $bytes = $fetchedValue.uValue | ForEach-Object { [String]::Format(\"{0:x2}\", $_) };\r\n    return [string]::Join(\"\", $bytes);\r\n}\r\n\r\nfunction getDWORDValue {\r\n    param($reg, [uint32]$hive, [string]$key, [string]$value)\r\n    \r\n    if ($SNC_session){\r\n        $fetchedValue = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"GetDWORDValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    } else {\r\n        $fetchedValue = $reg | Invoke-CimMethod -MethodName \"GetDWORDValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    }\r\n    if ($fetchedValue.ReturnValue -ne 0) {\r\n        throw \"failed to get registry $hive\\$key\\$value\";\r\n    }\r\n    return $fetchedValue.uValue;\r\n}\r\n\r\nfunction getQWORDValue {\r\n    param($reg, [uint32]$hive, [string]$key, [string]$value)\r\n    \r\n    if ($SNC_session){\r\n        $fetchedValue = $reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"GetQWORDValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    } else {\r\n        $fetchedValue = $reg | Invoke-CimMethod -MethodName \"GetQWORDValue\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; sValueName=$value} -ErrorAction Stop;\r\n    }\r\n    if ($fetchedValue.ReturnValue -ne 0) {\r\n        throw \"failed to get registry $hive\\$key\\$value\";\r\n    }\r\n    return $fetchedValue.uValue;\r\n}\r\n\r\nfunction outputFetchedRegistryItems {\r\n    param([switch]$shouldWriteHost, [bool]$shouldOutputEmptyItems)\r\n    \r\n    $didWriteHost = $false;\r\n    \r\n    if ($script:fetchedRegistryEntries) {\r\n        foreach ($hive in $script:fetchedRegistryEntries.Keys) {\r\n            foreach ($key in $script:fetchedRegistryEntries[$hive].Keys) {\r\n                $createdKey = $false;\r\n                \r\n                foreach ($property in $script:fetchedRegistryEntries[$hive][$key].Keys) {\r\n                    $value = $script:fetchedRegistryEntries[$hive][$key][$property]\r\n                    if ($shouldOutputEmptyItems -or ![string]::IsNullOrEmpty($value)) {\r\n                        if (!$createdKey -and -not $shouldWriteHost) {\r\n                            $current = outputRegistryKey -hive $hive -key $key\r\n                            $createdKey = $true;\r\n                        }\r\n                        if ($shouldWriteHost){\r\n                            $didWriteHost = $true;\r\n                            if ($property -eq \"''\"){\r\n                                    $property = \"\";\r\n                            }\r\n                            write-output \"$property : $value\";\r\n                        } else{\r\n                            outputRegistryValue -node $current -name $property -value $value\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction outputRegistryKey {\r\n    param([string]$hive, [string]$key)\r\n\r\n    $xmlRegistry = getChild -xmlNode $script:xmlResult -name \"Registry\"\r\n    if (!$xmlRegistry) {\r\n        $xmlRegistry = createElement -xmlDocument $script:xmlDocument -name \"Registry\"\r\n        appendChild -parent $script:xmlResult -child $xmlRegistry\r\n    }\r\n\r\n    $hiveElement = getChildWithNameAndAttribute -xmlNode $xmlRegistry -name \"entry\" -attributeName \"key\" -attributeValue $hive\r\n    if (!$hiveElement) {\r\n        $hiveElement = createElementWithAttribute -xmlDocument $xmlDocument -name \"entry\" -attributeName \"key\" -attributeValue $hive\r\n        appendChild -parent $xmlRegistry -child $hiveElement\r\n    }\r\n    \r\n    $currentElement = $hiveElement;\r\n    $lastIndex = 0;\r\n    $index = $key.IndexOf(\"\\\");\r\n    while ($index -ne -1) {\r\n        $part = $key.SubString($lastIndex, $index - $lastIndex);\r\n        $currentElement = nextXmlNode -currentElement $currentElement -name $part\r\n        \r\n        $lastIndex = $index + 1;\r\n        $index = $key.IndexOf(\"\\\", $index + 1);\r\n    }\r\n    $part = $key.SubString($lastIndex);\r\n    $currentElement = nextXmlNode -currentElement $currentElement -name $part\r\n    \r\n    return $currentElement\r\n}\r\n\r\nfunction outputRegistryValue {\r\n    param([System.Xml.XmlNode]$node, [string]$name, [string]$value)\r\n    if (![string]::IsNullOrEmpty($value)) {\r\n        $keyElement = createElementWithAttribute -xmlDocument $script:xmlDocument -name \"entry\" -attributeName \"key\" -attributeValue $name\r\n        appendChild -parent $node -child $keyElement\r\n\r\n        $valueElement = createElement -xmlDocument $script:xmlDocument -name \"value\" -value $value\r\n        appendChild -parent $keyElement -child $valueElement\r\n    }\r\n}\r\n\r\nfunction addRegistryValuesToFetch{\r\n    param([string] $entry, [string[]]$specificKeys, [switch]$shouldThrow, [string]$computer, [System.Management.Automation.PSCredential]$cred)\r\n\r\n    if ($specificKeys){\r\n        foreach ($subKey in $specificKeys) {\r\n            addfetch($entry + \"\\\" + $subKey);\r\n        }\r\n        \r\n        return;\r\n    }\r\n    \r\n    if (-not $SNC_session){\r\n        $SNC_session = CreateNewCimSession -Host $computer -Credential $cred;\r\n    }\r\n    \r\n    if ($SNC_session) {\r\n        $reg = Get-CimClass -Namespace \"root\\default\" -ClassName \"StdRegProv\" -CimSession $SNC_session\r\n    } else {\r\n        $reg = Get-CimClass -Namespace \"root\\default\" -ClassName \"StdRegProv\";         \r\n    }\r\n\r\n    $parser = [regex]\"^(HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKEY_CURRENT_CONFIG)[\\\\\\/](.*)?\";\r\n    $parts = $parser.match($entry);\r\n\r\n    if (!$parts.Success) {\r\n        if ($shouldThrow){\r\n            throw \"Could not locate any hive (for example: HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKEY_CURRENT_CONFIG) in $entry\";\r\n        }\r\n        return;\r\n    }\r\n    \r\n    [string]$hiveStr = $parts.Groups[1].Value.toString();\r\n    [uint32]$hive = $registryHives[$hiveStr];\r\n    [string]$key = $parts.Groups[2].toString();\r\n    \r\n    if ($SNC_session){\r\n        $output = ($reg | Invoke-CimMethod -CimSession $SNC_session -MethodName \"EnumValues\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; } -ErrorAction Stop).sNames;\r\n    } else {\r\n        $output = ($reg | Invoke-CimMethod -MethodName \"EnumValues\" -Arguments @{hDefKey=$hive; sSubKeyName=$key; } -ErrorAction Stop).sNames;\r\n    }\r\n\r\n    foreach ($subKey in $output) {\r\n        $anyAdds = $true;\r\n        addfetch($entry + \"\\\" + $subKey);\r\n    }\r\n}\r\n\r\nfunction fetchAndOutputRegistries{\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [bool]$outputForWMIProvider)\r\n    \r\n    fetchRegistry -computer $computer -cred $cred -outputForWMIProvider $outputForWMIProvider;\r\n\r\n    # if we are fetching and outputting registries values for the WMIProvider, we need to output values with empty data\r\n    if ($outputForWMIProvider) {\r\n        outputFetchedRegistryItems -shouldWriteHost -shouldOutputEmptyItems $outputForWMIProvider;\r\n    } else {\r\n        outputFetchedRegistryItems -shouldOutputEmptyItems $outputForWMIProvider;\r\n    }\r\n}\r\n\r\nfunction Get-RegistryValues {\r\n    param([string] $entry, [string]$computer, [System.Management.Automation.PSCredential]$cred)\r\n    \r\n    addRegistryValuesToFetch -entry $entry -computer $computer -cred $cred;\r\n    fetch -computer $computer -cred $cred\r\n}\r\n\r\nfunction Get-RegistryKeysRemote {\r\n    param([string] $entry, [System.Management.Automation.Runspaces.PSSession]$ps)\r\n\r\n    $finalOutput = invoke-command -session $ps -scriptblock {$reg = gwmi -list -namespace root\\default | where-object {$_.Name -eq \"StdRegProv\"};\r\n        \r\n        $parser = [regex]\"^(HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKEY_CURRENT_CONFIG)[\\\\\\/](.*)?\";\r\n        $parts = $parser.match($entry);\r\n\r\n        if (!$parts.Success) {\r\n            return;\r\n        }\r\n        $hive = getHiveString($parts.Groups[1].Value);\r\n            \r\n        $key =$parts.Groups[2];\r\n            \r\n        if ($hive  -eq  \"HKEY_CLASSES_ROOT\") {\r\n            $output = $reg.enumKey(\"2147483648\" ,  $key).sNames;\r\n        }\r\n        Elseif ($hive  -eq  \"HKEY_CURRENT_USER\") {\r\n            $output = $reg.enumKey(\"2147483649\" ,  $key).sNames;\r\n        }\r\n        Elseif ($hive  -eq  \"HKEY_LOCAL_MACHINE\") {\r\n            $output = $reg.enumKey(\"2147483650\" ,  \"$key\").sNames;\r\n        }\r\n        Elseif ($hive  -eq  \"HKEY_USERS\") {\r\n            $output = $reg.enumKey(\"2147483651\" ,  $key).sNames;\r\n        }\r\n        Elseif ($hive  -eq  \"HKEY_CURRENT_CONFIG\") {\r\n            $output = $reg.enumKey(\"2147483653\" ,  $key).sNames;\r\n        }\r\n\r\n        $finalOutput = \"\";\r\n        foreach ($subKey in $output) {\r\n            $finalOutput = $finalOutput + $subKey + \",\"; \r\n        }\r\n        return $finalOutput\r\n\r\n    }\r\n\r\n    write-host $finalOutput;\r\n}\r\n\r\nfunction Get-RegistryKeys {\r\n   param([string] $entry, [string]$computer, [System.Management.Automation.PSCredential]$cred)\r\n    \r\n    if (($global:isMid -eq $False) -and $cred) {\r\n        SNCLog-DebugInfo \"WMIFetch.psm1 Get-RegistryKeys with credential computer: $computer namespace: $namespace table: $table isMid: $global:isMid\";\n        $reg = gwmi -list -computer $computer -credential $cred -namespace root\\default | where-object {$_.Name -eq \"StdRegProv\"}\r\n    } else {\r\n        SNCLog-DebugInfo \"WMIFetch.psm1 Get-RegistryKeys with no credential computer: $computer table: $table namespace: $namespace isMid: $global:isMid\";\n        $reg = gwmi -list -computer $computer -namespace root\\default | where-object {$_.Name -eq \"StdRegProv\"}        \r\n    }\r\n     \r\n    $parser = [regex]\"^(HKCR|HKCU|HKLM|HKU|HKEY_CLASSES_ROOT|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKEY_CURRENT_CONFIG)[\\\\\\/](.*)?\";\r\n    $parts = $parser.match($entry);\r\n\r\n    if (!$parts.Success) {\r\n        return;\r\n    }\r\n\r\n    $hive = getHiveString($parts.Groups[1].Value);\r\n    \r\n    $key =$parts.Groups[2];\r\n    \r\n    if ($hive  -eq  \"HKEY_CLASSES_ROOT\") {\r\n        $output = $reg.enumKey(\"2147483648\" ,  $key).sNames;\r\n    }\r\n    Elseif ($hive  -eq  \"HKEY_CURRENT_USER\") {\r\n        $output = $reg.enumKey(\"2147483649\" ,  $key).sNames;\r\n    }\r\n    Elseif ($hive  -eq  \"HKEY_LOCAL_MACHINE\") {\r\n        $output = $reg.enumKey(\"2147483650\" ,  \"$key\").sNames;\r\n    }\r\n    Elseif ($hive  -eq  \"HKEY_USERS\") {\r\n        $output = $reg.enumKey(\"2147483651\" ,  $key).sNames;\r\n    }\r\n    Elseif ($hive  -eq  \"HKEY_CURRENT_CONFIG\") {\r\n        $output = $reg.enumKey(\"2147483653\" ,  $key).sNames;\r\n    }\r\n\r\n    $finalOutput = \"\";\r\n    foreach ($subKey in $output) {\r\n        $finalOutput = $finalOutput + $subKey + \",\"; \r\n    }\r\n\r\n    write-host $finalOutput;\r\n }\r\n\r\nfunction Get-MultipleRegistryDataAsScript {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] [string]$RegistryKeys\r\n    )\r\n\r\n    $regHash = @{};\r\n    # Properties to ignore\r\n    $defaultProps = @(\"PSParentPath\",\"PSChildName\",\"PSProvider\", \"PSDrive\",\"PSComputerName\",\"PSShowComputerName\",\"RunspaceId\");\r\n    # Translation between Get-ItemProperty restuls types and expected types in sensor\r\n    $regTypes = @{\r\n        \"System.String\"                 = \"REG_SZ\";\r\n        \"System.Int32\"                  = \"REG_DWORD\";\r\n        \"System.Int64\"                  = \"REG_QWORD\";\r\n        \"System.Byte[]\"                 = \"REG_BINARY\";\r\n        \"Deserialized.System.String[]\"  = \"REG_MULTI_SZ\";\r\n    }\r\n    # Shorten PSDrive names as expected in Get-ItemProperty command\r\n   $driveNames = @{\r\n        \"HKEY_LOCAL_MACHINE\"  = \"HKLM:\";\r\n        \"HKEY_CLASSES_ROOT\"   = \"registry::HKEY_CLASSES_ROOT\"\r\n        \"HKEY_CURRENT_USER\"   = \"HKCU:\";\r\n        \"HKEY_USERS\"          = \"registry::HKEY_USERS\";\r\n        \"HKEY_CURRENT_CONFIG\" = \"registry::HKEY_CURRENT_CONFIG\";\r\n    }\r\n    $scriptToRun = \"\";\r\n\r\n    # Split input into an array\r\n    $regKeys = $RegistryKeys.split(\",\");\r\n\r\n    # Loop over all input values and create a hash of Registry bases to values.\r\n    # Input: HKEY_LOCAL_MACHINE/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*/DisplayName and HKEY_LOCAL_MACHINE/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*/InstallDate\r\n    # Output: regHash[\"HKLM:/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*\"] = \"DisplayName,InstallDate,\" (will get rid of the extra comma later)\r\n    foreach($regKey in $regKeys){\r\n        $isDriveValid = \"false\";\r\n        $regKey = $regKey.trim();\r\n        \r\n        if ($script:shouldFilterHotfix -eq \"true\" -and $regKey.indexOf(\"/Package_*_KB*/\") -gt -1){\r\n            continue;\r\n        }\r\n        \r\n        \r\n        $lastSlash =$regKey.lastIndexOf(\"/\");\r\n        \r\n        if ($lastSlash -lt 0){\r\n            continue;\r\n        }\r\n\r\n        $attr = $regKey.substring($lastSlash+1 , $regKey.length-$lastSlash -1);\r\n        $base = $regKey.substring(0, $lastSlash);\r\n        \r\n        $firstSlash = $base.indexOf(\"/\");\r\n        $driveSeg = $base.substring(0, $firstSlash);\r\n        \r\n        # Try and replace long name with short names\r\n        $drive = $driveNames[$driveSeg];\r\n        if ($drive){\r\n            $isDriveValid = \"true\";\r\n            $base = $drive + $base.substring($firstSlash, $base.length-$firstSlash);\r\n        }\r\n        \r\n        foreach($key in $driveNames.Keys) {\r\n            if ($driveSeg -eq $key){\r\n                $isDriveValid = \"true\";\r\n                break;\r\n            }\r\n        }\r\n        \r\n        # Only if we found a drive, add it to the hash\r\n        if ($isDriveValid -eq \"true\" -and $attr){\r\n            $regHash[$base] += $attr + \",\";\r\n        }\r\n    }\r\n    \r\n    # For every registry base, create a Get-ItemProperty command and run it.\r\n    # Input: regHash[\"HKLM:/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*\"] = \"DisplayName,InstallDate,\"\r\n    # Output: Get-ItemProperty -Path 'HKLM:/Software/Wow6432Node/Microsoft/Windows/CurrentVersion/Uninstall/*' -Name DisplayName,InstallDate -EA SilentlyContinue|select DisplayName,InstallDate|format-list;\r\n    foreach($regBase in $regHash.keys){\r\n        # Prepare the command\r\n        if (($regHash[$regBase]).indexOf('*') -gt -1 ){\r\n            # if require all - return all\r\n            $command = \"Get-ItemProperty -Path '$regBase' -EA SilentlyContinue|select PSPath,* -EA SilentlyContinue|format-list;\"\r\n        }\r\n        else{\r\n            # Remove PSPath if it is in the list of attributes as we set PSPath to be the first attribute (this is important for later parsing).\r\n            $query = $regHash[$regBase] -replace \"\\bPSPath,\", \"\";\r\n            if ($query){\r\n                $query = \"PSPath,\" + $query;\r\n                $query = $query.substring(0, $query.length-1);\r\n            }\r\n            # If we only got PSPath in the query\r\n            else{\r\n                $query = \"PSPath\";\r\n            }\r\n            $command = \"Get-ItemProperty -Path '$regBase' -EA SilentlyContinue|select $query|format-list;\"\r\n        }\r\n\r\n        $scriptToRun += $command;\r\n    }\r\n    \r\n    return $scriptToRun;\r\n}\r\n\r\nfunction Get-MultipleWMIDataAsScript {\r\n    param\r\n    (\r\n        [Parameter(Mandatory=$true)] [string]$wmiKeys\r\n    )\r\n\r\n    $wmiHash = @{};\r\n    # Inogre if registry entry\r\n    $entriesToIgnore = @(\"HKEY_LOCAL_MACHINE\",\"HKEY_CLASSES_ROOT\",\"HKEY_CURRENT_USER\", \"HKEY_USERS\",\"HKEY_CURRENT_CONFIG\",\"HKLM\",\"HKCR\", \"HKCU\", \"HKU\", \"HKCC\");\r\n    <# First line of the script is the function definition of printValues.\r\n     This function makes sure it expands ManagementBaseObject and shows extended start and end tags in between so we may replace the ManagementBaseObject string value with extended values.\r\n     Function with new lines:\r\n    function printValues{\r\n        Process{\r\n            # go over each object in the results. An object should be a WMI object\r\n            foreach-object{\r\n                # Select which array to pull from. If  we use PsObject.Properties on a ManagementBaseObject: extra properties will show\r\n                try {\r\n                    $a=$_.Properties\r\n                } catch {\r\n                    $a=$null;\r\n                }\r\n                if (-not $a){\r\n                    $a=$_.PsObject.Properties\r\n                }\r\n                # For each property display the name and the value. If the value is an array print it comman-seperated.\r\n                foreach($p in $a){\r\n                    $o=$p.Name+'' : '';\r\n                    if ($p.Value -is [Array]){\r\n                        $o+=[string]::Join('','', $p.Value);\r\n                    }else{\r\n                        $o+=$p.Value;\r\n                    }\r\n                    # Print\r\n                    $o;\r\n                    # If the value is a ManagementBaseObject or an array of ManagementBaseObjects then recurse over the Value.\r\n                    if($p.Value -is [System.Management.ManagementBaseObject] -or $p.Value -is [System.Management.ManagementBaseObject[]]){\r\n                        '''+$EXTENDED_TAG_START+''';\r\n                        $p.Value|printValues; # Recursion\r\n                        '''+$EXTENDED_TAG_END+''';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    #>\r\n    $scriptToRun = 'function printValues{Process{foreach-object{try{$a=$_.Properties}catch{$a=$null}if(-not $a){$a=$_.PsObject.Properties}foreach($p in $a){$o=$p.Name+'' : '';if ($p.Value -is [Array]){$o+=[string]::Join('','', $p.Value);}else{$o+=$p.Value;}$o;if($p.Value -is [System.Management.ManagementBaseObject] -or $p.Value -is [System.Management.ManagementBaseObject[]]){'''+$EXTENDED_TAG_START+''';$p.Value|printValues;'''+$EXTENDED_TAG_END+''';}}}}}';\r\n\r\n    # Split input into an array\r\n    $wKeys = $wmiKeys.split(\",\");\r\n\r\n    # Loop over all input values and create a hash of Registry bases to values.\r\n    # Input: root\\MSCluster\\MSCluster_ClusterToNode.Antecedent, root\\MSCluster\\MSCluster_ClusterToNode.Dependent\r\n    # Output: wmiHash[\"root\\MSCluster\\MSCluster_ClusterToNode\"] = \"Antecedent,Dependent,\" (will get rid of the extra comma later)\r\n    foreach($wKey in $wKeys){\r\n        $wKey = $wKey.trim();\r\n        $firstSlash = $wKey.indexOf(\"/\");\r\n        \r\n        $driveSeg = \"WMI\";\r\n        if ($firstSlash -gt -1){\r\n            $driveSeg = $wKey.substring(0, $firstSlash);\r\n        }\r\n        \r\n        # In case this is a registry query, skip\r\n        if ($entriesToIgnore -contains $driveSeg){\r\n            continue;\r\n        }\r\n        \r\n        $lastDot = $wKey.lastIndexOf(\".\");\r\n        \r\n        if ($lastDot -gt -1){\r\n            $attr = $wKey.substring($lastDot+1 , $wKey.length-$lastDot -1);\r\n            $base = $wKey.substring(0, $lastDot);\r\n            \r\n            $wmiHash[$base] += $attr + \",\";\r\n        }\r\n    }\r\n    \r\n    # For every registry base, create a Get-ItemProperty command and run it.\r\n    # Input: wmiHash[\"root\\MSCluster\\MSCluster_ClusterToNode\"] = \"Antecedent,Dependent,\"\r\n    # Output: gwmi -namespace \"root\\MSCluster\" MSCluster_ClusterToNode -EA SilentlyContinue | select __Class,Antecedent,Dependent;\r\n    # Output: gwmi Win32_OperatingSystem | select __CLASS, Caption, Version | format-list\r\n    foreach($wBase in $wmiHash.keys){\r\n        # Prepare the command\r\n        $nameSpace = \"root\\cimv2\";\r\n        $query = \"__CLASS,\" + $wmiHash[$wBase];\r\n        $query = $query.substring(0, $query.length-1); # get rid of the last slash.\r\n        \r\n        $lastSlash = $wBase.lastIndexOf(\"/\");\r\n        $table = $wBase;\r\n        \r\n        if ($lastSlash -gt -1){\r\n            $table = $wBase.substring($lastSlash+1 , $wBase.length-$lastSlash -1);\r\n            $namespace = $wBase.substring(0, $lastSlash);\r\n        }\r\n        \r\n        # Uses printValues to print stings and objects\r\n        $command = \"gwmi -namespace $namespace $table -EA SilentlyContinue|select $query|printValues|format-list;\";\r\n        $scriptToRun += $command;\r\n    }\r\n    \r\n    return $scriptToRun;\r\n}\r\n\r\n# This is the command to run form the probes for all WMI queries\r\n# If WMI is the protocol user use fetchMultipleWMI -computer &lt;IP&gt; -cre $cred -wmi \"true\" -WMI_FetchData &lt;comma seperated WMI fetchs&gt;\r\n# Otherwise user fetchMultipleWMI -computer &lt;IP&gt; -cre $cred -wmi \"false\" -WMI_FetchData &lt;comma seperated WMI fetchs&gt;\r\nfunction fetchMultipleWMI{\r\n    param([string]$computer, [System.Management.Automation.PSCredential]$cred, [string]$wmi, [string]$WMI_FetchData, [string]$filterHotfixValue, [string]$output_format, [int]$launchProcessWaitTime = 300)\r\n    \r\n    if ($filterHotfixValue -ne $null -and $filterHotfixValue -ne \"\"){\r\n        filterHotfix($filterHotfixValue);\r\n    }\r\n    \r\n    # Replace any number of back slashes with a single forward slash\r\n    $WMI_FetchData = $WMI_FetchData -replace \"\\\\{1,}\", \"/\";\r\n\r\n    $scriptToRun  = Get-MultipleWMIDataAsScript -wmiKeys $WMI_FetchData;\r\n    $scriptToRun +=  \"'$script:SNC_SEPERATOR_REGISTRY';\";\r\n    $scriptToRun += Get-MultipleRegistryDataAsScript -RegistryKeys $WMI_FetchData;\r\n    \r\n    $runWmi = $true;\r\n    if ($wmi -and $wmi.toLower() -eq \"false\"){\r\n        $runWmi = $false;\r\n    }\r\n\n\n    # Run script on a remote computer using executeRemote with a protocol flag ($runWmi = $true -> protocol is WMI else protocol is WinRM; Default is WMI)\r\n    if ($computer  -or -not $runWmi){\r\n        SNCLog-DebugInfo \"[fetchMultipleWMI] executeRemote -computer `\"$computer`\" -scriptBlock `\"$scriptToRun`\" -wmi $runWmi -cred *** -launchProcessWaitTime $launchProcessWaitTime\"\r\n        $rtn = executeRemote -computer \"$computer\" -scriptBlock \"$scriptToRun\" -wmi $runWmi -cred $cred -launchProcessWaitTime $launchProcessWaitTime | Out-String;\r\n    }\r\n    # Run the script locally on the MID server\r\n    else{\r\n        $rtn = Invoke-Expression \"$scriptToRun\" | Out-String -width $([int32]::MaxValue);\r\n    }\r\n\r\n    #write-host \"RUN: $scriptToRun\";\r\n    #write-host \"We got back: $rtn\";\r\n    \r\n    if ($output_format -eq \"json\" ){\r\n        # In PowerShell 3 there is a ConvertTo-Json cmdlet but we cannot use it just now as we support PowerShell 2.0 as well\r\n        $outputStr = rawResultsToJson -results $rtn;\r\n    }\r\n    elseif ($output_format -eq \"raw\"){\r\n        $outputStr = $rtn;\r\n    }\r\n    # Default is XML\r\n    else{\r\n        $script:xmlDocument = createXmlDocument;\r\n        $script:xmlResult = createElement -xmlDocument $script:xmlDocument -name \"wmi\"\r\n        appendChild -parent $script:xmlDocument -child $script:xmlResult\r\n        wmiDataToXml -results $rtn;\r\n        registryDataToXml -results $rtn;\r\n        \r\n        $outputStr = getXmlString($script:xmlDocument)\r\n    }\r\n    write-output $outputStr\r\n}\r\n\r\n# This method creates XML from the results of the Registry queries\r\nfunction wmiDataToXml {\r\n    param([string] $results)\r\n    \r\n    $class = \"\";\r\n    $prevClass = \"\";\r\n    $att = \"\";\r\n    $val = \"\";\r\n    $extendedVal = 0;\r\n    \r\n    $parts = $results -split $SNC_SEPERATOR_REGISTRY;\r\n    \r\n    if ($parts[0] -eq $null){\r\n        return;\r\n    }\r\n    \r\n    $lines = $parts[0].Split([Environment]::NewLine);\r\n    $lineNumber = -1;\r\n    \r\n    foreach ($line in $lines){\r\n        $lineNumber++;\r\n        # If we got to registry lines - stop\r\n        if ($line -eq $SNC_SEPERATOR_REGISTRY -or $line.startsWith(\"PSPath\")){\r\n            return;\r\n        }\r\n        \r\n        # Start handle extended values of object - read below for description\r\n        <# Example for objects returned, the PriavteProperties is a System.Management.ManagementBaseObject and right after it we start with the extended values of the object indicated by the EXTENDED_START and all the way till EXTENDED_END.\r\n        This is done with the printValues function\r\n            __CLASS           : MSCluster_Resource\r\n            Name              : SQL Server Agent (MSSQLCLUSTER)\r\n            Type              : SQL Server Agent\r\n            PrivateProperties : System.Management.ManagementBaseObject\r\n\r\n            EXTENDED_START:\r\n            __GENUS           : 2\r\n            __CLASS           : MSCluster_Property_Resource_SQL_Server_Agent\r\n            __SUPERCLASS      : MSCluster_Property\r\n            __DYNASTY         : MSCluster_Property\r\n            __RELPATH         : \r\n            __PROPERTY_COUNT  : 2\r\n            __DERIVATION      : {MSCluster_Property}\r\n            __SERVER          : \r\n            __NAMESPACE       : \r\n            __PATH            : \r\n            InstanceName      : MSSQLCLUSTER\r\n            VirtualServerName : VSQL\r\n            PSComputerName    : \r\n\r\n            EXTENDED_END!\r\n        #>\r\n\r\n        if ($line.trim() -eq \"\" -or $line.startsWith(\"__[^C]\") -or $line.startsWith(\"---\") -or $line.startsWith(\" \")){\r\n            continue;\r\n        }\r\n        \r\n        $parts = $line.split(\":\", 2);\r\n                \r\n        # Check if there is a need to read the extension of the object, check the next line - because we would like to replace the \"System.Management.ManagementBaseObject\" string with actual values\r\n        if (areNextValuesExtendedObject -lines $lines -lineNumber $lineNumber){\r\n            # This is the first extended value - reset att and val\r\n            if ($parts[0] -and $extendedVal -eq 0){\r\n                $att = $parts[0].trim();\r\n                $val = \"\";\r\n            }\r\n            $extendedVal++;\r\n            continue;\r\n        }\r\n        \r\n        # Show extended value instead of System.Management.ManagementBaseObject\r\n        if ($extendedVal -gt 0){\r\n            if ($line -eq $EXTENDED_TAG_END){\r\n                $extendedVal--;\r\n                \r\n                # When done with extended values, write the XML tag and reset $val\r\n                if ($extendedVal -eq 0){\r\n                    createXmlTagAndVal -tableElement $tableElement -val $val -att $att -class $class\r\n                    $val = \"\";\r\n                }\r\n            }\r\n            \r\n            if (-not $parts[0] -or $line.startsWith(\"__\")){\r\n                continue;\r\n            }\r\n            if (-not $parts[1] -or $parts[1].trim() -eq \"\"){\r\n                continue;\r\n            }\r\n            $val += $parts[0].trim() + \"=\" + $parts[1].trim() + \",\";\r\n            \r\n            continue;\r\n        }\r\n        # End handle extended values of object\r\n        \r\n        # Check if the line starts with __CLASS which indication a new item (if we do not have the class name (in $parts[1]) we will not create a new item).\r\n        # We also check if the line starts with BOM character + __CLASS when there is UTF-8 BOM Character as the first character (Should only be in the first line to indicate the UTF-8 stream).\r\n        if (($line.startsWith(\"__CLASS\") -or $line.startsWith([char]0xFEFF + \"__CLASS\")) -and $parts[1] -ne $null){\r\n            $class = $parts[1].trim();\r\n            $tableElement = createElement -xmlDocument $script:xmlDocument -name $class;\r\n            continue;\r\n        }\r\n        \r\n        else{\r\n            if ($parts[0]){\r\n                $att = $parts[0].trim();\r\n            }\r\n            if ($parts[1]){\r\n                $val = $parts[1].trim();\r\n            }\r\n        }\r\n        \r\n        createXmlTagAndVal -tableElement $tableElement -val $val -att $att -class $class;\r\n        $val = \"\";\r\n        addNewLineToNode -parent $tableElement -xmlDocument $script:xmlDocument;\r\n    }\r\n}\r\n\r\nfunction createXmlTagAndVal {\r\n    param([System.Xml.XmlElement]$tableElement, [string]$val, [string]$att, [string]$class)\r\n    \r\n    if ($class -and $att -and $val -and $tableElement){    \r\n        appendChild -parent $script:xmlResult -child $tableElement\r\n        \r\n        if ($val.endsWith(\",\")){\r\n            $val = $val.substring(0,$val.length-1);\r\n        }\r\n        \r\n        $val = checkEmptyString -val $val;\r\n        if ($att.equals(\"CommandLine\") -and $val -and ($val -like '*password*')) {\r\n                $val = $val -replace 'password\\s*={0,1}\\s*\\S+', '******';\r\n        }\r\n        $valueElement = createElement -xmlDocument $script:xmlDocument -name $att -value $val;\r\n        appendChild -parent $tableElement -child $valueElement;\r\n    }\r\n}\r\n\r\n# This method creates XML from the results of the Registry queries\r\nfunction registryDataToXml {\r\n    param([string] $results)\r\n    \r\n    $parts = $results -split $SNC_SEPERATOR_REGISTRY;\r\n    \r\n    if ($parts[1] -eq $null){\r\n        return;\r\n    }\r\n\r\n    $value = \"\";\r\n    $tree = \"\";\r\n    $regRes = $parts[1];\r\n    $props = @{};\r\n    $current = $null;\r\n    \r\n    foreach ($line in $($regRes.Split([Environment]::NewLine))){\r\n        if ($line.trim() -eq \"\" -or $line.startsWith(\" \")){\r\n            continue;\r\n        }\r\n        \r\n        $parts = $line.split(\":\", 2);\r\n        \r\n        if ($parts[0] -eq $null){\r\n            continue;\r\n        }\r\n        \r\n        $attName = $parts[0].trim();\r\n        $attValue = $parts[1];\r\n        if ($attValue){\r\n            $attValue = $attValue.trim();\r\n        }\r\n        \r\n        # Line with PSPath Example: PSPath : Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\r\n        if ($attName -eq \"PSPath\"){\r\n            if ($attValue){\r\n                # tree = HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\r\n                $tree = $attValue.replace(\"Microsoft.PowerShell.Core\\Registry::\",\"\");\r\n            }\r\n            else{\r\n                continue;\r\n            }\r\n            \r\n            # Tree: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\r\n            # hive: HKEY_LOCAL_MACHINE\r\n            # key:  SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\r\n            $anotherParts = $tree.split(\"\\\", 2);\r\n            $hive = $anotherParts[0];\r\n            $key = $anotherParts[1];\r\n            $current = outputRegistryKey -hive $hive -key $key;\r\n        }\r\n        # Change of elseif to if will cause PSPath to show in XML\r\n        elseif ($attName -and $attValue -and $current){\r\n            $attValue = checkEmptyString -val $attValue;\r\n            outputRegistryValue -node $current -name $attName -value $attValue;\r\n        }\r\n        addNewLineToNode -parent $current -xmlDocument $script:xmlDocument\r\n    }\r\n}\r\n\r\nfunction rawResultsToJson {\r\n    param([string] $results)\r\n    \r\n    $parts = $results -split $script:SNC_SEPERATOR_REGISTRY;\r\n    \"{\";\r\n    \r\n    # WMI Is a set of objects with a known key (as we created the query).\r\n    if ($parts[0]){\r\n        \"`\"wmi`\": {\" ;\r\n        parseRawWmiToJson -results $parts[0];\r\n        \"},\";\r\n    }\r\n    # Registry are expandable and we cannot know the response in advance and that is why registry is an array\r\n    if ($parts[1]){\r\n        \"`\"registry`\": [\";\r\n        parseRawRegistryToJson -results $parts[1];\r\n        \"]\";\r\n    }\r\n    \r\n    \"}\";\r\n}\r\n\r\nfunction parseRawWmiToJson{\r\n    param([string] $results)\r\n    \r\n    $json = \"\";\r\n    $class = \"\";\r\n    $oldClass = \"\";\r\n    $extendedVal = 0;\r\n    $tmpObj = \"\";\r\n    $isObjArry = $false;\r\n    \r\n    $lines = $results.Split([Environment]::NewLine); # Changed to `r`n|`n\r\n    $lineNumber = -1;\r\n    \r\n    foreach ($line in $lines){\r\n        $lineNumber++;\r\n        if ($line.trim() -eq \"\" -or $line.startsWith(\" \")){\r\n            continue;\r\n        }\r\n        \r\n        $parts = $line.split(\":\", 2);\r\n        \r\n        # Start handle extended values of object - read below for description\r\n        <# Example for objects returned, the PriavteProperties is a System.Management.ManagementBaseObject and right after it we start with the extended values of the object indicated by the EXTENDED_START and all the way till EXTENDED_END.\r\n            __CLASS           : MSCluster_Resource\r\n            Name              : SQL Server Agent (MSSQLCLUSTER)\r\n            Type              : SQL Server Agent\r\n            PrivateProperties : System.Management.ManagementBaseObject\r\n\r\n            EXTENDED_START:\r\n            __GENUS           : 2\r\n            __CLASS           : MSCluster_Property_Resource_SQL_Server_Agent\r\n            __SUPERCLASS      : MSCluster_Property\r\n            __DYNASTY         : MSCluster_Property\r\n            __RELPATH         : \r\n            __PROPERTY_COUNT  : 2\r\n            __DERIVATION      : {MSCluster_Property}\r\n            __SERVER          : \r\n            __NAMESPACE       : \r\n            __PATH            : \r\n            InstanceName      : MSSQLCLUSTER\r\n            VirtualServerName : VSQL\r\n            PSComputerName    : \r\n\r\n            EXTENDED_END!\r\n        #>\r\n        \r\n        # Check if there is a need to read the extension of the object, check the next line - because we would like to replace the \"System.Management.ManagementBaseObject\" string with actual values\r\n        if (areNextValuesExtendedObject -lines $lines -lineNumber $lineNumber){\r\n            # This is the first extended value - reset att and val\r\n            if ($parts[0] -and $extendedVal -eq 0){\r\n                $att = $parts[0].trim();\r\n                $val = \"\";\r\n            }\r\n            $extendedVal++;\r\n            continue;\r\n        }\r\n        \r\n        # We should have all next values as comma separated values of the same object\r\n        if ($extendedVal -gt 0){\r\n            if ($line -eq $EXTENDED_TAG_END){\r\n                $extendedVal--;\r\n                \r\n                # When done with extended values, write the XML tag and reset $val\r\n                if ($extendedVal -eq 0){\r\n                    $val = removeLastComma -str $val;\r\n\r\n                    $tmpObj += createJsonValues -att $att -val $val;\r\n                    $val = \"\";\r\n                }\r\n            }\r\n            \r\n            if (-not $parts[0] -or $line.startsWith(\"__\")){\r\n                continue;\r\n            }\r\n            if (-not $parts[1]){\r\n                continue;\r\n            }\r\n            $val += $parts[0].trim() + \"=\" + $parts[1].trim() + \",\";\r\n            \r\n            continue;\r\n        }\r\n        # End handle extended values of object.\r\n        \r\n        # Check if the line starts with __CLASS which indication a new item (if we do not have the class name (in $parts[1]) we will not create a new item).\r\n        # We also check if the line starts with BOM character + __CLASS when there is UTF-8 BOM Character as the first character (Should only be in the first line to indicate the UTF-8 stream).\r\n        if (($line.startsWith(\"__CLASS\") -or $line.startsWith([char]0xFEFF + \"__CLASS\")) -and $parts[1] -ne $null){\r\n            $class = escapeJsonValue($parts[1].trim());\r\n\r\n            if ($oldClass -eq \"\"){\r\n                $oldClass = $class;\r\n                continue;\r\n            }\r\n            \r\n            # If we spot the same class - in a JSON we would like to have an array.\r\n            if ($class -eq $oldClass){\r\n                $tmpObj = removeLastComma -str $tmpObj\r\n                # Open the first item of the array\r\n                if ($isObjArry -eq $false){\r\n                    $tmpObj = \"{\" + $tmpObj;\r\n                }\r\n                # Close item and open the next one\r\n                if ($tmpObj -ne \"{\"){\r\n                    $tmpObj = $tmpObj + \"},{\";\r\n                }\r\n                # Turn array flag ON\r\n                $isObjArry = $true;\r\n            }\r\n        }\r\n\r\n        # Different class than before - add the tmpObj to the JSON\r\n        if ($class -ne $oldClass){\r\n            # Time to write tmp obj; obj can be an array of JSONs (noted by the array flag isObjArry) or a single JSON\r\n            $json += createJsonObject -objId $oldClass -tmpObj $tmpObj -isObjArry $isObjArry;\r\n            $json += \"`n\";\r\n            # Reset values\r\n            $oldClass = $class;\r\n            $isObjArry = $false;\r\n            $tmpObj = \"\";\r\n        }\r\n        \r\n        if (-not $parts[0]){\r\n            continue;\r\n        }\r\n        \r\n        $att = $parts[0].trim();\r\n        if ($parts[1]){\r\n            $val = $parts[1].trim();\r\n        }\r\n        else {\r\n            $val = \"\";\r\n        }\r\n        \r\n        if ($class -ne \"\" -and $att -ne \"__CLASS\"){\r\n            $tmpObj += createJsonValues -att $att -val $val;\r\n            $val = \"\";\r\n        }\r\n    }\r\n    \r\n    # Add the tmpObj to the JSON\r\n    $json += createJsonObject -objId $oldClass -tmpObj $tmpObj -isObjArry $isObjArry;\r\n\r\n    $json = removeLastComma -str $json\r\n    if ($json -and -not $json.endsWith(\"}\") -and -not$json.endsWith(\"]\")){\r\n        $json += \"}\";\r\n    }\r\n    \r\n    return $json;\r\n}\r\n\r\nfunction createJsonObject{\r\n    param([string]$objId, [string]$tmpObj, [bool]$isObjArry)\r\n    \r\n    # if no id or object - return empty string\r\n    if (-not $tmpObj -or -not $objId){\r\n        return \"\";\r\n    }\r\n    \r\n    # Remove last comma if needed.\r\n    $tmpObj = removeLastComma -str $tmpObj\r\n    # If the object is an array - we should make sure JSON is well formatted.\r\n    if ($isObjArry -eq $true){\r\n        # If we are missing a closer for the last item in the array.\r\n        if ($tmpObj.endsWith('\"')){\r\n            $tmpObj += \"}\";\r\n        }\r\n        return \"\"\"$objId\"\": [$tmpObj],\";\r\n    }\r\n    # This is not an array just an object\r\n    else{\r\n        return \"\"\"$objId\"\": {$tmpObj},\";\r\n    }\r\n}\r\n\r\nfunction createJsonValues{\r\n    param([string]$att, [string]$val)\r\n    \r\n    if (-not $att){\r\n        return \"\";\r\n    }\r\n    \r\n    $att = escapeJsonValue($att);\r\n    $val = escapeJsonValue($val);\r\n    if ($att.equals(\"CommandLine\") -and $val -and ($val -like '*password*')) {\r\n        $val = $val -replace 'password\\s*={0,1}\\s*\\S+', '******';\r\n    }\r\n    return \"`\"$att`\": `\"$val`\",\";\r\n}\r\n\r\n# This function builds key-value pairs for the registry. \r\n# The comma is added before adding the key-value pair.\r\n# Helps with skipping last comma check in parseRawRegistryToJson()\r\nfunction createJsonValuesForRegistry{\r\n    param([string]$att, [string]$val)\r\n\r\n    if ($att -ne \"\"){\r\n       $att = escapeJsonValue($att);\r\n       $val = escapeJsonValue($val);\r\n       \",`\"$att`\": `\"$val`\"\";\r\n    }\r\n}\r\n\r\nfunction parseRawRegistryToJson{\r\n    param([string] $results)\r\n\r\n    $pspath = \"\"\r\n\r\n    foreach ($line in $($results.Split([Environment]::NewLine))){\r\n        $parts = $line.split(\":\", 2);\r\n        \r\n        if ($line.trim() -eq \"\" -or $line.startsWith(\" \")){\r\n            continue;\r\n        }\r\n        \r\n        if (-not $parts[0]){\r\n            continue;\r\n        }\r\n        $att = $parts[0].trim();\r\n        \r\n        if ($parts[1]){\r\n            $val = $parts[1].trim();\r\n        }\r\n        else {\r\n            $val = \"\";\r\n        }\r\n        \r\n        if ($att -eq \"PSPath\"){\r\n            if ($pspath -ne \"\"){\r\n                \"}`n,\";\r\n            }\r\n        \r\n            $pspath = $val;\r\n            \r\n            $escapedPath = $pspath.trim().replace(\"Microsoft.PowerShell.Core\\Registry::\",\"\");\r\n            $escapedPath = escapeJsonValue($escapedPath);\r\n            \"{ `\"Path`\": `\"$escapedPath`\"\";\r\n            continue;\r\n        }\r\n        else{\r\n            createJsonValuesForRegistry -att $att -val $val;\r\n        }\r\n    }\r\n    \"}\";\r\n}\r\n\r\nfunction areNextValuesExtendedObject{\r\n    param([array]$lines, [int]$lineNumber)\r\n    $nextLine = $lines[$lineNumber+1];\r\n    $nextNextLine = $lines[$lineNumber+2];\r\n\r\n    if ($nextLine -ne $null -and ($nextLine -eq $EXTENDED_TAG_START -or ($nextLine.trim() -eq \"\" -and $nextNextLine -and $nextNextLine -eq $EXTENDED_TAG_START))){\r\n        return $true;\r\n    }\r\n    \r\n    return $false;\r\n}\r\n\r\nfunction removeLastComma{\r\n    param([string] $str)\r\n    \r\n    if (-not $str){\r\n        return \"\";\r\n    }\r\n    \r\n    if ($str.endsWith(\",\")){\r\n        return $str.substring(0, $str.length-1); # get rid of the last comma.\r\n    }\r\n    \r\n    return $str;\r\n}\r\n\r\nfunction checkEmptyString{\r\n    param([string] $val)\r\n    \r\n    # If we got a null character return empty string\r\n    if ($val -eq $null -or $val -eq [char] 0x0 -or $val -eq \"&#x0;\") {\r\n        return \"\";\r\n    }\r\n    return $val;\r\n}\r\n\r\nfunction escapeJsonValue{\r\n    param([string] $val)\r\n    \r\n    # If we got a null character return empty string\r\n    if ( (checkEmptyString -val $val) -eq \"\") {\r\n        return \"\";\r\n    }\r\n\r\n    if ($val){\r\n        $val = $val.replace(\"\\\", \"\\\\\");\r\n        $val = $val.replace(\"\"\"\", \"\\\"\"\");\r\n    }\r\n    \r\n    return $val;\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_e1634355376001006b882d465abe5dd5","name":"WMIFetch.psm1","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/5adc4a4073f213005581b7385ef6a7bc","value":"5adc4a4073f213005581b7385ef6a7bc"},"description":"Contains functions for executing a given .ps1 file on a remote target machine","source":"","sys_updated_on":"2021-01-06 23:01:25","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"e6c77b17736e13005581b7385ef6a7db","sys_updated_by":"cong.thieu","sys_created_on":"2018-06-13 01:31:01","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"ExecuteRemote.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"benjamin.phan","sys_mod_count":"64","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"function getConfigurableParm {\r\n   param([string]$variable, [string]$defaultValue)\r\n   $value = [Environment]::GetEnvironmentVariable($variable)\r\n   if (-not $value) {\r\n        $value = $defaultValue;\r\n    }\r\n    return $value;\r\n}\r\n \r\n<# Benjamin Phan:\r\n   This function should probably not be called outside of executeRemote, since this function depends on variables being set\r\n   by executeRemote. We might want to refactor executeRemote so that this part is placed inline rather than in this function.\r\n   I originally made it this way because it seemed easier to read, but really it should not be a function in case someone\r\n   comes across it and tries to use it standalone.\r\n#>\r\nfunction launchWMI {\r\n   param([string]$computer, [System.Management.Automation.PSCredential]$cred, [string]$sourceScript, [string]$scriptBlock, [switch]$copyScriptToTarget, [int]$launchProcessWaitTime)\r\n   $context = startImpersonation $cred\r\n   $cmdLongline = \"mode con lines=1 cols=$([int16]::MaxValue-1)\";\r\n   if ($copyScriptToTarget) {\r\n       $executionPolicyFlag = ' -ExecutionPolicy Bypass';\r\n   } else {\r\n       $executionPolicyFlag = '';\r\n   }\r\n   # the space between powershell and the executionPolicyFlag is contained in the executionPolicyFlag itself\r\n   $cmdPowerShellPrefix = \"powershell$executionPolicyFlag -NonInteractive -WindowStyle Hidden\";\r\n   \r\n\r\n   # set some useful variables\r\n   $varString = \"Set-Variable -Name 'SNC_isWmi' -Value `$true -Scope Global; \"\r\n\r\n\r\n   # check if we have any variables we need to send to the remote session\r\n   $remoteVarsVariable = Get-ChildItem -Path Env:SNCExecuteRemoteVars 2> $null\r\n   if ($?) {\r\n       $paramNamesString = $remoteVarsVariable.Value\r\n       $vars = ($paramNamesString -split \",\")\r\n\r\n       # build up command containing variables and values to pass to remote session\r\n       Foreach ($var in $vars) {\r\n           $varObj = Get-Variable -Name $var\r\n           $varName = $varObj.Name\r\n           $varVal = $varObj.Value\r\n\r\n           # only need to escape single quotes, double quotes are passed properly without escaping\r\n           $escapedVarVal = $varVal -replace \"'\",\"''\"\r\n           $varString += \"Set-Variable -Name '$varName' -Value '$escapedVarVal' -Scope Global; \"\r\n       }\r\n   }\r\n\r\n   # If we got a sourceScript as a file path and we should not copy the script to the target, run the script as script block.     \r\n   if ($sourceScript -and -not $copyScriptToTarget) {\r\n      $scriptBlock = (Get-Content -path $sourceScript)\r\n   }\r\n\r\n   if ($scriptBlock){\r\n      # If we get a string as a script block, attach the the command to make sure that the windows is large enough for long line and pass is as the powerlshell command\r\n      $varCommand = \"& {$cmdLongline; $varString $scriptBlock}\";\r\n\r\n      # escape the command for cmd\r\n      # for sequences of backslashes followed by double quote, double the number of quotes\r\n      # also convert any \" to \\\"\"\r\n      $escapedCommand = $varCommand -replace '(\\\\*)\"', '$1$1\\\"\"'\r\n      $command = \"$cmdPowerShellPrefix -command `\"$escapedCommand`\"\"\r\n   }\r\n   else {\r\n      # Create directories as needed and copy script to directory\r\n      $pathExists = Test-Path -Path $remoteHomeDir\r\n      if (-not $?) {\r\n        throw \"Failed to test the path $remoteHomeDir\"\r\n      }\r\n      if (-not $pathExists) {\r\n        New-Item -ItemType directory -Path $remoteHomeDir -Force > $null\r\n        if (-not $?) {\r\n         throw \"Failed to create directory $remoteHomeDir\"\r\n        }\r\n      }\r\n\r\n      Copy-Item -Path $sourceScript -Destination $remoteScriptPath -Force -Recurse\r\n      if (-not $?) {\r\n         throw \"Failed to copy script $sourceScript to target $remoteScriptPath\"\r\n      }\r\n\r\n     # create a script on the target that contains the commands to set powershell params\r\n     $paramFileGuid = [System.Guid]::NewGuid()\r\n     $targetParamFileName = \"executeRemote_params_$paramFileGuid.ps1\"\r\n     $remoteParamScript = \"$remoteHomeDir\\$targetParamFileName\"\r\n     $localParamScript = \"$localHomeDir\\$targetParamFileName\"\r\n\r\n     # add the home directory and script path to the parameters that are passed to the remote powershell process\r\n     $varString += \"Set-Variable -Name 'SNC_remoteScriptDirectory' -Value '$localHomeDir' -Scope Global; \"\r\n     $varString += \"Set-Variable -Name 'SNC_remoteScriptPath' -Value '$localScriptPath' -Scope Global; \"\r\n         \r\n     New-Item -ItemType \"file\" -Path $remoteParamScript -Force > $null\r\n     Set-Content -Value $varString -Path $remoteParamScript -Force -Encoding UTF8\r\n\r\n     $hasParams = $true\r\n     $runParamsScript = \"try { & `\"$localParamScript`\"; } catch {}\"\r\n      \r\n     # Potential security issue: passing parameters to target through plain text\r\n     $varCommand = \"& {$cmdLongline; $runParamsScript & `\"$localScriptPath`\" `\"$localParamScript`\"}\"\r\n     $escapedCommand = $varCommand -replace '(\\\\*)\"', '$1$1\\\"\"'\r\n     $command = \"$cmdPowerShellPrefix -command `\"$escapedCommand`\"\"\r\n   }\r\n\r\n   # Run script remotely\r\n   try {\r\n      # call launchProcess with -UTF8 so that unicode characters are brought back and put into the payload properly\r\n      if ($launchProcessWaitTime) {\r\n         launchProcess -computer $computer -cred $cred -command $command -UTF8 -secondsToWait $launchProcessWaitTime -shouldKillProcess $true\r\n      } else {\r\n         launchProcess -computer $computer -cred $cred -command $command -UTF8\r\n      }\r\n   } catch [System.IO.FileNotFoundException] {\r\n        throw;\r\n   } catch {\r\n      write-error $_.Exception.Message\r\n   } finally {\r\n     if (-not $scriptBlock){\r\n        Remove-Item -Path $remoteScriptPath -Force\r\n        if ($hasParams) {\r\n           Remove-Item -Path $remoteParamScript -Force\r\n        }\r\n     }\r\n   }\r\n   endImpersonation $context\r\n}\r\n\r\nfunction executeRemote {\r\n    Param([string]$computer, [string][Parameter(Mandatory=$true,ParameterSetName='filePath')]$filePath, [string][Parameter(Mandatory=$true,ParameterSetName='scriptBlock')]$scriptBlock, [boolean] $wmi, [System.Management.Automation.PSCredential]$cred, [switch][Parameter(ParameterSetName='filePath')]$copyScriptToTarget, [int]$launchProcessWaitTime)\r\n\r\n    # for WMI, read base_dir from the env.  for WinRM, use the shell\r\n    if ($wmi) {\r\n        $targetBaseDir  = getConfigurableParm -variable \"SNC_base_dir\" -defaultvalue \"admin$\\temp\"\r\n    } elseif ($SNC_base_dir) {\r\n        $targetBaseDir  = $SNC_base_dir\r\n    } else {\r\n         $targetBaseDir  = \"admin$\\temp\"\r\n    }\r\n\r\n    $instanceName = getConfigurableParm -variable \"SNC_instance\" -defaultvalue \"unregistered\"\r\n\r\n    $targetFileGuid = [System.Guid]::NewGuid()\r\n    $targetFileName = \"psscript_executeRemote_$targetFileGuid.ps1\"\r\n\r\n    $homeDir = \"$targetBaseDir\\$instanceName\"\r\n    $localHomeDir = \"\\\\127.0.0.1\\$homeDir\"\r\n    $localScriptPath = \"$localHomeDir\\$targetFileName\"\r\n    $remoteHomeDir = \"\\\\$computer\\$homeDir\"\r\n    $remoteScriptPath = \"$remoteHomeDir\\$targetFileName\"\r\n    \r\n    if ($wmi) {\r\n        launchWMI -computer $computer -launchProcessWaitTime $launchProcessWaitTime -cred $cred -sourceScript $filePath -scriptBlock $scriptBlock -copyScriptToTarget:$copyScriptToTarget;\r\n    } else {\r\n        # This is a WimRM session\r\n        $remotePs = getRemoteSession;\r\n        if ($remotePs) {\r\n            # pass powershell_param_ variables to the remote session\r\n            if ($SNC_REMOTE_VARIABLES) {\r\n                $varNames = $SNC_REMOTE_VARIABLES -split \",\"\r\n                Foreach ($varName in $varNames) {\r\n                    $value = (Get-Variable $varName).Value\r\n\r\n                    # only need to escape single quotes, double quotes are passed properly without escaping\r\n                    $escapedValue = $value -replace \"'\",\"''\"\r\n                    $sbString = \"Set-Variable -Name '$varName' -Value '$escapedValue'\"\r\n                    if (isJEACodeSigning) {\r\n                        invokeJEAExecuteScript $remotePs $sbString\r\n                    } else {\r\n                        $paramsSb = [scriptblock]::Create($sbString)\r\n                        Invoke-Command -Session $remotePs -ScriptBlock $paramsSb\r\n                    }\r\n                }\r\n            }\r\n            # If it is JEA code signing, we want to enforce copy script file to target so that we can verify it signature.\n            # Note that isJEACodeSigning is a function returning a boolean value. Don't use it directly in a boolean expression\n            # like (isJEACodeSigning -and $filePath). It will be evaluated to $true even if $filePath is empty!\n            # There is a good article about PS logical operators at https://4sysops.com/archives/powershell-logical-operators/\n            if ($copyScriptToTarget -or ((isJEACodeSigning) -and $filePath)) {\r\n                # copy the script to the target\r\n                SendFileExecuteRemote -Path $filePath -Destination $localHomeDir -Name $targetFileName -Session $remotePs > $null\r\n\r\n                # pass the directory of the script on target to the remote session\r\n                $sbString = \"Set-Variable -Name 'SNC_remoteScriptDirectory' -Value '$localHomeDir'\"\r\n                if (isJEACodeSigning) {\r\n                    invokeJEAExecuteScript $remotePs $sbString\r\n                } else {\r\n                    $paramsSb = [scriptblock]::Create($sbString)\r\n                    Invoke-Command -Session $remotePs -ScriptBlock $paramsSb\r\n                }\r\n\r\n                # pass the path of the script on target to the remote session\r\n                $sbString = \"Set-Variable -Name 'SNC_remoteScriptPath' -Value '$localScriptPath'\"\r\n                if (isJEACodeSigning) {\r\n                    invokeJEAExecuteScript $remotePs $sbString\r\n                } else {\r\n                    $paramsSb = [scriptblock]::Create($sbString)\r\n                    Invoke-Command -Session $remotePs -ScriptBlock $paramsSb\r\n                }\r\n                \r\n                # Tell the remote that we're not using WMI\r\n                $sbString = \"Set-Variable -Name 'SNC_isWmi' -Value `$false\"\r\n                if (isJEACodeSigning) {\r\n                    invokeJEAExecuteScript $remotePs $sbString\r\n                } else {\r\n                    $paramsSb = [scriptblock]::Create($sbString)\r\n                    Invoke-Command -Session $remotePs -ScriptBlock $paramsSb\r\n                }\r\n\r\n                # execute the script on the target\r\n                $executeScriptSb = [ScriptBlock]::Create(\"try { Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass; } finally { & `\"$localScriptPath`\" }\")\r\n                if (isJEACodeSigning) {\r\n                    $output = invokeJEAExecuteScript $remotePs $executeScriptSb.toString() -ErrorAction Continue\r\n                } else {\r\n                    $output = Invoke-Command -Session $remotePs -ScriptBlock $executeScriptSb -ErrorAction Continue\r\n                }\r\n\r\n                #remove the script on the target\r\n                $removeFileSb = [ScriptBlock]::Create(\"Remove-Item `\"$localScriptPath`\" -Force\")\r\n                if (isJEACodeSigning) {\r\n                    InvokeJEAExecuteScript $remotePs $removeFileSb.toString() > $null\r\n                } else {\r\n                    Invoke-Command -Session $remotePs -ScriptBlock $removeFileSb > $null\r\n                }\r\n            } elseif ($filePath) {\r\n                # execute the script on the target\r\n                $output = Invoke-Command -Session $remotePs -FilePath $filePath -ErrorAction Continue\r\n            } elseif ($scriptblock) {\r\n                $scriptBlockRemote = [Scriptblock]::Create($scriptblock);\r\n                if (isJEACodeSigning) {\r\n                    invokeJEAExecuteScript $remotePs $scriptBlockRemote.toString()\r\n                } else {\r\n                    Invoke-Command -Session $remotePs -ScriptBlock $scriptBlockRemote;\r\n                }\r\n            }\r\n            foreach ($out in $output) {\r\n                # must use [Console]::WriteLine because [Console]::OutputEncoding is properly set to UTF8\r\n                # Write-Host and Write-Output do not correctly pass unicode characters back to MID Java code\r\n                [Console]::WriteLine($out)\r\n            }\r\n        } else {\r\n            Write-Error \"Failed to create remote Powershell Session\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction getRemoteSession{\r\n    if ($SNC_session -and $SNC_session.getType() -and $SNC_session.getType().Name.ToLower() -eq \"pssession\"){\r\n        return $SNC_session\r\n    }\r\n    \r\n    return CreatePSSessionWithComputerName -host $computer -credential $cred;\r\n}\r\n\r\nfunction SendFileExecuteRemote\r\n{\r\n    <#\r\n    Author: Benjamin Phan\r\n    10/12/18\r\n    Ripped from LaunchProc.psm1 with modifications.\r\n    This Send-File takes in a Destination directory and a Name, which allows us to change the resulting file's name.\r\n    The original Send-File sets the resulting file's name to be the same as the source file.\r\n\r\n    Another difference is that this function does not use using:$variables, since this functionality does not seem\r\n    to be supported in Powershell 2.0.\r\n\r\n    We need this function inside this module because LaunchProc.psm1 is not imported into the Powershell session\r\n    when we are on the WinRM code path.\r\n    #>\r\n    [CmdletBinding()]\r\n    param\r\n    (\r\n        [string[]]$Path,[string]$Destination, [string]$Name, [System.Management.Automation.Runspaces.PSSession]$Session\r\n    )\r\n    process\r\n    {\r\n        foreach ($p in $Path)\r\n        {\r\n            try\r\n            {\r\n                if ($p.StartsWith('\\\\'))\r\n                {\r\n                    Write-Verbose -Message \"[$($p)] is a UNC path. Copying locally first\"\r\n                    Copy-Item -Path $p -Destination ([environment]::GetEnvironmentVariable('TEMP', 'Machine'))\r\n                    $p = \"$([environment]::GetEnvironmentVariable('TEMP', 'Machine'))\\$($p | Split-Path -Leaf)\"\r\n                }\r\n                if (Test-Path -Path $p -PathType Container) # If the path is a directory, get all files under directory\r\n                {\r\n                    Write-Log -Source $MyInvocation.MyCommand -Message \"[$($p)] is a folder. Sending all files\"\r\n                    $files = Get-ChildItem -Path $p -File -Recurse\r\n                    $sendFileParamColl = @()\r\n                    foreach ($file in $Files)\r\n                    {\r\n                        $sendParams = @{\r\n                            'Session' = $Session\r\n                            'Path' = $file.FullName\r\n                        }\r\n                        if ($file.DirectoryName -ne $p) ## It's a subdirectory\r\n                        {\r\n                            $subdirpath = $file.DirectoryName.Replace(\"$p\\\", '')\r\n                            $sendParams.Destination = \"$Destination\\$subDirPath\"\r\n                        }\r\n                        else\r\n                        {\r\n                            $sendParams.Destination = $Destination\r\n                        }\r\n                        $sendFileParamColl += $sendParams\r\n                    }\r\n                    foreach ($paramBlock in $sendFileParamColl)\r\n                    {\r\n                        SendFileExecuteRemote @paramBlock\r\n                    }\r\n                }\r\n                else # Sending individual file\r\n                {\r\n                    Write-Verbose -Message \"Starting WinRM copy of [$($p)] to [$($Destination)]\"\r\n                    $remoteScript = {\r\n                        param($dest, $fname, $len, $destBytes)\r\n                        if (-not (Test-Path -Path $dest -PathType Container))\r\n                        {\r\n                            $null = New-Item -Path $dest -Type Directory -Force\r\n                        }\r\n                        $fileDest = \"$dest\\$fname\"\r\n                        if (-not $destBytes) {\n                            ## Create a new array to hold the file content\r\n                            $destBytes = New-Object byte[] $len\r\n                            $position = 0\r\n                            \r\n                            ## Go through the input, and fill in the new array of file content\r\n                            foreach ($chunk in $input)\r\n                            {\r\n                                [GC]::Collect()\r\n                                [Array]::Copy($chunk, 0, $destBytes, $position, $chunk.Length)\r\n                                $position += $chunk.Length\r\n                            }\r\n                        }\n                        \r\n                        [IO.File]::WriteAllBytes($fileDest, $destBytes)\r\n                        \r\n                        Get-Item $fileDest\r\n                        [GC]::Collect()\r\n                    }\r\n                    \r\n                    # Get the source file, and then get its contents\r\n                    $sourceBytes = [System.IO.File]::ReadAllBytes($p);\r\n                    $Length = $sourceBytes.Length\r\n                    if (isJEACodeSigning) {\r\n                        $_params = @{  \r\n                            \"dest\" = $Destination\r\n                            \"fname\" = $Name\r\n                            \"len\" = $Length\r\n                            \"destBytes\" = $sourceBytes\r\n                        }\r\n                        $_fileDest = invokeJEAExecuteScript $Session $remoteScript.toString() $_params\r\n                        return $_fileDest;\n                    } else {\r\n                        # Stream the chunks into the remote script.\r\n                        $streamChunks = @();\r\n                        \r\n                        # Now break it into chunks to stream.\r\n                        $streamSize = 1MB;\r\n                        for ($position = 0; $position -lt $sourceBytes.Length; $position += $streamSize)\r\n                        {\r\n                            $remaining = $sourceBytes.Length - $position\r\n                            $remaining = [Math]::Min($remaining, $streamSize)\r\n                            \r\n                            $nextChunk = New-Object byte[] $remaining\r\n                            [Array]::Copy($sourcebytes, $position, $nextChunk, 0, $remaining)\r\n                            $streamChunks +=, $nextChunk\r\n                        }\r\n                        $streamChunks | Invoke-Command -Session $Session -ScriptBlock $remoteScript -ArgumentList $Destination,$Name,$Length\r\n                    }\r\n                    Write-Verbose -Message \"WinRM copy of [$($p)] to [$($Destination)] complete\"\r\n                }\r\n            }\r\n            catch\r\n            {\r\n                Write-Error $_.Exception.Message\r\n            }\r\n        }\r\n    }\r\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_e6c77b17736e13005581b7385ef6a7db","name":"ExecuteRemote.psm1","sys_policy":"","use_attachment":"false"},{"parent":"","description":"SSH scripts","source":"","sys_updated_on":"2019-09-05 23:59:00","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"e97f7010777333000e846558981061fa","sys_updated_by":"tim.broberg","sys_created_on":"2019-09-05 23:59:00","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"SSH","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"tim.broberg","sys_mod_count":"0","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_e97f7010777333000e846558981061fa","name":"SSH","sys_policy":"","use_attachment":"false"},{"parent":"","description":"Holds PowerShell script files for use by the MID Server","source":"","sys_updated_on":"2013-04-04 16:51:45","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"ef89e4fc372001006b882d465abe5d60","sys_updated_by":"jimmy.yuan","sys_created_on":"2013-04-02 16:15:07","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"PowerShell","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"jimmy.yuan","sys_mod_count":"2","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_ef89e4fc372001006b882d465abe5d60","name":"PowerShell","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/b0c9a9a3370002000e4d03488e41f113","value":"b0c9a9a3370002000e4d03488e41f113"},"description":"","source":"","sys_updated_on":"2015-07-17 08:05:44","directory":"true","sys_class_name":"ecc_agent_script_file","sys_id":"f81b00b1f711020028f47d78ac99d9be","sys_updated_by":"will.swift","sys_created_on":"2015-07-17 08:05:44","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"ScriptAPI","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"will.swift","sys_mod_count":"0","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/91d8237704f12210559073c06a02f73b","value":"91d8237704f12210559073c06a02f73b"},"sys_update_name":"ecc_agent_script_file_f81b00b1f711020028f47d78ac99d9be","name":"ScriptAPI","sys_policy":"","use_attachment":"false"},{"parent":{"link":"https://dev315171.service-now.com/api/now/v1/table/ecc_agent_sync_file/ef89e4fc372001006b882d465abe5d60","value":"ef89e4fc372001006b882d465abe5d60"},"description":"Utility for creating remote PSSession","source":"","sys_updated_on":"2019-09-10 01:11:41","directory":"false","sys_class_name":"ecc_agent_script_file","sys_id":"fbebdd359f6213005581decf857fcfae","sys_updated_by":"thanh.phan","sys_created_on":"2018-06-08 01:19:49","sys_domain":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_user_group/global","value":"global"},"checksum":"","sys_name":"PSRemoteSession.psm1","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"script_attachment":"","sys_created_by":"thanh.phan","sys_mod_count":"4","active":"true","sys_overrides":"","sys_domain_path":"","sys_tags":"","version":"","script":"function CreatePSSessionWithComputerName {\r\n    param([string]$Host, [string]$Port, [Nullable[bool]]$UseSSL,\r\n          [System.Management.Automation.PSCredential]$Credential, [string]$ConfigurationName, [string]$AdditionalOptions)\r\n\r\n    $connectionOption = FormConnectionOptionWithComputerName -Host $Host -Port $Port -UseSSL $UseSSL\r\n    CreateNewPSSession -ConnectionOption $connectionOption -Credential $Credential -ConfigurationName $ConfigurationName -AdditionalOptions $AdditionalOptions\r\n}\r\n\r\nfunction CreatePSSessionWithURI {\r\n    param([string]$Host, [string]$Port, [string]$UriPath, [Nullable[bool]]$UseSSL,\r\n          [System.Management.Automation.PSCredential]$Credential, [string]$ConfigurationName, [string]$AdditionalOptions)\r\n\r\n    $connectionOption = FormConnectionOptionByURI -Host $Host -Port $Port -UriPath $UriPath -UseSSL $UseSSL\r\n    CreateNewPSSession -ConnectionOption $connectionOption -Credential $Credential -ConfigurationName $ConfigurationName -AdditionalOptions $AdditionalOptions\r\n}\r\n\r\nfunction FormConnectionOptionWithComputerName {\r\n    param([string]$Host, [string]$Port, [Nullable[bool]]$UseSSL)\r\n\r\n    #\r\n    # handle optional parameters: if not speficied, use default values from environment variables\r\n    #\r\n    if ([string]::IsNullOrEmpty($Port)) {\r\n        $Port = $env:SNC_targetPort\r\n    }\r\n\r\n    if ($UseSSL -eq $null) {\r\n        $UseSSL = ($env:SNC_useSSL -eq \"true\")\r\n    }\r\n\r\n\t$options = \"-ComputerName $Host\";\r\n\r\n    if (-not [string]::IsNullOrEmpty($Port)) {\r\n        $options +=  \" -Port $Port\"\r\n    }\r\n\r\n\tif ($UseSSL) {\r\n        $options +=  \" -UseSSL\"\r\n    }\r\n\r\n    $options\r\n}\r\n\r\nfunction FormConnectionOptionByURI {\r\n    param([string]$Host, [string]$Port, [string]$UriPath, [Nullable[bool]]$UseSSL)\r\n\r\n    #\r\n    # handle optional parameters: if not speficied, use default values from environment variables\r\n    #\r\n    if ([string]::IsNullOrEmpty($Port)) {\r\n        $Port = $env:SNC_targetPort\r\n    }\r\n\r\n    if ($UseSSL -eq $null) {\r\n        $UseSSL = ($env:SNC_useSSL -eq \"true\")\r\n    }\r\n\r\n    # default to \"/wsman\" if URI path not specified\r\n    if ([string]::IsNullOrEmpty($UriPath)) {\r\n        $UriPath = \"/wsman\"\r\n    }\r\n\r\n    # form URI\r\n    if ($UseSSL -eq $true) {\r\n        $protocol = \"https\"\r\n    } else {\r\n        $protocol = \"http\"\r\n    }\r\n\t$uri = $protocol + \"://\" + $Host;\r\n    if (-not [string]::IsNullOrEmpty($Port)) {\r\n        $uri += \":$Port\"\r\n    }\r\n\t$uri += $UriPath;\r\n\r\n    \"-ConnectionUri $uri\"\r\n}\r\n\r\nfunction CreateNewPSSession {\r\n    param([string]$ConnectionOption, [System.Management.Automation.PSCredential]$Credential, [string]$ConfigurationName, [string]$AdditionalOptions)\r\n\r\n    # if credential is not explicitly specified, use the global variable $cred\r\n    if (-not ($Credential)) {\r\n        $Credential = $cred\r\n    }\r\n\r\n    # if additional options are not explicitly specified, use environment variable\r\n    if ([string]::IsNullOrEmpty($AdditionalOptions)) {\r\n        $AdditionalOptions = $env:SNC_additionalPSSessionOptions\r\n    }\r\n\r\n    # form the New-PSSession command, using the connection option as the base,\r\n    # adding credential, SSL certificate options, and other options if applicable\r\n    $cmd = \"New-PSSession $connectionOption\"\r\n\r\n    if ($Credential) {\r\n        # care must be taken in using single quote here: $credential is an object and\r\n        # we do not want the variable to be expanded and turned into a string;\r\n        # it will be evaluated when the script block is executed\r\n        $cmd += ' -Credential $Credential'\r\n        SNCLog-DebugInfo \"Running CreateNewPSSession with user $($Credential.UserName)\"\r\n    } else {\r\n        $cmd += ' -Authentication NegotiateWithImplicitCredential'\r\n        SNCLog-DebugInfo \"Running CreateNewPSSession without explicit credential\"\r\n    }\r\n\r\n    if ($env:SNC_skipSSLCertCheckOptions) {\r\n        $soCmd = \"New-PSSessionOption $env:SNC_skipSSLCertCheckOptions\"\r\n        $soSb = [Scriptblock]::Create($soCmd)\r\n        $so = & $soSb\r\n        # care must be taken in using single quote here: $so is an object\r\n        $cmd += ' -SessionOption $so'\r\n    }\r\n\r\n    if (-not [string]::IsNullOrEmpty($ConfigurationName)) {\r\n        $cmd += \" -ConfigurationName `\"$ConfigurationName`\"\"\r\n    }\r\n\r\n    if (-not [string]::IsNullOrEmpty($AdditionalOptions)) {\r\n        $cmd += \" $AdditionalOptions\"\r\n    }\r\n\r\n    SNCLog-DebugInfo (\"Running create session script: \" + $ExecutionContext.InvokeCommand.ExpandString($cmd))\r\n    $sb = [Scriptblock]::Create($cmd)\r\n    & $sb\r\n}\r\n","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/42b8273704f12210559073c06a02f78d","value":"42b8273704f12210559073c06a02f78d"},"sys_update_name":"ecc_agent_script_file_fbebdd359f6213005581decf857fcfae","name":"PSRemoteSession.psm1","sys_policy":"","use_attachment":"false"}]}