{"result":[{"diagram_options":"function getDiagramOptions($, go, dispatch, uuidv4) {\n\tvar MAX_TABLE_ENTRIES_SHOWN = 10;\n    return {\n        allowDelete: false,\n        initialDocumentSpot: go.Spot.Top,\n        initialViewportSpot: go.Spot.Top,\n        maxSelectionCount: 1,\n        // support mouse wheel scrolling of table when the mouse is in the table\n        'toolManager.doMouseWheel': function() {\n            var e = this.diagram.lastInput;\n            var tab = this.diagram.findObjectAt(e.documentPoint);\n            while (tab !== null && !tab._updateScrollBar) tab = tab.panel;\n            if (tab !== null) {\n                var scrolling_table = tab.part;\n                var table = scrolling_table.findObject(\"TABLE\");\n                var scrollbarButton = scrolling_table.findObject(\"SCROLLBARBUTTON\");\n                if (table && scrollbarButton) {\n                    var delta = e.delta;\n                    if (delta > 0) {\n                        table.topIndex = Math.max(0, table.topIndex - 1);\n                    } else if (delta < 0) {\n                        table.topIndex = Math.min(table.topIndex + 1, Math.max(0, table.rowCount - MAX_TABLE_ENTRIES_SHOWN)); // Prevent exceeding row count or going below 0\n                    }\n                    var scrollLocation = (table.topIndex / table.rowCount) * (table.rowCount / (table.rowCount - MAX_TABLE_ENTRIES_SHOWN));\n                    scrollbarButton.alignment = new go.Spot(0.5, scrollLocation, 0, 0);\n                }\n\n                e.handled = true;\n                return;\n            }\n            go.ToolManager.prototype.doMouseWheel.call(this);\n        },\n        'toolManager.gestureBehavior': go.ToolManager.GestureZoom,\n        'toolManager.hoverDelay': 300,\n        'relinkingTool.linkValidation': function(fromNode, fromPort, toNode) {\n            if (fromNode.containingGroup || toNode.containingGroup) {\n                return (fromNode.containingGroup && toNode.containingGroup && toNode.containingGroup.data.key === fromNode.containingGroup.data.key);\n            }\n            return true;\n        },\n        'draggingTool.dragsLink': false,\n        'undoManager.isEnabled': true,\n        'undoManager.maxHistoryLength': 0,\n        'contextMenuTool.canStart': function() {\n            if (this.diagram.lastInput.clickCount > 1) return false;\n            return go.ContextMenuTool.prototype.canStart.call(this);\n        },\n        'contextMenuTool.standardMouseClick': function() {\n            return false;\n        },\n        'draggingTool.isEnabled': false, // To enable/disable dragging of nodes and links\n        'animationManager.isEnabled': false, // To enable/disable animations\n        contentAlignment: go.Spot.Center, // Position to which content to be aligned\n        'draggingTool.doActivate': function() { // To write custom logic when dragging gets started\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_ACTIVATED');\n            go.DraggingTool.prototype.doActivate.call(this);\n        },\n        'draggingTool.doDeactivate': function() { // To write custom logic when dragging gets stopped\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_DEACTIVATED');\n            go.DraggingTool.prototype.doDeactivate.call(this);\n        },\n        'draggingTool.standardMouseSelect': function() { // To write custom logic when mouse selection done while dragging\n            go.DraggingTool.prototype.standardMouseSelect.call(this);\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_SELECTED');\n        },\n        'draggingTool.doMouseMove': function() { // To write custom logic when mouse move started while dragging\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_MOVED');\n            go.DraggingTool.prototype.doMouseMove.call(this);\n        },\n        'draggingTool.doMouseUp': function() { // To write custom logic when mouse up done while dragging\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_UP');\n            go.DraggingTool.prototype.doMouseUp.call(this);\n        },\n        ViewportBoundsChanged: function(event) { // To write custom logic when viewportBoundsChanged\n            dispatch('GO_DIAGRAM#VIEWPORT_BOUNDS_CHANGED', {\n                event: event\n            });\n        },\n        LinkDrawn: function(event) { // To write custom logic when link drawn\n            dispatch('GO_DIAGRAM#LINK_DRAWN', {\n                event: event\n            });\n        },\n        ChangedSelection: function(event) { // To write custom log while selection gets changed\n            dispatch('GO_DIAGRAM#SELECTION_CHANGED', {\n                selection: event.subject.first()\n            });\n        },\n        ModelChanged: function(event) { // To write custom logic when diagram model changed\n            dispatch('GO_DIAGRAM#MODEL_CHANGED', {\n                event: event\n            });\n        },\n    };\n}","diagram_template":"","advanced":"false","sys_updated_on":"2024-06-18 19:54:43","sys_class_name":"sn_diagram_builder_configuration","enable_search":"false","sys_id":"0838ce29973111102d264ae8f6890d97","sys_updated_by":"admin","enable_animation":"false","sys_created_on":"2022-09-07 17:30:38","sys_name":"Schema Viewer Configuration","right_component":"","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/f53f19bac362fa22ca2e93692d32f18f","value":"f53f19bac362fa22ca2e93692d32f18f"},"theme":"","enable_layout_customization":"true","sys_created_by":"admin","right_panel":"false","content_alignment":"Center","palette_configuration":"","sys_mod_count":"52","sys_tags":"","alerts_component":"","props":"","layout":"function getLayout($, go) {\n    var ANGLE = 90;\n    var NODE_SPACING = 100;\n    var LAYER_SPACING = 120;\n    var ALTERNATE_ANGLE = 0;\n\n    return $(go.TreeLayout, {\n        angle: ANGLE,\n        nodeSpacing: NODE_SPACING,\n        layerSpacing: LAYER_SPACING,\n        alternateAngle: ALTERNATE_ANGLE,\n        setsChildPortSpot: false,\n        setsPortSpot: false,\n        isInitial: true\n    });\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/f53f19bac362fa22ca2e93692d32f18f","value":"f53f19bac362fa22ca2e93692d32f18f"},"sys_update_name":"sn_diagram_builder_configuration_0838ce29973111102d264ae8f6890d97","left_panel":"false","enable_dragging":"true","name":"Schema Viewer Configuration","header":"false","left_component":"","sys_policy":""},{"diagram_options":"function getDiagramOptions($, go, dispatch, uuidv4, resolveThemeVariable) {\n    return {\n        allowDelete: false,\n        maxSelectionCount: 1,\n        'contentAlignment': go.Spot.Default,\n        'initialPosition': new go.Point(0, 0),\n        'toolManager.gestureBehavior': go.ToolManager.GestureZoom,\n        'toolManager.hoverDelay': 300,\n        'relinkingTool.linkValidation': function(fromNode, fromPort, toNode) {\n            if (fromNode.containingGroup || toNode.containingGroup) {\n                return (fromNode.containingGroup && toNode.containingGroup && toNode.containingGroup.data.key === fromNode.containingGroup.data.key);\n            }\n            return true;\n        },\n        'draggingTool.dragsLink': true,\n        'undoManager.isEnabled': true,\n        'undoManager.maxHistoryLength': 0,\n        'contextMenuTool.canStart': function() {\n            if (this.diagram.lastInput.clickCount > 1) return false;\n            return go.ContextMenuTool.prototype.canStart.call(this);\n        },\n        'contextMenuTool.standardMouseClick': function() {\n            return false;\n        },\n        'animationManager.isEnabled': false,\n        'draggingTool.isEnabled': true,\n        'draggingTool.doActivate': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_ACTIVATED', {\n                draggingTool: this\n            });\n        },\n        'draggingTool.doDeactivate': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_DEACTIVATED', {\n                draggingTool: this\n            });\n        },\n        'draggingTool.standardMouseSelect': function() {\n            go.DraggingTool.prototype.standardMouseSelect.call(this);\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_SELECTED');\n        },\n        'draggingTool.doMouseMove': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_MOVED', {\n                draggingTool: this\n            });\n        },\n        'draggingTool.doMouseUp': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_UP', {\n                draggingTool: this\n            });\n\n        },\n        ViewportBoundsChanged: function(event) {\n            dispatch('GO_DIAGRAM#VIEWPORT_BOUNDS_CHANGED', {\n                event: event\n            });\n        },\n        LinkDrawn: function(event) {\n            dispatch('GO_DIAGRAM#LINK_DRAWN', {\n                event: event,\n                edgeId: \"539bb9bb532310100b0cddeeff7b1207\"\n            });\n        },\n        ChangedSelection: function(event) {\n            dispatch('GO_DIAGRAM#SELECTION_CHANGED', {\n                selection: event.subject.first()\n            });\n        },\n        ModelChanged: function(event) {\n            dispatch('GO_DIAGRAM#MODEL_CHANGED', {\n                event: event\n            });\n        },\n    };\n}","diagram_template":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_diagram_template/d17665d5c3be3110b09bb4cdb840dd6a","value":"d17665d5c3be3110b09bb4cdb840dd6a"},"advanced":"true","sys_updated_on":"2024-05-17 12:51:17","sys_class_name":"sn_diagram_builder_configuration","enable_search":"true","sys_id":"161dd439c38a3d10b09bb4cdb840dd6c","sys_updated_by":"admin","enable_animation":"false","sys_created_on":"2023-10-23 06:58:37","sys_name":"Sample Grid Layout Configuration","right_component":"","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/1cf7ad026abf3abab12e761ddaa6e9df","value":"1cf7ad026abf3abab12e761ddaa6e9df"},"theme":"","enable_layout_customization":"true","sys_created_by":"admin","right_panel":"false","content_alignment":"Center","palette_configuration":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_palette_configuration/458a7065a33002105d51b85de31e6188","value":"458a7065a33002105d51b85de31e6188"},"sys_mod_count":"31","sys_tags":"","alerts_component":"","props":"{\"recenterThresholdPercentage\": 100, \"additionalNodeProps\": [], \"additionalEdgeProps\": [],\"retainNodeEdgePositions\":true,\"retainGroupExpansions\":true}","layout":" function getLayout($, go) {\n    return $(go.GridLayout);\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/1cf7ad026abf3abab12e761ddaa6e9df","value":"1cf7ad026abf3abab12e761ddaa6e9df"},"sys_update_name":"sn_diagram_builder_configuration_161dd439c38a3d10b09bb4cdb840dd6c","left_panel":"true","enable_dragging":"false","name":"Sample Grid Layout Configuration","header":"true","left_component":"","sys_policy":""},{"diagram_options":"function getDiagramOptions($, go, dispatch, uuidv4, resolveThemeVariable) {\n    return {\n        allowDelete: false,\n        initialDocumentSpot: go.Spot.Top,\n        initialViewportSpot: go.Spot.Top,\n        maxSelectionCount: 1,\n        'toolManager.gestureBehavior': go.ToolManager.GestureZoom,\n        'toolManager.hoverDelay': 300,\n        'relinkingTool.linkValidation': function(fromNode, fromPort, toNode) {\n            if (fromNode.containingGroup || toNode.containingGroup) {\n                return (fromNode.containingGroup && toNode.containingGroup && toNode.containingGroup.data.key === fromNode.containingGroup.data.key);\n            }\n            return true;\n        },\n        'draggingTool.dragsLink': true,\n        'undoManager.isEnabled': true,\n        'undoManager.maxHistoryLength': 0,\n        'contextMenuTool.canStart': function() {\n            if (this.diagram.lastInput.clickCount > 1) return false;\n            return go.ContextMenuTool.prototype.canStart.call(this);\n        },\n        'contextMenuTool.standardMouseClick': function() {\n            return false;\n        },\n        'draggingTool.isEnabled': true,\n        'animationManager.isEnabled': false,\n        contentAlignment: go.Spot.Center,\n        'draggingTool.doActivate': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_ACTIVATED');\n            go.DraggingTool.prototype.doActivate.call(this);\n        },\n        'draggingTool.doDeactivate': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_DEACTIVATED');\n            go.DraggingTool.prototype.doDeactivate.call(this);\n        },\n        'draggingTool.standardMouseSelect': function() {\n            go.DraggingTool.prototype.standardMouseSelect.call(this);\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_SELECTED');\n        },\n        'draggingTool.doMouseMove': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_MOVED');\n            go.DraggingTool.prototype.doMouseMove.call(this);\n        },\n        'draggingTool.doMouseUp': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_UP');\n            go.DraggingTool.prototype.doMouseUp.call(this);\n        },\n        ViewportBoundsChanged: function(event) {\n            dispatch('GO_DIAGRAM#VIEWPORT_BOUNDS_CHANGED', {\n                event: event\n            });\n        },\n        LinkDrawn: function(event) {\n            dispatch('GO_DIAGRAM#LINK_DRAWN', {\n                event: event\n            });\n        },\n        ChangedSelection: function(event) {\n            dispatch('GO_DIAGRAM#SELECTION_CHANGED', {\n                selection: event.subject.first()\n            });\n        },\n        ModelChanged: function(event) {\n            dispatch('GO_DIAGRAM#MODEL_CHANGED', {\n                event: event\n            });\n        },\n        BackgroundSingleClicked: function(event) {\n            dispatch('RIGHT_PANEL#BACKGROUND_SINGLE_CLICKED', {\n                event: event\n            });\n        },\n    };\n}","diagram_template":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_diagram_template/249bf1c453013110de44ddeeff7b12a4","value":"249bf1c453013110de44ddeeff7b12a4"},"advanced":"true","sys_updated_on":"2024-05-17 12:50:34","sys_class_name":"sn_diagram_builder_configuration","enable_search":"true","sys_id":"4175699653332110de44ddeeff7b1203","sys_updated_by":"admin","enable_animation":"false","sys_created_on":"2023-07-05 05:10:39","sys_name":"Sample Builder Configuration","right_component":"","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/1cf7ad026abf3abab12e761ddaa6e9df","value":"1cf7ad026abf3abab12e761ddaa6e9df"},"theme":"","enable_layout_customization":"false","sys_created_by":"admin","right_panel":"false","content_alignment":"Center","palette_configuration":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_palette_configuration/458a7065a33002105d51b85de31e6188","value":"458a7065a33002105d51b85de31e6188"},"sys_mod_count":"23","sys_tags":"","alerts_component":"","props":"{\"recenterThresholdPercentage\": 100, \"additionalNodeProps\": [], \"additionalEdgeProps\": []}","layout":"// You can either update the TreeLayout configuration or re-implement your own layout.    function getLayout($, go) {      return $(go.TreeLayout, {      angle: 90,      nodeSpacing: 100,      layerSpacing: 120,      alternateAngle: 90,      setsChildPortSpot: false,      setsPortSpot: false,     });}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/1cf7ad026abf3abab12e761ddaa6e9df","value":"1cf7ad026abf3abab12e761ddaa6e9df"},"sys_update_name":"sn_diagram_builder_configuration_4175699653332110de44ddeeff7b1203","left_panel":"false","enable_dragging":"false","name":"Sample Builder Configuration","header":"true","left_component":"","sys_policy":""},{"diagram_options":"function getDiagramOptions($, go, dispatch, uuidv4) {\n    var colorPrimary = \"#01778E\";\n    var colorPrimaryWithOpacity = \"rgba(1, 119, 142, 0.2)\";\n    var temporaryLinkCurviness = 30;\n\n    var temporaryLink = $(\n        go.Link, {\n            layerName: 'Tool',\n            curve: go.Link.Bezier,\n            curviness: temporaryLinkCurviness,\n        },\n        $(go.Shape, {\n            isPanelMain: true,\n            stroke: colorPrimaryWithOpacity,\n            strokeWidth: 16,\n        }),\n        $(go.Shape, {\n            isPanelMain: true,\n            stroke: colorPrimary,\n            strokeWidth: 2\n        }),\n        $(\n            go.Shape, // the arrowhead\n            {\n                toArrow: 'Standard',\n                fill: '#01778E',\n                stroke: null\n            }\n        )\n    );\n\n    function formInvisiblePort(from) {\n        return $(go.Shape, 'Circle', {\n            width: 0,\n            height: 0,\n            fill: null,\n            stroke: null,\n            segmentIndex: from ? 0 : -1,\n        });\n    }\n\n    return {\n        allowDelete: false,\n        initialDocumentSpot: go.Spot.Top,\n        initialViewportSpot: go.Spot.Top,\n        maxSelectionCount: 1,\n        'toolManager.gestureBehavior': go.ToolManager.GestureZoom,\n        'toolManager.hoverDelay': 300,\n        'undoManager.isEnabled': true,\n        'undoManager.maxHistoryLength': 0,\n        'contextMenuTool.canStart': function() {\n            if (this.diagram.lastInput.clickCount > 1) return false;\n            return go.ContextMenuTool.prototype.canStart.call(this);\n        },\n        'contextMenuTool.standardMouseClick': function() {\n            return false;\n        },\n\n        'relinkingTool.copyLinkProperties': function() {},\n        'relinkingTool.fromHandleArchetype': formInvisiblePort(true),\n        'relinkingTool.toHandleArchetype': formInvisiblePort(false),\n        'relinkingTool.temporaryLink': temporaryLink,\n        'relinkingTool.temporaryFromPort': formInvisiblePort(true),\n        'relinkingTool.temporaryToPort': formInvisiblePort(false),\n        'relinkingTool.setNoTargetPortProperties': function(\n            tempnode,\n            tempport,\n            toend\n        ) {\n            go.RelinkingTool.prototype.setNoTargetPortProperties.call(\n                this,\n                tempnode,\n                tempport,\n                toend\n            );\n            this.originalLink.opacity = 0;\n            this.originalLink.removeAdornment('Selection');\n        },\n        'relinkingTool.doDeactivate': function() {\n            this.originalLink.opacity = 1;\n            this.originalLink.clearAdornments();\n            this.originalLink.updateAdornments();\n            go.RelinkingTool.prototype.doDeactivate.call(this);\n        },\n        'linkingTool.temporaryLink': temporaryLink,\n        'linkingTool.temporaryFromPort': formInvisiblePort(true),\n        'linkingTool.temporaryToPort': formInvisiblePort(false),\n        'draggingTool.isEnabled': false,\n        'animationManager.isEnabled': true,\n        contentAlignment: go.Spot.Top,\n        'draggingTool.doActivate': function(event) {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_ACTIVATED');\n            go.DraggingTool.prototype.doActivate.call(this);\n        },\n        'draggingTool.doDeactivate': function(event) {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_DEACTIVATED');\n            go.DraggingTool.prototype.doDeactivate.call(this);\n        },\n        'draggingTool.standardMouseSelect': function(event) {\n            go.DraggingTool.prototype.standardMouseSelect.call(this);\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_SELECTED');\n        },\n        'draggingTool.doMouseMove': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_MOVED');\n            go.DraggingTool.prototype.doMouseMove.call(this);\n        },\n        'draggingTool.doMouseUp': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_UP');\n            go.DraggingTool.prototype.doMouseUp.call(this);\n        },\n        ViewportBoundsChanged: function(event) {\n            dispatch('GO_DIAGRAM#VIEWPORT_BOUNDS_CHANGED', {\n                event: event\n            });\n        },\n        LinkDrawn: function(event) {\n            dispatch('GO_DIAGRAM#LINK_DRAWN', {\n                event: event\n            });\n        },\n        ChangedSelection: function(event) {\n            dispatch('GO_DIAGRAM#SELECTION_CHANGED', {\n                selection: event.subject.first()\n            });\n        },\n        ModelChanged: function(event) {\n            dispatch('GO_DIAGRAM#MODEL_CHANGED', {\n                event: event\n            });\n        }\n    };\n}","diagram_template":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_diagram_template/01e215d1b7110110388487c2de11a9d4","value":"01e215d1b7110110388487c2de11a9d4"},"advanced":"false","sys_updated_on":"2025-06-11 10:10:07","sys_class_name":"sn_diagram_builder_configuration","enable_search":"false","sys_id":"7674b5bdb7d90110388487c2de11a957","sys_updated_by":"admin","enable_animation":"true","sys_created_on":"2022-01-27 18:06:42","sys_name":"Process Automation Designer with Swimlanes","right_component":"","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/1293c996ad48c7d88400c13afef3cdff","value":"1293c996ad48c7d88400c13afef3cdff"},"theme":"","enable_layout_customization":"true","sys_created_by":"admin","right_panel":"false","content_alignment":"Top","palette_configuration":"","sys_mod_count":"95","sys_tags":"","alerts_component":"","props":"","layout":"function getPDLayout($, go) {\n\n    var COLUMN_SPACING = 10;\n    var BOX_HEIGHT = 102;\n    var LAYER_SPACING = 25;\n    var PADDING = 10;\n    var MINIMUM_LANE_HEIGHT = 254;\n\t\n\tvar BRANCH_NODE_ID = '3c6e53f253421110d67cddeeff7b12ff';\n\n    function SwimLaneLayout() {\n        go.LayeredDigraphLayout.call(this);\n\n        // settable properties\n        this._laneProperty = \"lane\"; // how to get lane identifier string from node data\n        this._laneNames = [];\n        this._laneComparer = null;\n        this._laneSpacing = 0; // in columns\n\n        this._router = {\n            linkSpacing: 4\n        };\n        this._reducer = null;\n\n        // computed, read-only state\n        this.lanePositions = new go.Map(); // lane names --> start columns, left to right\n        this.laneBreadths = new go.Map(); // lane names --> needed width in columns\n\n        // internal state\n        this._layers = null;\n        this._neededSpaces = null;\n    }\n    go.Diagram.inherit(SwimLaneLayout, go.LayeredDigraphLayout);\n\n    Object.defineProperty(SwimLaneLayout.prototype, \"laneProperty\", {\n        get: function() {\n            return this._laneProperty;\n        },\n        set: function(val) {\n            if (typeof val !== 'string' && typeof val !== 'function') throw new Error(\"new value for SwimLaneLayout.laneProperty must be a property name, not: \" + val);\n            if (this._laneProperty !== val) {\n                this._laneProperty = val;\n                this.invalidateLayout();\n            }\n        }\n    });\n\n    Object.defineProperty(SwimLaneLayout.prototype, \"laneNames\", {\n        get: function() {\n            return this._laneNames;\n        },\n        set: function(val) {\n            if (!Array.isArray(val)) throw new Error(\"new value for SwimLaneLayout.laneNames must be an Array, not: \" + val);\n            if (this._laneNames !== val) {\n                this._laneNames = val;\n                this.invalidateLayout();\n            }\n        }\n    });\n\n    Object.defineProperty(SwimLaneLayout.prototype, \"laneComparer\", {\n        get: function() {\n            return this._laneComparer;\n        },\n        set: function(val) {\n            if (typeof val !== 'function') throw new Error(\"new value for SwimLaneLayout.laneComparer must be a function, not: \" + val);\n            if (this._laneComparer !== val) {\n                this._laneComparer = val;\n                this.invalidateLayout();\n            }\n        }\n    });\n\n    Object.defineProperty(SwimLaneLayout.prototype, \"laneSpacing\", { // unit is columns, not in document coordinates\n        get: function() {\n            return this._laneSpacing;\n        },\n        set: function(val) {\n            if (typeof val !== 'number') throw new Error(\"new value for SwimLaneLayout.laneSpacing must be a number, not: \" + val);\n            if (this._laneSpacing !== val) {\n                this._laneSpacing = val;\n                this.invalidateLayout();\n            }\n        }\n    });\n\n    Object.defineProperty(SwimLaneLayout.prototype, \"router\", {\n        get: function() {\n            return this._router;\n        },\n        set: function(val) {\n            if (this._router !== val) {\n                this._router = val;\n                this.invalidateLayout();\n            }\n        }\n    });\n\n    Object.defineProperty(SwimLaneLayout.prototype, \"reducer\", {\n        get: function() {\n            return this._reducer;\n        },\n        set: function(val) {\n            if (this._reducer !== val) {\n                this._reducer = val;\n\n                if (val) {\n                    var lay = this;\n                    val.findLane = function(v) {\n                        return lay.getLane(v);\n                    }\n                    val.getIndex = function(v) {\n                        return v.index;\n                    }\n                    val.getBary = function(v) {\n                        return v.bary || 0;\n                    }\n                    val.setBary = function(v, val) {\n                        v.bary = val;\n                    }\n                    val.getConnectedNodesIterator = function(v) {\n                        return v.vertexes;\n                    }\n                }\n\n                this.invalidateLayout();\n            }\n        }\n    });\n\n    SwimLaneLayout.prototype.doLayout = function(coll) {\n        this.lanePositions.clear(); // lane names --> start columns, left to right\n        this.laneBreadths.clear(); // lane names --> needed width in columns\n        this._layers = null;\n        this._neededSpaces = null;\n        go.LayeredDigraphLayout.prototype.doLayout.call(this, coll);\n        this.lanePositions.clear();\n        this.laneBreadths.clear();\n        this._layers = null;\n        this._neededSpaces = null;\n        this.laneNames = []; // clear out for next layout\n    }\n\n    SwimLaneLayout.prototype.nodeMinLayerSpace = function(v, topleft) {\n        if (!this._neededSpaces) this._neededSpaces = this.computeNeededLayerSpaces(this.network);\n        if (v.node === null) return 0;\n        var lay = v.layer;\n        if (!topleft) {\n            if (lay > 0) lay--;\n        }\n        var overlaps = (this._neededSpaces[lay] || 0) / 2;\n        var edges = this.countEdgesForDirection(v, (this.direction > 135) ? !topleft : topleft);\n        var needed = Math.max(overlaps, edges) * this.router.linkSpacing * 1.5;\n        if (this.direction === 90 || this.direction === 270) {\n            if (topleft) {\n                return v.focus.y + 10 + needed;\n            } else {\n                return v.bounds.height - v.focus.y + 10 + needed;\n            }\n        } else {\n            if (topleft) {\n                return v.focus.x + 10 + needed;\n            } else {\n                return v.bounds.width - v.focus.x + 10 + needed;\n            }\n        }\n    }\n\n    SwimLaneLayout.prototype.countEdgesForDirection = function(vertex, topleft) {\n        var c = 0;\n        var lay = vertex.layer;\n        vertex.edges.each(function(e) {\n            if (topleft) {\n                if (e.getOtherVertex(vertex).layer >= lay) c++;\n            } else {\n                if (e.getOtherVertex(vertex).layer <= lay) c++;\n            }\n        });\n        return c;\n    }\n\n    SwimLaneLayout.prototype.computeNeededLayerSpaces = function(net) {\n        // group all edges by their connected vertexes' least layer\n        var layerMinEdges = [];\n        net.edges.each(function(e) {\n            // consider all edges, including dummy ones!\n            var f = e.fromVertex;\n            var t = e.toVertex;\n            if (f.column === t.column) return; // skip edges that don't go between columns\n            if (Math.abs(f.layer - t.layer) > 1) return; // skip edges that don't go between adjacent layers\n            var lay = Math.min(f.layer, t.layer);\n            var arr = layerMinEdges[lay];\n            if (!arr) arr = layerMinEdges[lay] = [];\n            arr.push(e);\n        });\n        // sort each array of edges by their lowest connected vertex column\n        // for edges with the same minimum column, sort by their maximum column\n        var layerMaxEdges = []; // same as layerMinEdges, but sorted by maximum column\n        layerMinEdges.forEach(function(arr, lay) {\n            if (!arr) return;\n            arr.sort(function(e1, e2) {\n                var f1c = e1.fromVertex.column;\n                var t1c = e1.toVertex.column;\n                var f2c = e2.fromVertex.column;\n                var t2c = e2.toVertex.column;\n                var e1mincol = Math.min(f1c, t1c);\n                var e2mincol = Math.min(f2c, t2c);\n                if (e1mincol > e2mincol) return 1;\n                if (e1mincol < e2mincol) return -1;\n                var e1maxcol = Math.max(f1c, t1c);\n                var e2maxcol = Math.max(f2c, t2c);\n                if (e1maxcol > e2maxcol) return 1;\n                if (e1maxcol < e2maxcol) return -1;\n                return 0;\n            });\n            layerMaxEdges[lay] = arr.slice(0);\n            layerMaxEdges[lay].sort(function(e1, e2) {\n                var f1c = e1.fromVertex.column;\n                var t1c = e1.toVertex.column;\n                var f2c = e2.fromVertex.column;\n                var t2c = e2.toVertex.column;\n                var e1maxcol = Math.max(f1c, t1c);\n                var e2maxcol = Math.max(f2c, t2c);\n                if (e1maxcol > e2maxcol) return 1;\n                if (e1maxcol < e2maxcol) return -1;\n                var e1mincol = Math.min(f1c, t1c);\n                var e2mincol = Math.min(f2c, t2c);\n                if (e1mincol > e2mincol) return 1;\n                if (e1mincol < e2mincol) return -1;\n                return 0;\n            });\n        });\n\n        // run through each array of edges to count how many overlaps there might be\n        var layerOverlaps = [];\n        layerMinEdges.forEach(function(arr, lay) {\n            var mins = arr; // sorted by min column\n            var maxs = layerMaxEdges[lay]; // sorted by max column\n            var maxoverlap = 0; // maximum count for this layer\n            if (mins && maxs && mins.length > 1 && maxs.length > 1) {\n                var mini = 0;\n                var min = null;\n                var maxi = 0;\n                var max = null;\n                while (mini < mins.length || maxi < maxs.length) {\n                    if (mini < mins.length) min = mins[mini];\n                    var mincol = min ? Math.min(min.fromVertex.column, min.toVertex.column) : 0;\n                    if (maxi < maxs.length) max = maxs[maxi];\n                    var maxcol = max ? Math.max(max.fromVertex.column, max.toVertex.column) : Infinity;\n                    maxoverlap = Math.max(maxoverlap, Math.abs(mini - maxi));\n                    if (mincol <= maxcol && mini < mins.length) {\n                        mini++;\n                    } else if (maxi < maxs.length) {\n                        maxi++;\n                    }\n                }\n            }\n            layerOverlaps[lay] = maxoverlap * 1.5; // # of parallel links\n        });\n        return layerOverlaps;\n    }\n\n    SwimLaneLayout.prototype.setupLanes = function() {\n        // set up some data structures\n        var layout = this;\n        var laneNameSet = new go.Set().addAll(this.laneNames);\n        var laneIndexes = new go.Map(); // lane names --> index when sorted\n        var layers = [];\n        this._layers = layers;\n\n        var vit = this.network.vertexes.iterator;\n        while (vit.next()) {\n            var v = vit.value;\n\n            var lane = this.getLane(v); // cannot call findLane yet\n            if (lane !== null && !laneNameSet.has(lane)) {\n                laneNameSet.add(lane);\n                this.laneNames.push(lane);\n            }\n\n            var layer = v.layer;\n            if (layer >= 0) {\n                var arr = layers[layer];\n                if (!arr) {\n                    layers[layer] = [v];\n                } else {\n                    arr.push(v);\n                }\n            }\n        }\n\n        // sort laneNames and initialize laneIndexes\n        if (typeof laneComparer === \"function\") this.laneNames.sort(laneComparer);\n        for (var i = 0; i < this.laneNames.length; i++) {\n            laneIndexes.add(this.laneNames[i], i);\n        }\n        // now OK to call findLane\n\n        // sort vertexes so that vertexes are grouped by lane\n        for (var i = 0; i <= this.maxLayer; i++) {\n            layers[i].sort(function(a, b) {\n                return layout.compareVertexes(a, b);\n            });\n        }\n    }\n\n    /**\n     * Replace the standard reduceCrossings behavior so that it respects lanes.\n     */\n    SwimLaneLayout.prototype.reduceCrossings = function() {\n        this.setupLanes();\n\n        // this just cares about the .index and ignores .column\n        var layers = this._layers;\n        var red = this.reducer;\n        if (red) {\n            for (var i = 0; i < layers.length - 1; i++) {\n                red.reduceCrossings(layers[i], layers[i + 1]);\n                layers[i].forEach(function(v, j) {\n                    v.index = j;\n                })\n            }\n            for (var i = layers.length - 1; i > 0; i--) {\n                red.reduceCrossings(layers[i], layers[i - 1]);\n                layers[i].forEach(function(v, j) {\n                    v.index = j;\n                })\n            }\n        }\n\n        this.computeLanes(); // and recompute all vertex.column values\n    }\n\n    SwimLaneLayout.prototype.computeLanes = function() {\n        // compute needed width for each lane, in columns\n        for (var i = 0; i < this.laneNames.length; i++) {\n            var lane = this.laneNames[i];\n            this.laneBreadths.add(lane, this.computeMinLaneWidth(lane));\n        }\n        var lwidths = new go.Map(); // reused for each layer\n        for (var i = 0; i <= this.maxLayer; i++) {\n            var arr = this._layers[i];\n            if (arr) {\n                var layout = this;\n                // now run through Array finding width (in columns) of each lane\n                // and max with this.laneBreadths.get(lane)\n                for (var j = 0; j < arr.length; j++) {\n                    var v = arr[j];\n                    var w = this.nodeMinColumnSpace(v, true) + 1 + this.nodeMinColumnSpace(v, false);\n                    var ln = this.findLane(v);\n                    var totw = lwidths.get(ln)\n                    if (totw === null) {\n                        lwidths.set(ln, w);\n                    } else {\n                        lwidths.set(ln, totw + w);\n                    }\n                }\n                lwidths.each(function(kvp) {\n                    var lane = kvp.key;\n                    var colsInLayer = kvp.value;\n                    var colsMax = layout.laneBreadths.get(lane);\n                    if (colsInLayer > colsMax) layout.laneBreadths.set(lane, colsInLayer);\n                })\n                lwidths.clear();\n            }\n        }\n\n        // compute starting positions for each lane\n        var x = 0;\n        for (var i = 0; i < this.laneNames.length; i++) {\n            var lane = this.laneNames[i];\n            this.lanePositions.set(lane, x);\n            var w = this.laneBreadths.get(lane);\n            x += w + this.laneSpacing;\n        }\n\n        this.renormalizeColumns();\n    }\n\n    SwimLaneLayout.prototype.renormalizeColumns = function() {\n        // set new column and index on each vertex\n        for (var i = 0; i < this._layers.length; i++) {\n            var prevlane = null;\n            var c = 0;\n            var arr = this._layers[i];\n            for (var j = 0; j < arr.length; j++) {\n                var v = arr[j];\n                v.index = j;\n\n                var l = this.findLane(v);\n                if (prevlane !== l) {\n                    c = this.lanePositions.get(l);\n                    var w = this.laneBreadths.get(l);\n                    // compute needed breadth within lane, in columns\n                    var z = this.nodeMinColumnSpace(v, true) + 1 + this.nodeMinColumnSpace(v, false);\n                    var k = j + 1;\n                    while (k < arr.length && this.findLane(arr[k]) === l) {\n                        var vz = arr[k];\n                        z += this.nodeMinColumnSpace(vz, true) + 1 + this.nodeMinColumnSpace(vz, false);\n                        k++;\n                    }\n                    // if there is extra space, shift the vertexes to the middle of the lane\n                    if (z < w) {\n                        c += Math.floor((w - z) / 2);\n                    }\n                }\n\n                c += this.nodeMinColumnSpace(v, true);\n                v.column = c;\n                c += 1;\n                c += this.nodeMinColumnSpace(v, false);\n                prevlane = l;\n            }\n        }\n    }\n\n    /**\n     * Return the minimum lane width, in columns\n     * @param lane \n     */\n    SwimLaneLayout.prototype.computeMinLaneWidth = function(lane) {\n        return 0;\n    }\n\n    /**\n     * Disable normal straightenAndPack behavior, which would mess up the columns.\n     */\n    SwimLaneLayout.prototype.straightenAndPack = function() {}\n\n    /**\n     * Given a vertex, get the lane (name) that its node belongs in.\n     * If the lane appears to be undefined, this returns the empty string.\n     * For dummy vertexes (with no node) this will return null.\n     * @param v\n     */\n    SwimLaneLayout.prototype.getLane = function(v) {\n        if (v === null) return null;\n        var node = v.node;\n        if (node !== null) {\n            var data = node.data;\n            if (data !== null) {\n                var lane = null;\n                if (typeof this.laneProperty === \"function\") {\n                    lane = this.laneProperty(data);\n                } else {\n                    lane = data[this.laneProperty];\n                }\n                if (typeof lane === \"string\") return lane;\n                return \"\";\n            }\n        }\n        return null;\n    }\n\n    /**\n     * This is just like {@link #getLane} but handles dummy vertexes\n     * for which the {@link #getLane} returns null by returning the\n     * lane of the edge's source or destination vertex.\n     * This can only be called after the lanes have been set up internally.\n     * @param v\n     */\n    SwimLaneLayout.prototype.findLane = function(v) {\n        if (v !== null) {\n            var lane = this.getLane(v);\n            if (lane !== null) {\n                return lane;\n            } else {\n                var srcv = this.findRealSource(v.sourceEdges.first());\n                var dstv = this.findRealDestination(v.destinationEdges.first());\n                var srcLane = this.getLane(srcv);\n                var dstLane = this.getLane(dstv);\n                if (srcLane !== null || dstLane !== null) {\n                    if (srcLane === dstLane) return srcLane;\n                    if (srcLane !== null) return srcLane;\n                    if (dstLane !== null) return dstLane;\n                }\n            }\n        }\n        return null;\n    }\n\n    SwimLaneLayout.prototype.findRealSource = function(e) {\n        if (e === null) return null;\n        if (e.fromVertex.node) return e.fromVertex;\n        return this.findRealSource(e.fromVertex.sourceEdges.first());\n    }\n\n    SwimLaneLayout.prototype.findRealDestination = function(e) {\n        if (e === null) return null;\n        if (e.toVertex.node) return e.toVertex;\n        return this.findRealDestination(e.toVertex.destinationEdges.first());\n    }\n\n    SwimLaneLayout.prototype.compareVertexes = function(v, w) {\n        var laneV = this.findLane(v);\n        if (laneV === null) laneV = \"\";\n        var laneW = this.findLane(w);\n        if (laneW === null) laneW = \"\";\n        if (laneV < laneW) return -1;\n        if (laneV > laneW) return 1;\n        return 0;\n    };\n\n    function PDLayout() {\n        SwimLaneLayout.call(this);\n    }\n\n    go.Diagram.inherit(PDLayout, SwimLaneLayout);\n\n    PDLayout.prototype.doLayout = function(coll) {\n        var laneNames = coll.layout.laneNames;\n        this.laneNames = laneNames;\n        SwimLaneLayout.prototype.doLayout.call(this, coll);\n        this.laneNames = laneNames;\n    }\n\n    PDLayout.prototype.arrange = function() {\n        var laneNames = this.laneNames;\n        var nodeOrder = new Map();\n\n        var getFirstIncomingNode = function(node, nodeOrder) {\n            var key;\n\n            node.findLinksInto().each(function(link) {\n                var fromKey;\n\t\t\t\tif (link.fromNode && link.fromNode.data) {\n\t\t\t\t\tfromKey = link.fromNode.data.key;\n\t\t\t\t\tif (fromKey && (!key || nodeOrder.get(key) > nodeOrder.get(fromKey))) {\n\t\t\t\t\t\tkey = fromKey;\n\t\t\t\t\t}\n\t\t\t\t}\n            });\n\n            return key;\n        }\n\n        for (var i = this._layers.length - 1; i >= 0; i--) {\n            var arr = this._layers[i];\n            arr.sort(function(v1, v2) {\n                var n1 = v1.node;\n                var n2 = v2.node;\n                if (!n1 || !n2) {\n                    // v1 and v2 can be the \"connector part\" on link\n                    return 0;\n                }\n                // first by group\n                var group1 = n1.data.group;\n                var group2 = n2.data.group;\n                if (group1 !== group2) {\n                    var groupIndex1 = laneNames.indexOf(group1);\n                    var groupIndex2 = laneNames.indexOf(group2);\n                    return groupIndex1 - groupIndex2;\n                }\n\n                // then by the branch order from the same decision\n                var decisionKey1 =\n                    n1.data.node_id === BRANCH_NODE_ID ? n1.data.key.split(\".\")[0] : undefined;\n                var decisionKey2 =\n                    n2.data.node_id === BRANCH_NODE_ID ? n2.data.key.split(\".\")[0] : undefined;\n                if (decisionKey1 && decisionKey1 === decisionKey2) {\n                    return n1.data.order - n2.data.order;\n                }\n\n                // then by the incoming node\n                var firstIncomingNodeKey1 = getFirstIncomingNode(n1, nodeOrder);\n                var firstIncomingNodeKey2 = getFirstIncomingNode(n2, nodeOrder);\n\n                if (firstIncomingNodeKey1 && firstIncomingNodeKey2) {\n                    return (\n                        nodeOrder.get(firstIncomingNodeKey1) -\n                        nodeOrder.get(firstIncomingNodeKey2)\n                    );\n                } else {\n                    return 0;\n                }\n            });\n            arr.forEach(function(v) {\n                var dKey = v.node ? v.node.data.key : null;\n                if (dKey && !nodeOrder.dKey) {\n                    nodeOrder.set(dKey, nodeOrder.size + 1);\n                }\n            });\n        }\n    };\n\n    PDLayout.prototype.computeLanes = function() {\n        this.arrange();\n        SwimLaneLayout.prototype.computeLanes.call(this);\n    }\n\n    PDLayout.prototype.commitLayers = function(layerRects, offset) {\n        if (layerRects.length === 0) return;\n\n        var laneNames = this.diagram.layout.laneNames;\n        var diagram = this.diagram;\n        this.network.vertexes.each(function(v) {\n            if (v && v.node) {\n                var layer = v.layer;\n                diagram.model.setDataProperty(v.node.data, \"layer\", layer);\n            }\n        });\n\n        // Required for handling mouse down events (by using mouseHold with a delay of 0)\n        diagram.toolManager.holdDelay = 0;\n\n        var rect = layerRects[layerRects.length - 1];\n        var viewWidth = this.diagram.viewportBounds.width;\n        var totallength = Math.max(rect.right, viewWidth);\n\n        for (var i = 0; i < laneNames.length; i++) {\n            var lane = laneNames[i];\n            // assume lane names do not conflict with node names\n            var group = this.diagram.findNodeForKey(lane);\n            if (group === null) {\n                this.diagram.model.addNodeData({\n                    key: lane,\n                    isGroup: true,\n                });\n                group = this.diagram.findNodeForKey(lane);\n            }\n            group.location = new go.Point(\n                -PADDING,\n                this.lanePositions.get(lane) * this.columnSpacing + offset.y\n            );\n            var ph = group.findObject(\"PLACEHOLDER\"); // won't be a go.Placeholder, but just a regular Shape\n            if (ph) {\n                ph.desiredSize = new go.Size(\n                    totallength,\n                    this.laneBreadths.get(lane) * this.columnSpacing\n                );\n            }\n        }\n    }\n\n    PDLayout.prototype.computeMinLaneWidth = function(lane) {\n        return MINIMUM_LANE_HEIGHT / COLUMN_SPACING;\n    }\n\n    return $(PDLayout, {\n        layeringOption: go.LayeredDigraphLayout.LayerLongestPathSource,\n        packOption: go.LayeredDigraphLayout.PackStraighten,\n        aggressiveOption: go.LayeredDigraphLayout.AggressiveNone,\n        laneProperty: \"group\",\n        layerSpacing: LAYER_SPACING,\n        columnSpacing: COLUMN_SPACING,\n        linkSpacing: 20\n    })\n\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/1293c996ad48c7d88400c13afef3cdff","value":"1293c996ad48c7d88400c13afef3cdff"},"sys_update_name":"sn_diagram_builder_configuration_7674b5bdb7d90110388487c2de11a957","left_panel":"false","enable_dragging":"true","name":"Process Automation Designer with Swimlanes","header":"false","left_component":"","sys_policy":"read"},{"diagram_options":"function getDiagramOptions($, go, dispatch, uuidv4, resolveThemeVariable) {\n    // consistent with process-designer-configuration.constants.js's ENABLE_FEATURES.STAGES\n    var PROCESS_TYPE_CONFIGURATION_ENABLE_FEATURES_STAGES = 'stages';\n    // configuration doesn't have access to shared defineShapeTemplateFeatures\n    var PROCESS_TYPE_CONFIGURATION_PAD_MODE = '_padMode';\n\n    var COLOR_CSS_NAME = \"--now-color--primary-1\";\n    var colorPrimary1 = resolveThemeVariable(COLOR_CSS_NAME);\n    var colorPrimary1WithOpacity = \"rgba(\" + resolveThemeVariable(COLOR_CSS_NAME, false) + \", 0.2)\";\n    var temporaryLinkCurviness = 30;\n\n    var temporaryLink = $(\n        go.Link, {\n            layerName: 'Tool',\n            curve: go.Link.Bezier,\n            curviness: temporaryLinkCurviness,\n        },\n        $(go.Shape, {\n            isPanelMain: true,\n            stroke: colorPrimary1WithOpacity,\n            strokeWidth: 16,\n        }),\n        $(go.Shape, {\n            isPanelMain: true,\n            stroke: colorPrimary1,\n            strokeWidth: 2\n        }),\n        $(\n            go.Shape, // the arrowhead\n            {\n                toArrow: 'Triangle',\n                fill: colorPrimary1,\n                stroke: null\n            }\n        )\n    );\n\n    function formInvisiblePort(from) {\n        return $(go.Shape, 'Circle', {\n            width: 0,\n            height: 0,\n            fill: null,\n            stroke: null,\n            segmentIndex: from ? 0 : -1,\n        });\n    }\n\n    return {\n        allowDelete: false,\n        initialDocumentSpot: go.Spot.Top,\n        initialViewportSpot: go.Spot.Top,\n        maxSelectionCount: 1,\n        'toolManager.gestureBehavior': go.ToolManager.GestureZoom,\n        'toolManager.hoverDelay': 300,\n        'draggingTool.dragsLink': false,\n        'undoManager.isEnabled': true,\n        'undoManager.maxHistoryLength': 0,\n        'contextMenuTool.canStart': function() {\n            if (this.diagram.lastInput.clickCount > 1) return false;\n            return go.ContextMenuTool.prototype.canStart.call(this);\n        },\n        'contextMenuTool.standardMouseClick': function() {\n            return false;\n        },\n\n        'relinkingTool.copyLinkProperties': function() {},\n        'relinkingTool.fromHandleArchetype': formInvisiblePort(true),\n        'relinkingTool.toHandleArchetype': formInvisiblePort(false),\n        'relinkingTool.temporaryLink': temporaryLink,\n        'relinkingTool.temporaryFromPort': formInvisiblePort(true),\n        'relinkingTool.temporaryToPort': formInvisiblePort(false),\n        'relinkingTool.setNoTargetPortProperties': function(\n            tempnode,\n            tempport,\n            toend\n        ) {\n            go.RelinkingTool.prototype.setNoTargetPortProperties.call(\n                this,\n                tempnode,\n                tempport,\n                toend\n            );\n            this.originalLink.opacity = 0;\n            this.originalLink.removeAdornment('Selection');\n        },\n        'relinkingTool.doDeactivate': function() {\n            this.originalLink.opacity = 1;\n            this.originalLink.clearAdornments();\n            this.originalLink.updateAdornments();\n            go.RelinkingTool.prototype.doDeactivate.call(this);\n        },\n        'linkingTool.temporaryLink': temporaryLink,\n        'linkingTool.temporaryFromPort': formInvisiblePort(true),\n        'linkingTool.temporaryToPort': formInvisiblePort(false),\n        'draggingTool.isEnabled': false,\n        'animationManager.isEnabled': true,\n        contentAlignment: go.Spot.Left,\n        'draggingTool.doActivate': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_ACTIVATED');\n            go.DraggingTool.prototype.doActivate.call(this);\n        },\n        'draggingTool.doDeactivate': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_DEACTIVATED');\n            go.DraggingTool.prototype.doDeactivate.call(this);\n        },\n        'draggingTool.standardMouseSelect': function() {\n            go.DraggingTool.prototype.standardMouseSelect.call(this);\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_SELECTED');\n        },\n        'draggingTool.doMouseMove': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_MOVED');\n            go.DraggingTool.prototype.doMouseMove.call(this);\n        },\n        'draggingTool.doMouseUp': function() {\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_UP');\n            go.DraggingTool.prototype.doMouseUp.call(this);\n        },\n        ViewportBoundsChanged: function(event) {\n            dispatch('GO_DIAGRAM#VIEWPORT_BOUNDS_CHANGED', {\n                event: event\n            });\n        },\n        LinkDrawn: function(event) {\n            dispatch('GO_DIAGRAM#LINK_DRAWN', {\n                event: event\n            });\n        },\n        ChangedSelection: function(event) {\n            if (!event.diagram.model.modelData[PROCESS_TYPE_CONFIGURATION_ENABLE_FEATURES_STAGES] && event.subject.first() && event.subject.first().data.isGroup)\n                return;\n            if (event.diagram.model.modelData[PROCESS_TYPE_CONFIGURATION_PAD_MODE] && event.diagram.model.modelData[PROCESS_TYPE_CONFIGURATION_PAD_MODE] !== 'edit')\n                return;\n\n            dispatch('GO_DIAGRAM#SELECTION_CHANGED', {\n                selection: event.subject.first()\n            });\n        },\n        ModelChanged: function(event) {\n            dispatch('GO_DIAGRAM#MODEL_CHANGED', {\n                event: event\n            });\n        },\n        BackgroundSingleClicked: function(event) {\n            if (event.diagram.model.modelData[PROCESS_TYPE_CONFIGURATION_PAD_MODE] && event.diagram.model.modelData[PROCESS_TYPE_CONFIGURATION_PAD_MODE] !== 'edit')\n                return;\n\n            dispatch('PAD#DIAGRAM_CLICK_BACKGROUND');\n        },\n        BackgroundDoubleClicked: function(event) {\n            dispatch('PAD#DIAGRAM_CLICK_BACKGROUND');\n        }\n    };\n}","diagram_template":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_diagram_template/01e215d1b7110110388487c2de11a9d4","value":"01e215d1b7110110388487c2de11a9d4"},"advanced":"true","sys_updated_on":"2024-06-11 10:08:06","sys_class_name":"sn_diagram_builder_configuration","enable_search":"false","sys_id":"e4f2d12d43ff5510496ae653dbb8f29e","sys_updated_by":"admin","enable_animation":"true","sys_created_on":"2022-12-15 23:42:57","sys_name":"Process Automation Designer","right_component":"","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/1293c996ad48c7d88400c13afef3cdff","value":"1293c996ad48c7d88400c13afef3cdff"},"theme":"","enable_layout_customization":"true","sys_created_by":"admin","right_panel":"false","content_alignment":"Top","palette_configuration":"","sys_mod_count":"17","sys_tags":"","alerts_component":"","props":"{\"recenterThresholdPercentage\": 70, \"additionalNodeProps\": [], \"additionalEdgeProps\": []}","layout":"function getPDLayout($, go) {\n    function AlignedLayeredDigraphVertex(net) {\n        go.LayeredDigraphVertex.call(this, net);\n    }\n    go.Diagram.inherit(AlignedLayeredDigraphVertex, go.LayeredDigraphVertex);\n    AlignedLayeredDigraphVertex.prototype.commit = function() {\n        var node = this.node;\n        if (node !== null) {\n            node.move(this.bounds.position);\n        }\n    }\n\n    function AlignedLayeredDigraphNetwork(lay) {\n        go.LayeredDigraphNetwork.call(this, lay);\n    }\n    go.Diagram.inherit(AlignedLayeredDigraphNetwork, go.LayeredDigraphNetwork);\n    AlignedLayeredDigraphNetwork.prototype.createVertex = function() {\n        return new AlignedLayeredDigraphVertex(this);\n    }\n\n    function AlignedLayeredDigraphLayout() {\n        go.LayeredDigraphLayout.call(this);\n    }\n    go.Diagram.inherit(AlignedLayeredDigraphLayout, go.LayeredDigraphLayout);\n    AlignedLayeredDigraphLayout.prototype.createNetwork = function() {\n        return new AlignedLayeredDigraphNetwork(this);\n    }\n    AlignedLayeredDigraphLayout.prototype.assignLayers = function() {\n        go.LayeredDigraphLayout.prototype.assignLayers.call(this);\n\n        // for every vertex, record the maximum vertex width or height for the vertex's layer\n        var maxsizes = [];\n        for (var it = this.network.vertexes.iterator; it.next();) {\n            var v = it.value;\n            var lay = v.layer;\n            var max = maxsizes[lay];\n            if (max === undefined) max = 0;\n            var sz = v.width;\n            if (sz > max) maxsizes[lay] = sz;\n        }\n        // now make sure every vertex has the maximum width or height according to which layer it is in,\n        // and aligned on the left (if horizontal) or the top (if vertical)\n        for (it = this.network.vertexes.iterator; it.next();) {\n            var v = it.value;\n            var node = v.node;\n            if (node === null) continue;\n            var lay = v.layer;\n            var max = maxsizes[lay];\n            v.focus = new go.Point(max / 2, v.focus.y);\n            v.width = max;\n        }\n        // from now on, the LayeredDigraphLayout will think that the Node is bigger than it really is\n        // (other than the ones that are the widest or tallest in their respective layer).\n    }\n\n    AlignedLayeredDigraphLayout.prototype.commitLinks = function() {\n        go.LayeredDigraphLayout.prototype.commitLinks.call(this);\n        this.network.edges.each((e) => {\n            var l = e.link;\n            if (!l) return;\n\n            l.updateRoute();\n            var pts = l.points.copy();\n            if (pts.count >= 6) {\n                var p2 = pts.elt(pts.length - 4);\n                var p3 = pts.elt(pts.length - 3);\n\n                var nodeX = l.toNode.position.x;\n                var x = nodeX - 25;\n                pts.setElt(pts.length - 4, new go.Point(x, p2.y));\n                pts.setElt(pts.length - 3, new go.Point(x, p3.y));\n                l.points = pts;\n            }\n        });\n    }\n\n    // https://forum.nwoods.com/t/align-groups-with-different-widths-in-layereddigraphlayout/16066\n    // GoJS forum suggested to use the custom AlignedLayeredDigraphLayout\n    // https://gojs.net/extras/AlignedLayeredDigraphLayout.html\n    return $(AlignedLayeredDigraphLayout, {\n        layerSpacing: 50,\n        linkSpacing: 20,\n        layeringOption: go.LayeredDigraphLayout.LayerLongestPathSource,\n        alignOption: go.LayeredDigraphLayout.AlignAll,\n    });\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/1293c996ad48c7d88400c13afef3cdff","value":"1293c996ad48c7d88400c13afef3cdff"},"sys_update_name":"sn_diagram_builder_configuration_e4f2d12d43ff5510496ae653dbb8f29e","left_panel":"false","enable_dragging":"true","name":"Process Automation Designer","header":"false","left_component":"","sys_policy":"read"},{"diagram_options":"function getDiagramOptions($, go, dispatch, uuidv4) {\n    return {\n        contentAlignment: go.Spot.Center,\n        'draggingTool.isEnabled': false,\n        'animationManager.isEnabled': false,\n        allowDelete: false,\n        initialDocumentSpot: go.Spot.Top,\n        initialViewportSpot: go.Spot.Top,\n        maxSelectionCount: 1,\n        'toolManager.gestureBehavior': go.ToolManager.GestureZoom,\n        'toolManager.hoverDelay': 300,\n        'relinkingTool.linkValidation': function(fromNode, fromPort, toNode) {\n            if (fromNode.containingGroup || toNode.containingGroup) {\n                return (fromNode.containingGroup && toNode.containingGroup && toNode.containingGroup.data.key === fromNode.containingGroup.data.key);\n            }\n            return true;\n        },\n        'draggingTool.dragsLink': false,\n        'undoManager.isEnabled': true,\n        'undoManager.maxHistoryLength': 0,\n        'contextMenuTool.canStart': function() {\n            if (this.diagram.lastInput.clickCount > 1) return false;\n            return go.ContextMenuTool.prototype.canStart.call(this);\n        },\n        'contextMenuTool.standardMouseClick': function() {\n            return false;\n        },\n        'draggingTool.doActivate': function() { // To write custom logic when dragging gets started\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_ACTIVATED', {\n                draggingTool: this\n            });\n        },\n        'draggingTool.doDeactivate': function() { // To write custom logic when dragging gets stopped\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_DEACTIVATED', {\n                draggingTool: this\n            });\n        },\n        'draggingTool.standardMouseSelect': function() { // To write custom logic when mouse selection done while dragging\n            go.DraggingTool.prototype.standardMouseSelect.call(this);\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_SELECTED');\n        },\n        'draggingTool.doMouseMove': function() { // To write custom logic when mouse move started while dragging\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_MOVED', {\n                draggingTool: this\n            });\n        },\n        'draggingTool.doMouseUp': function() { // To write custom logic when mouse up done while dragging\n            dispatch('GO_DIAGRAM#DRAGGING_TOOL_MOUSE_UP', {\n                draggingTool: this\n            });\n        },\n        ViewportBoundsChanged: function(event) { // To write custom logic when viewportBoundsChanged\n            dispatch('GO_DIAGRAM#VIEWPORT_BOUNDS_CHANGED', {\n                event: event\n            });\n        },\n        LinkDrawn: function(event) { // To write custom logic when link drawn\n            dispatch('GO_DIAGRAM#LINK_DRAWN', {\n                event: event\n            });\n        },\n        ChangedSelection: function(event) { // To write custom log while selection gets changed\n            dispatch('GO_DIAGRAM#SELECTION_CHANGED', {\n                selection: event.subject.first()\n            });\n        },\n        ModelChanged: function(event) { // To write custom logic when diagram model changed\n            dispatch('GO_DIAGRAM#MODEL_CHANGED', {\n                event: event\n            });\n        }\n    };\n}","diagram_template":{"link":"https://dev315171.service-now.com/api/now/v1/table/sn_diagram_builder_diagram_template/2835a724c3d030101099006c2840dd36","value":"2835a724c3d030101099006c2840dd36"},"advanced":"false","sys_updated_on":"2024-06-25 15:34:22","sys_class_name":"sn_diagram_builder_configuration","enable_search":"true","sys_id":"f7052724c3d030101099006c2840dd80","sys_updated_by":"admin","enable_animation":"false","sys_created_on":"2021-05-20 15:48:15","sys_name":"Flow Diagram","right_component":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_ux_lib_component/e1980b6a4a8491a40a4755dba82fc141","value":"e1980b6a4a8491a40a4755dba82fc141"},"sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/a4f5f4d7ca80209b2a32be23119ae821","value":"a4f5f4d7ca80209b2a32be23119ae821"},"theme":"","enable_layout_customization":"true","sys_created_by":"admin","right_panel":"true","content_alignment":"Center","palette_configuration":"","sys_mod_count":"231","sys_tags":"","alerts_component":"","props":"","layout":"function getFlowDiagrammingLayout($, go) {\n    var SYS_IDS = FlowDiagramConstants.SYS_IDS;\n    var LAYOUT_CONFIGURATION = FlowDiagramConstants.LAYOUT_CONFIGURATION;\n    var NODE_TYPES = FlowDiagramConstants.NODE_TYPES;\n    var SOURCE_NODE_KEYS = FlowDiagramConstants.SOURCE_NODE_KEYS;\n    var FLOW_LOGIC_TYPES = FlowDiagramConstants.FLOW_LOGIC_TYPES;\n    var INSTANCE_TYPES = FlowDiagramConstants.INSTANCE_TYPES;\n\n    function FlowDiagramLayout() {\n        go.Layout.call(this);\n        // node.data.key -> Rect\n        this._dimensions = new go.Map();\n        // node.data.key -> node\n        this._nodes = new go.Map();\n        // key of the hidden else node, which is available through previousSibing and nextSibling\n        // value is an object with two entries:\n        // {\n        //    previousSibling: the IF or ELSEIF node key\n        //    nextSibling: the node after the IF group\n        // }\n        this._hiddenElseLinks = new go.Map();\n    }\n\n    go.Diagram.inherit(FlowDiagramLayout, go.Layout);\n\n    /*****************************\n            start of helper methods\n     ******************************/\n    FlowDiagramLayout.prototype._resetMapData = function() {\n        this._dimensions.clear();\n        this._nodes.clear();\n        this._hiddenElseLinks.clear();\n    };\n\n    FlowDiagramLayout.prototype.getNodeId = function(node, key) {\n        if (!key) {\n            key = LAYOUT_CONFIGURATION.NODE_ID;\n        }\n        if (!node || !node.data || !node.data[key]) {\n            return \"\";\n        }\n        return node.data[key];\n    };\n\n    FlowDiagramLayout.prototype.getNodeShapeType = function(node, key) {\n        /*  Node shape template types:\n            simple      - single input, single output: ex. trigger, action, stage\n            end         - hidden node\n            block       - ex. forEach (loop), parallel branch (block), decision branch (block)\n            conditional - single input, true/false outputs: ex. if, elseIf\n            oneToMany   - single input, many outputs: ex. parallel, decision\n        */\n        var sysId = this.getNodeId(node, key);\n        var linkIt = node.findLinksOutOf();\n        var numLinksOut = linkIt.count;\n\n\n        if (this.isEndDoLoop(node)) {\n            return NODE_TYPES.END;\n        } else if (this.isTryNode(node)) {\n            return NODE_TYPES.BLOCK;\n        }\n\n        switch (true) {\n            case sysId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_TRIGGER_NODE_ID:\n            case sysId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_ADD_TRIGGER_NODE_ID:\n            case sysId === SYS_IDS.FLOW_LOGIC_PATH_BROKEN_ACTION && numLinksOut <= 1:\n            case sysId === SYS_IDS.FLOW_ACTION_DIAGRAM_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_STAGE_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_ONE_TO_ONE_ACTION:\n            case sysId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_SUBFLOW_INS_OUTS_NODE_ID:\n            case sysId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_ADD_A_SUBFLOW_INS_OUTS_NODE_ID:\n            case sysId === SYS_IDS.FLOW_PLACEHOLDER_ACTION:\n                return NODE_TYPES.SIMPLE;\n            case sysId === SYS_IDS.FLOW_LOGIC_LOOP_DIAGRAM_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_DO_LOOP_DIAGRAM_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_PARALLEL_BLOCK_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_DECISION_BLOCK_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_TRY_ACTION:\n                return NODE_TYPES.BLOCK;\n            case sysId === SYS_IDS.FLOW_LOGIC_END_LOOP_IF_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_END_DO_LOOP_IF_ACTION:\n            case sysId === SYS_IDS.FLOW_LOGIC_PATH_BROKEN_ACTION && node.data.loopStartNodeKey && numLinksOut === 2:\n            case sysId === SYS_IDS.FLOW_LOGIC_END_CATCH_ACTION:\n                return NODE_TYPES.END;\n            case sysId === SYS_IDS.FLOW_LOGIC_CONDITIONAL_DIAGRAM_ACTION:\n                return NODE_TYPES.CONDITIONAL;\n            case sysId === SYS_IDS.FLOW_LOGIC_ONE_TO_MANY_ACTION:\n                return NODE_TYPES.ONE_TO_MANY;\n            case sysId === SYS_IDS.FLOW_LOGIC_GO_BACK_TO_ACTION:\n                return NODE_TYPES.GO_BACK_TO;\n            case sysId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_ADD_A_NODE_NODE_ID:\n                return NODE_TYPES.ADD_A_NODE;\n            case sysId === SYS_IDS.FLOW_LOGIC_CATCH_ACTION:\n                return NODE_TYPES.TRY_CATCH;\n            case sysId === SYS_IDS.FLOW_LOGIC_CONTINUE_ACTION:\n                return NODE_TYPES.CONTINUE;\n            default:\n                return \"\";\n        }\n    };\n\n    FlowDiagramLayout.prototype.isConditionalTruePort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_IF_ELSE_OUTPUT_TRUE_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isConditionalFalsePort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_IF_ELSE_OUTPUT_FALSE_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isBreakPort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_BREAK_OUTPUT_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isBreakPort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_BREAK_OUTPUT_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isLoopBackPort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_FOR_INPUT_LOOP_BACK_SYS_ID ||\n            portId === SYS_IDS.DIAGRAM_PORT_FOR_INPUT_DO_LOOP_BACK_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isUntilLoopOutputPort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_END_DO_LOOP_OUTPUT_LOOPBACK_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isGoBackToOutputPort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_GOBACKTO_OUTPUT_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isGoBackToInputPort = function(portId) {\n        return portId === SYS_IDS.DIAGRAM_PORT_GOBACKTO_INPUT_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isFlowTriggerOrSubflowInputsOutputs = function(node) {\n        var nodeId = this.getNodeId(node);\n        return nodeId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_TRIGGER_NODE_ID || nodeId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_ADD_TRIGGER_NODE_ID || nodeId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_SUBFLOW_INS_OUTS_NODE_ID || nodeId === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_ADD_A_SUBFLOW_INS_OUTS_NODE_ID;\n    };\n\n    FlowDiagramLayout.prototype.isFlowEnd = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_DIAGRAM_TEMPLATE_ADD_A_NODE_NODE_ID;\n    };\n\n    FlowDiagramLayout.prototype.isPathBroken = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_PATH_BROKEN_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isConditionalNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_CONDITIONAL_DIAGRAM_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isIfNode = function(node) {\n        return this.getNodeId(node, LAYOUT_CONFIGURATION.DEFINITION_SYS_ID) === SYS_IDS.FLOW_LOGIC_IF_DEFINITION_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isElseIfNode = function(node) {\n        return this.getNodeId(node, LAYOUT_CONFIGURATION.DEFINITION_SYS_ID) === SYS_IDS.FLOW_LOGIC_ELSEIF_DEFINITION_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isElseNodeKey = function(nodeKey) {\n        var node = this._nodes.get(nodeKey);\n        if (!node && this._hiddenElseLinks.get(nodeKey)) {\n            return true;\n        }\n        return false;\n    };\n\n    FlowDiagramLayout.prototype.isLoopNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_LOOP_DIAGRAM_ACTION ||\n            this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_DO_LOOP_DIAGRAM_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isDoLoopNode = function(node) {\n        return this.getNodeId(node, LAYOUT_CONFIGURATION.DEFINITION_SYS_ID) === SYS_IDS.FLOW_LOGIC_DOUNTIL_DEFINITION_SYS_ID;\n    };\n\n    FlowDiagramLayout.prototype.isLogicBlockNode = function(node) {\n        return this.isIfNode(node) || this.isElseIfNode(node) || this.isLoopNode(node);\n    };\n\n    FlowDiagramLayout.prototype.isGoBackToNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_GO_BACK_TO_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isBreakNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_BREAK_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isContinueNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_CONTINUE_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isBreakNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_BREAK_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isContinueNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_CONTINUE_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isGoBackToTargetNode = function(node) {\n        var id = this.getNodeId(node, 'key');\n        if (id && this.goBackToTargetMap[id]) {\n            return true;\n        }\n        return false;\n    };\n\n    FlowDiagramLayout.prototype.isLastNode = function(node) {\n        return this.getNodeId(node, 'key') === this.lastNodeKey;\n    };\n\n    FlowDiagramLayout.prototype.isActionNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_ACTION_DIAGRAM_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isStageNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_STAGE_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isPathBrokenLoopNode = function(node, numLinksOut) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_PATH_BROKEN_ACTION &&\n            node.data.loopStartNodeKey && numLinksOut === 2;\n    };\n\n    FlowDiagramLayout.prototype.isOneToOneFlowLogic = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_ONE_TO_ONE_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isOneToManyFlowLogic = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_ONE_TO_MANY_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isSimpleNode = function(node, numLinksOut) {\n        return numLinksOut <= 1 && (this.isFlowTriggerOrSubflowInputsOutputs(node) || this.isActionNode(node) || this.isPathBroken(node) || this.isOneToOneFlowLogic(node) || this.isStageNode(node));\n    };\n\n    FlowDiagramLayout.prototype.isParallelBlock = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_PARALLEL_BLOCK_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isDecisionBlock = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_DECISION_BLOCK_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isEndNode = function(node) {\n        return this.getNodeId(node) === SYS_IDS.FLOW_LOGIC_END_LOOP_IF_ACTION;\n    };\n\n    FlowDiagramLayout.prototype.isEndLoop = function(node) {\n        return this.isEndNode(node) && node.data[SOURCE_NODE_KEYS.SOURCE_LOOP] !== undefined;\n    };\n\n    FlowDiagramLayout.prototype.isEndDoLoop = function(node) {\n        return node.data && node.data.instanceType && node.data.instanceType === FLOW_LOGIC_TYPES.ENDDOLOOP\n    };\n\n    FlowDiagramLayout.prototype.isEndIf = function(node) {\n        return this.isEndNode(node) && node.data[SOURCE_NODE_KEYS.SOURCE_IF] !== undefined;\n    };\n\n    FlowDiagramLayout.prototype.isEndCatch = function(node) {\n        return this.isEndNode(node) && (node.data[SOURCE_NODE_KEYS.SOURCE_CATCH] !== undefined || node.data.instanceType === FLOW_LOGIC_TYPES.ENDCATCH);\n    };\n\n    FlowDiagramLayout.prototype.isEndParallel = function(node) {\n        return this.isEndNode(node) && node.data[SOURCE_NODE_KEYS.SOURCE_PARALLEL] !== undefined;\n    };\n\n    FlowDiagramLayout.prototype.isEndDecision = function(node) {\n        return this.isEndNode(node) && node.data[SOURCE_NODE_KEYS.SOURCE_DECISION] !== undefined;\n    };\n\n    FlowDiagramLayout.prototype.isDecisionNode = function(node) {\n        if (!node || !node.data || !node.data.data || !node.data.data.hasOwnProperty(LAYOUT_CONFIGURATION.DECISION_LABEL)) {\n            return false;\n        }\n        return true;\n    };\n\n    FlowDiagramLayout.prototype.isTryNode = function(node) {\n        return node && node.data && node.data.definition_type === FLOW_LOGIC_TYPES.TRY;\n    };\n\n    FlowDiagramLayout.prototype.isCatchNode = function(node) {\n        return node && node.data && node.data.definition_type === FLOW_LOGIC_TYPES.CATCH;\n    };\n\n    FlowDiagramLayout.prototype.isCatchNodeWithChildren = function(node) {\n        var nodeData = node.data;\n        return nodeData.definition_type === FLOW_LOGIC_TYPES.CATCH &&\n            nodeData.relation &&\n            nodeData.relation.children &&\n            nodeData.relation.children.length;\n    };\n\n    FlowDiagramLayout.prototype.isFromTryCatchNode = function(node) {\n        var parentId = this.getRelation(node, \"parent\");\n        var previousSiblingId = this.getRelation(node, \"previousSibling\");\n        var parentNode = this._nodes.get(parentId);\n        return !previousSiblingId && (this.getNodeId(parentNode) === SYS_IDS.FLOW_LOGIC_TRY_ACTION || this.getNodeId(parentNode) === SYS_IDS.FLOW_LOGIC_CATCH_ACTION);\n    };\n\n    FlowDiagramLayout.prototype.fromStageNode = function(node, stageNodesMap) {\n        if (node && node.key && stageNodesMap) {\n            return stageNodesMap[node.key];\n        } else {\n            return false;\n        }\n    };\n\n    FlowDiagramLayout.prototype.isGroupNode = function(node) {\n        return this.isConditionalNode(node) || this.isLoopNode(node) || this.isParallelBlock(node) || this.isDecisionBlock(node) || this.isOneToManyFlowLogic(node);\n    };\n\n    FlowDiagramLayout.prototype.isGroupParentNode = function(node) {\n        return this.isConditionalNode(node) || this.isLoopNode(node) || this.isOneToManyFlowLogic(node);\n    };\n\n    FlowDiagramLayout.prototype.getSourceNodeKey = function(node) {\n        if (this.isEndLoop(node)) {\n            return node.data[SOURCE_NODE_KEYS.SOURCE_LOOP];\n        } else if (this.isEndIf(node)) {\n            return node.data[SOURCE_NODE_KEYS.SOURCE_IF];\n        } else if (this.isEndParallel(node)) {\n            return node.data[SOURCE_NODE_KEYS.SOURCE_PARALLEL];\n        } else if (this.isEndDecision(node)) {\n            return node.data[SOURCE_NODE_KEYS.SOURCE_DECISION];\n        } else if (this.isEndCatch(node)) {\n            return node.data[SOURCE_NODE_KEYS.SOURCE_CATCH];\n        } else {\n            return null;\n        }\n    };\n\n    FlowDiagramLayout.prototype.findPathBrokenSourceNodeKey = function(node) {\n        if (!node || !node.data) {\n            return \"\";\n        }\n\n        // If Path Broken is from a traditional end node, use that end node key\n        var sourceNodeKey = node.data[SOURCE_NODE_KEYS.SOURCE_PARALLEL] || node.data[SOURCE_NODE_KEYS.SOURCE_DECISION] ||\n            node.data[SOURCE_NODE_KEYS.SOURCE_IF] || node.data[SOURCE_NODE_KEYS.SOURCE_LOOP] ||\n            node.data[SOURCE_NODE_KEYS.SOURCE_CATCH] || node.data[SOURCE_NODE_KEYS.SOURCE_TRY];\n\n        if (sourceNodeKey) {\n            return sourceNodeKey;\n        }\n\n        // If source node key not found, find associated End node and use its parent\n        var endNode = this.diagram.findNodeForKey(node.data.endNodeKey);\n        if (endNode) {\n            return endNode.data.parent ||\n                (endNode.data.relation && endNode.data.relation.parent);\n        }\n\n        return null;\n    };\n\n    FlowDiagramLayout.prototype.verticallyAligned = function(link, x) {\n        // the fromNode is positioned but not the toNode\n        // but the horizontal position of the toNode is dependent on the x value\n        // Note that we need to deal with the case that\n        // the nodes at the ends of the link do not have the same width\n        var fromNodeBoundary = link.fromNode.actualBounds;\n        var fromPortBoundary = link.fromPort.actualBounds;\n        var toNodeBoundary = link.toNode.actualBounds;\n        var toPortBoundary = link.toPort.actualBounds;\n        return (\n            fromNodeBoundary.x + fromPortBoundary.x + fromPortBoundary.width / 2 ===\n            x - toNodeBoundary.width / 2 + toPortBoundary.x + toPortBoundary.width / 2\n        );\n    };\n\n    FlowDiagramLayout.prototype.getRelation = function(node, relation, defaultValue) {\n        var result = defaultValue;\n        if (node) {\n            if (node[relation]) {\n                result = node[relation]\n            } else if (node.data && node.data.relation) {\n                result = node.data.relation[relation];\n            }\n        }\n        return result;\n    };\n\n    FlowDiagramLayout.prototype.addToCustomLinks = function(customLinks, link, linkIt) {\n        customLinks.add(link);\n        if (linkIt.next()) {\n            return linkIt.value;\n        } else {\n            return undefined;\n        }\n    };\n\n    FlowDiagramLayout.prototype.getBottomPosition = function(nodeBoundary, portBoundary) {\n        var x = nodeBoundary.x + portBoundary.x + portBoundary.width / 2;\n        var y = nodeBoundary.y + portBoundary.y + portBoundary.height;\n        return {\n            x: x,\n            y: y,\n        };\n    };\n\n    FlowDiagramLayout.prototype.getTopPosition = function(nodeBoundary, portBoundary) {\n        var x = nodeBoundary.x + portBoundary.x + portBoundary.width / 2;\n        var y = nodeBoundary.y;\n        return {\n            x: x,\n            y: y,\n        };\n    };\n\n    FlowDiagramLayout.prototype.getRightPosition = function(nodeBoundary, portBoundary) {\n        var x = nodeBoundary.x + portBoundary.x + portBoundary.width;\n        var y = nodeBoundary.y + portBoundary.y + portBoundary.height / 2;\n        return {\n            x: x,\n            y: y,\n        };\n    };\n\n    FlowDiagramLayout.prototype.calculateOneToManyCenterAlignOffset = function(firstX, lastX, currentX, baseX) {\n        // We center align the \"many\" branches by calculating the total x-axis and divide it by 2\n        // var baseX = this.x;\n        var offSetX = (Math.abs((Math.abs(firstX) + Math.abs(lastX))) / 2);\n        if (currentX) {\n            baseX = currentX;\n        }\n        return baseX - offSetX;\n    };\n\n    FlowDiagramLayout.prototype.getFromNode = function(node) {\n        if (!node) {\n            return;\n        }\n        var linkIt = node.findLinksInto();\n        if (linkIt.next()) {\n            var link = linkIt.value;\n            return link.fromNode;\n        }\n        return;\n    };\n\n    FlowDiagramLayout.prototype.hasPreviousSibling = function(node) {\n        if (!node || !node.data || !node.data.relation) {\n            return false;\n        }\n        return node.data.relation.previousSibling;\n    };\n\n    FlowDiagramLayout.prototype.isCenterAlignEnabled = function(branchCount, node, parallelMap) {\n        if (!branchCount && !node) {\n            return LAYOUT_CONFIGURATION.ONE_TO_MANY_ALIGN_CENTER_ENABLED;\n        }\n        return LAYOUT_CONFIGURATION.ONE_TO_MANY_ALIGN_CENTER_ENABLED && branchCount > 1 && !parallelMap[node.key];\n    };\n\n    FlowDiagramLayout.prototype.getLinkHeight = function(link) {\n        if (link.data.linkLabel) {\n            return LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_WITH_LABEL;\n        } else {\n            return LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n        }\n    };\n\n    FlowDiagramLayout.prototype.calculateBlockXAxis = function(x, width, index) {\n        return index < 1 ? x : x + width + LAYOUT_CONFIGURATION.NODE_GAP_HORIZONTAL_PARALLEL / 2;\n    };\n\n    FlowDiagramLayout.prototype.getLinkSegmentHeight = function(link) {\n        if (this.isEndLoop(link.fromNode)) {\n            return LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_LOOP_END;\n        } else if (this.isDecisionNode(link.fromNode)) {\n            return LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_DECISION_WITHOUT_STAGE;\n        } else {\n            return LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n        }\n    };\n\n    FlowDiagramLayout.prototype.isIfElseIfLink = function(link) {\n        var nextSiblingOfFromNode = this.getRelation(link.fromNode, \"nextSibling\");\n        return (\n            link.toNode && link.toNode.data &&\n            nextSiblingOfFromNode === link.toNode.data.key &&\n            this.isElseIfNode(link.toNode)\n        );\n    };\n\n    FlowDiagramLayout.prototype.isElseLink = function(link) {\n        var nextSiblingOfFromNode = this.getRelation(link.fromNode, \"nextSibling\");\n        var parentOfToNode = this.getRelation(link.toNode, \"parent\");\n        // make sure that nextSiblingOfFromNode exists, which means that there is an ELSE path.\n        return nextSiblingOfFromNode && nextSiblingOfFromNode === parentOfToNode;\n    };\n\n    FlowDiagramLayout.prototype.shouldUpdateNodeY = function(node, linksIntoResult, stageNodesMap) {\n        var fromNode = this.getFromNode(node);\n        var isAllowedStageNode = this.hasPreviousSibling(node) && this.isDecisionBlock(node) && this.fromStageNode(node, stageNodesMap);\n        // nodes does not have stage || if has presib\n        if ((linksIntoResult.customLinks.length > 0 || linksIntoResult.verticalLink) && (!this.fromStageNode(node, stageNodesMap) || isAllowedStageNode) && !(this.isDecisionNode(fromNode) && this.isStageNode(node))) {\n            return true;\n        }\n        return false;\n    };\n\n    FlowDiagramLayout.prototype.updateStageNodeRelation = function(nextNode) {\n        if (nextNode && this.isStageNode(nextNode) && nextNode.data) {\n            if (!nextNode.data.relation) {\n                nextNode.data.relation = {};\n            }\n            nextNode.data.relation.parent = nextNode.data.parent;\n            nextNode.data.relation.nextSibling = nextNode.data.associated_node_key;\n        }\n    };\n\n    FlowDiagramLayout.prototype.getNodeIndex = function(link) {\n        var nextNode = link.toNode;\n        if (this.isStageNode(nextNode)) {\n            var linkIt = nextNode.findLinksOutOf();\n            if (linkIt.next()) {\n                nextNode = linkIt.value.toNode;\n            }\n        }\n        var currentChildren = this.getRelation(link.fromNode, \"children\", []);\n        return currentChildren.indexOf(nextNode.data.key);\n    };\n    /*****************************\n            end of helper methods\n     ******************************/\n\n\n    FlowDiagramLayout.prototype.invalidBound = function(node) {\n        var bound = node.actualBounds;\n        return isNaN(bound.x) || isNaN(bound.y);\n    };\n\n    FlowDiagramLayout.prototype.getNodeDimension = function(node) {\n        if (!node || !node.data) {\n            return;\n        }\n        var dimensionKey = node.data.key;\n        var dimension;\n        if (this.isGroupNode(node)) {\n            dimension = this._dimensions.get(\"grp-\" + dimensionKey);\n            if (dimension) {\n                return dimension.copy();\n            }\n        }\n        if (this._dimensions.get(dimensionKey)) {\n            return this._dimensions.get(dimensionKey).copy();\n        }\n    };\n\n    FlowDiagramLayout.prototype.setNodeDimension = function(node, boundary) {\n        this._dimensions.set(node.data.key, boundary.copy());\n    };\n\n    FlowDiagramLayout.prototype.setGroupDimension = function(node, boundary) {\n        this._dimensions.set(\"grp-\" + node.data.key, boundary.copy());\n    };\n\n    FlowDiagramLayout.prototype.getGroupDimensionByKey = function(key) {\n        var dimension = this._dimensions.get(\"grp-\" + key);\n        if (dimension) {\n            return dimension.copy();\n        }\n        return;\n    };\n\n    FlowDiagramLayout.prototype.setGroupDimensionByKey = function(key, boundary) {\n        this._dimensions.set(\"grp-\" + key, boundary.copy());\n    };\n\n    FlowDiagramLayout.prototype.enlargeGroupDimension = function(endNode, additionalGap) {\n        var sourceNodeKey = this.getSourceNodeKey(endNode);\n        if (sourceNodeKey) {\n            var sourceGroupDimension = this.getGroupDimensionByKey(sourceNodeKey);\n            var endNodeDimension = this._dimensions.get(endNode.data.key);\n            var enlargedDimension = endNodeDimension;\n            if (sourceGroupDimension) {\n                if (additionalGap) {\n                    sourceGroupDimension.width = sourceGroupDimension.width + additionalGap;\n                }\n                enlargedDimension = sourceGroupDimension.unionRect(endNodeDimension);\n            }\n            this.setGroupDimensionByKey(sourceNodeKey, enlargedDimension);\n        }\n    };\n\n    FlowDiagramLayout.prototype.getLinkHeightToNode = function(toNode, x) {\n        var linkHeight = LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n        if (this.fromStageNode(toNode, this.stageNodesMap)) {\n            return LAYOUT_CONFIGURATION.STAGE_VERTICAL_LINK;\n        }\n        if (toNode) {\n            var linkIt = toNode.findLinksInto();\n            while (linkIt.next()) {\n                var link = linkIt.value;\n                if (this.verticallyAligned(link, x)) {\n                    if (this.isEndLoop(link.fromNode) || this.isEndDoLoop(link.fromNode)) {\n                        linkHeight = LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_LOOP_END;\n                    } else if (this.isEndIf(link.toNode) || this.isEndCatch(toNode) || this.isEndParallel(link.toNode) || this.isEndDecision(link.toNode)) {\n                        if (link.data.linkLabel) {\n                            linkHeight = LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_IF_END_WITH_LABEL;\n                        } else if (this.isEndCatch(toNode)) {\n                            linkHeight = LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n                        } else {\n                            linkHeight = LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_IF_END;\n                        }\n                    } else {\n                        linkHeight = this.getLinkHeight(link);\n                    }\n                    break;\n                }\n            }\n        }\n        return linkHeight;\n    };\n\n    // Since Stage nodes initially have invalidBound(), a node might not have an actualBounds at this point.\n    // If a link.fromNode has an invalidBound(), move link.fromNode based on the node's actualBounds\n    FlowDiagramLayout.prototype.moveFromNodeIfInvalidBound = function(link) {\n        var node;\n        if (link && link.fromNode && link.fromNode.actualBounds && this.invalidBound(link.fromNode)) {\n            if (this.stageNodesMap[link.fromNode.key]) {\n                node = this._nodes.get(this.stageNodesMap[link.fromNode.key]);\n            } else if (link.fromNode.data && link.fromNode.data.relation && link.fromNode.data.relation.previousSibling) {\n                node = this._nodes.get(link.fromNode.data.relation.previousSibling);\n            }\n            if (node && node.actualBounds && !this.invalidBound(node)) {\n                link.fromNode.moveTo(node.actualBounds.x - LAYOUT_CONFIGURATION.NODE_GAP_HORIZONTAL_STAGE, node.actualBounds.y + node.actualBounds.height + LAYOUT_CONFIGURATION.STAGE_VERTICAL_LINK);\n            }\n        }\n    };\n\n    // if the fromNode and toNode are ENDOF nodes and fromNode does not have actualBounds\n    // get x from originating ENDOF node of fromNode and get y from toNode.actualBounds.y\n    // this can happen since an ENDOF node does not have real actualBounds to begin with\n    FlowDiagramLayout.prototype.moveNodeIfFromToEndNodeAndInvalidBound = function(link) {\n        if (this.invalidBound(link.fromNode) &&\n            !this.invalidBound(link.toNode) &&\n            this.isEndNode(link.fromNode) &&\n            this.isEndNode(link.toNode)) {\n            var adjustedX;\n            var sourceNode;\n            if (link.fromNode.data &&\n                this.isEndDecision(link.fromNode) &&\n                this._nodes.get(link.fromNode.data[SOURCE_NODE_KEYS.SOURCE_DECISION])) {\n                sourceNode = this._nodes.get(link.fromNode.data[SOURCE_NODE_KEYS.SOURCE_DECISION]);\n            } else if (link.fromNode.data &&\n                this.isEndParallel(link.fromNode) &&\n                this._nodes.get(link.fromNode.data[SOURCE_NODE_KEYS.SOURCE_PARALLEL])) {\n                sourceNode = this._nodes.get(link.fromNode.data[SOURCE_NODE_KEYS.SOURCE_PARALLEL]);\n            }\n            if (sourceNode && !this.invalidBound(sourceNode)) {\n                adjustedX = sourceNode.actualBounds.x + sourceNode.actualBounds.width / 2 - LAYOUT_CONFIGURATION.ONE_TO_MANY_ICON_X_OFFSET;\n                link.fromNode.moveTo(adjustedX, link.toNode.actualBounds.y - LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK);\n            }\n        }\n    };\n\n    FlowDiagramLayout.prototype.categorizeLinksInto = function(linkIt, x) {\n        // Should only have at most one vertical link\n        // Can be undefined if there is an End node above\n        var verticalLink;\n        // incoming link from a node above and on the left-hand size\n        // the from node is an IF or ELSEIF node and the link is from its false port\n        var sideLink;\n        var customLinks = new go.List();\n        var downLinks = new go.List();\n        var rightLinks = new go.List();\n        while (linkIt.next()) {\n            var link = linkIt.value;\n            this.moveFromNodeIfInvalidBound(link);\n            this.moveNodeIfFromToEndNodeAndInvalidBound(link);\n\n            // Error case: Should not happen\n            if (this.invalidBound(link.fromNode)) {\n                continue;\n            }\n\n            if (!this.isLoopBackPort(link.toPortId)) {\n                if (this.isConditionalFalsePort(link.fromPortId)) {\n                    if (this.isIfElseIfLink(link) || this.isElseLink(link) || this.isCatchNodeWithChildren(link.fromNode)) {\n                        sideLink = link;\n                    } else {\n                        rightLinks.add(link);\n                    }\n                } else {\n                    if (this.isFlowTriggerOrSubflowInputsOutputs(link.fromNode) || this.isPathBroken(link.fromNode)) {\n                        // Trigger and PathBroken nodes are special case because\n                        // their port size is incorrect. Should get it fixed!\n                        verticalLink = link;\n                    } else if (this.verticallyAligned(link, x)) {\n                        verticalLink = link;\n                    } else {\n                        downLinks.add(link);\n                    }\n                }\n            } else if (link.fromPortId === SYS_IDS.DIAGRAM_PORT_END_DO_LOOP_OUTPUT_LOOPBACK_SYS_ID && !sideLink) {\n                sideLink = link;\n            }\n        }\n        // sort down-link nodes from left to right\n        downLinks.sort(function(l1, l2) {\n            return l1.fromNode.actualBounds.x - l2.fromNode.actualBounds.x;\n        });\n        // sort right-link nodes from bottom to top\n        rightLinks.sort(function(l1, l2) {\n            return l2.fromNode.actualBounds.y - l1.fromNode.actualBounds.y;\n        });\n\n        var currentDownLink;\n        var currentRightLink;\n        var downLinkIt = downLinks.iterator;\n        var rightLinkIt = rightLinks.iterator;\n        if (downLinkIt.next()) {\n            currentDownLink = downLinkIt.value;\n        }\n        if (rightLinkIt.next()) {\n            currentRightLink = rightLinkIt.value;\n        }\n        while (currentDownLink || currentRightLink) {\n            if (!currentDownLink) {\n                currentRightLink = this.addToCustomLinks(customLinks, currentRightLink, rightLinkIt);\n            } else if (!currentRightLink) {\n                currentDownLink = this.addToCustomLinks(customLinks, currentDownLink, downLinkIt);\n            } else {\n                var currentGroupDimension = this.getNodeDimension(\n                    currentRightLink.fromNode\n                );\n                if (currentGroupDimension) {\n                    if (currentGroupDimension.containsRect(currentDownLink.fromNode.actualBounds)) {\n                        currentDownLink = this.addToCustomLinks(customLinks, currentDownLink, downLinkIt);\n                    } else if (\n                        currentDownLink.fromNode.actualBounds.x + currentDownLink.fromNode.actualBounds.width < currentGroupDimension.x\n                    ) {\n                        currentDownLink = this.addToCustomLinks(customLinks, currentDownLink, downLinkIt);\n                    } else {\n                        currentRightLink = this.addToCustomLinks(customLinks, currentRightLink, rightLinkIt);\n                    }\n                } else { // we need to breakout of infinite loop\n                    break;\n                }\n            }\n        }\n        return {\n            customLinks: customLinks,\n            verticalLink: verticalLink,\n            sideLink: sideLink,\n        };\n    };\n\n    FlowDiagramLayout.prototype.updateNodeY = function(verticalLink, customLinks, node, y, ignoreCustom) {\n        var fromNodeY = 0;\n        var toStageNode = false;\n        if (this.isStageNode(node) && this.stageNodeAssociatedMap[node.key]) {\n            var toNodeKey = this.stageNodeAssociatedMap[node.key];\n            node = this._nodes.get(toNodeKey);\n            toStageNode = true;\n        }\n\n        // If node is a GOBACK target then add height to the GOBACK edge\n        if (this.isGoBackToTargetNode(node)) {\n            y += LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_GOBACKTO_TARGET;\n            if (toStageNode) {\n                y += LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n            }\n        }\n        if (verticalLink && !this.isDecisionBlock(node)) {\n            var verticalLinkFromNodeBoundary = verticalLink.fromNode.actualBounds;\n            fromNodeY =\n                verticalLinkFromNodeBoundary.y + verticalLinkFromNodeBoundary.height;\n        } else {\n            // End node blocks the vertical link\n            // Get the previous sibling that is an IF node\n            var previousSiblingAsIf;\n            var previousSiblingAsDecision;\n            var curr = node;\n            while (true) {\n                var previousSiblingId = this.getRelation(curr, \"previousSibling\");\n                if (!previousSiblingId) {\n                    break;\n                }\n                var previousSibling = this._nodes.get(previousSiblingId);\n                if (!previousSibling) {\n                    // hidden else node\n                    previousSiblingId =\n                        this._hiddenElseLinks.get(previousSiblingId).previousSibling;\n                    previousSibling = this._nodes.get(previousSiblingId);\n                } else {\n                    if (this.isIfNode(previousSibling)) {\n                        previousSiblingAsIf = previousSibling;\n                        break;\n                    }\n                    if (this.isDecisionBlock(previousSibling)) {\n                        previousSiblingAsDecision = previousSibling;\n                        break;\n                    }\n                }\n                curr = previousSibling;\n            }\n            if (previousSiblingAsIf) {\n                var previousSiblingAsIfBoundary =\n                    this.getNodeDimension(previousSiblingAsIf);\n                if (previousSiblingAsIfBoundary) {\n                    fromNodeY =\n                        previousSiblingAsIfBoundary.y + previousSiblingAsIfBoundary.height;\n                } else {\n                    fromNodeY = y;\n                }\n            }\n            if (previousSiblingAsDecision) {\n                var previousSiblingAsDecisionBoundary =\n                    this.getNodeDimension(previousSiblingAsDecision);\n                if (previousSiblingAsDecisionBoundary) {\n                    fromNodeY = previousSiblingAsDecisionBoundary.y;\n                }\n                return fromNodeY;\n            } else if (this.fromStageNode(node, this.stageNodesMap)) {\n                return y;\n            }\n        }\n        var customLinksSize = customLinks.size;\n        if (ignoreCustom) { // ignore custom link when link into is GoBackTo\n            customLinksSize = 0;\n        }\n        y = Math.max(\n            y,\n            fromNodeY +\n            LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK +\n            (customLinksSize - 1) * LAYOUT_CONFIGURATION.EDGE_GAP +\n            LAYOUT_CONFIGURATION.EDGE_GAP_LARGE\n        );\n        var linkIt = customLinks.iterator;\n        while (linkIt.next()) {\n            var index = linkIt.key;\n            var link = linkIt.value;\n            // if node is a GoBack target then source is below, we don't want to add this space above target\n            if (!this.isGoBackToOutputPort(link.fromPortId)) {\n                var fromNodeBoundary = link.fromNode.actualBounds;\n                fromNodeY = fromNodeBoundary.y + fromNodeBoundary.height;\n                y = Math.max(\n                    y,\n                    fromNodeY +\n                    this.getLinkSegmentHeight(link) +\n                    (customLinksSize - 1 - index) * LAYOUT_CONFIGURATION.EDGE_GAP +\n                    LAYOUT_CONFIGURATION.EDGE_GAP_LARGE\n                );\n            }\n        }\n        if (this.isCatchNode(node)) {\n            // add additional edge height for catch node\n            y += LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_CATCH;\n        }\n        return y;\n    };\n\n    FlowDiagramLayout.prototype.updateLinkX = function(linkX, parentNodeGroupDim, largestSiblingBlockLinkX) {\n        // when no siblings then just add x-axis HORIZONTAL GAP around parent block\n        if (parentNodeGroupDim) {\n            // add a RIGHT GAP point from GoBack Source Node\n            linkX = parentNodeGroupDim.x + parentNodeGroupDim.width + LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n            if (linkX < largestSiblingBlockLinkX) {\n                linkX = largestSiblingBlockLinkX;\n            }\n            return linkX;\n        }\n    };\n\n    FlowDiagramLayout.prototype.hasNextSiblingWithChildren = function(node) {\n        var nextSiblingKey = this.getRelation(node, \"nextSibling\");\n        if (nextSiblingKey && !this.isEndNode(node)) {\n            var nextSiblingNode = this._nodes.get(nextSiblingKey);\n            var nextSiblingChildren = this.getRelation(nextSiblingNode, \"children\", []);\n            if (nextSiblingChildren && nextSiblingChildren.length > 0) {\n                return true;\n            }\n            // check if next sibling is ELSE block\n            var sibElseNode = this._hiddenElseLinks.get(nextSiblingKey);\n            if (sibElseNode && sibElseNode.children && sibElseNode.children.length > 0) {\n                return true;\n            }\n            return this.hasNextSiblingWithChildren(nextSiblingNode);\n        }\n        return false;\n    };\n\n    // find largest sibling group to route down/around\n    FlowDiagramLayout.prototype.findLargestSiblingGroup = function(parentKey, toNodParentKey) {\n        var foundNode;\n        var foundNodeGroupDimension;\n        if (parentKey && parentKey !== toNodParentKey) {\n            var parentParentNode = this._nodes.get(parentKey);\n            if (this.isIfNode(parentParentNode) || this.isElseIfNode(parentParentNode)) {\n                parentNodeGroupDim = this.getGroupDimensionByKey(parentParentNode.data.key);\n                if (parentParentNode && parentParentNode.data.relation.nextSibling) {\n                    var parentSibNode = this._nodes.get(parentParentNode.data.relation.nextSibling);\n                    var parentSiblingNodeDimension = this.getNodeDimension(parentSibNode);\n                    var parentNextSiblingKey = this.getRelation(parentParentNode, \"nextSibling\");\n                    var parentSiblingGroupDimension = this.getGroupDimensionByKey(parentNextSiblingKey) || parentSiblingNodeDimension;\n                    if (parentSibNode && parentSiblingGroupDimension) {\n                        foundNode = parentSibNode;\n                        foundNodeGroupDimension = parentSiblingGroupDimension;\n                        return {\n                            foundNode: foundNode,\n                            foundNodeGroupDimension: foundNodeGroupDimension\n                        };\n                    }\n                }\n            } else if (this._hiddenElseLinks.get(parentKey)) {\n                var elseChildren = this._hiddenElseLinks.get(parentKey).children;\n                if (elseChildren && elseChildren.length > 0) {\n                    nextSiblingKey = elseChildren[0];\n                    nextSiblingNode = this._nodes.get(nextSiblingKey);\n                    var parentSiblingNodeDimension = this.getNodeDimension(nextSiblingNode);\n                    var parentSiblingGroupDimension = this.getGroupDimensionByKey(nextSiblingKey) || parentSiblingNodeDimension;\n                    if (nextSiblingNode && parentSiblingGroupDimension) {\n                        foundNode = nextSiblingNode;\n                        foundNodeGroupDimension = parentSiblingGroupDimension;\n                        return {\n                            foundNode: foundNode,\n                            foundNodeGroupDimension: foundNodeGroupDimension\n                        };\n                    }\n                }\n            }\n        }\n        return;\n    };\n\n    FlowDiagramLayout.prototype.getParentNode = function(node) {\n        if (!node) {\n            return;\n        }\n        var parentNodeKey = this.getRelation(node, \"parent\");\n        if (parentNodeKey) {\n            var parentNode = this._nodes.get(parentNodeKey);\n            if (parentNode && parentNode.data) {\n                return parentNode;\n            }\n            var parentElseNode = this._hiddenElseLinks.get(parentNodeKey);\n            if (parentElseNode) {\n                return parentElseNode;\n            }\n        }\n        return;\n    };\n\n    FlowDiagramLayout.prototype.getAncestorIfNode = function(node) {\n        if (!node) {\n            return;\n        }\n        var parentNodeKey = this.getRelation(node, \"parent\");\n        if (parentNodeKey) {\n            var parentNode = this._nodes.get(parentNodeKey);\n            if (parentNode && this.isElseIfNode(parentNode)) {\n                var siblingKey = this.getRelation(parentNode, \"previousSibling\");\n                parentNode = this._nodes.get(siblingKey);\n                return this.getAncestorIfNode(parentNode);\n            }\n            // if parent node is not found, check for Else\n            if (!parentNode) {\n                var previousSiblingKey = this._hiddenElseLinks.get(parentNodeKey).parent; // previousSibling\n                if (previousSiblingKey) {\n                    parentNode = this._nodes.get(previousSiblingKey);\n                }\n            }\n            if (this.isConditionalNode(parentNode)) {\n                return this.getAncestorIfNode(parentNode);\n            }\n        }\n        return node;\n    };\n\n    FlowDiagramLayout.prototype.getCurrentBlockIfNode = function(node) {\n        if (!node) {\n            return;\n        }\n        if (this.isIfNode(node)) {\n            return node;\n        }\n        if (this.isElseIfNode(node) || this.isElseNodeKey(node.key)) {\n            var previousSiblingKey = this.getRelation(node, \"previousSibling\");\n            var sibNode = this._nodes.get(previousSiblingKey);\n            return this.getCurrentBlockIfNode(sibNode);\n        }\n    };\n\n    FlowDiagramLayout.prototype.addRoutePointsDownAround = function(node, parentNode, linkX, linkY, pointsToAdd, shouldAddY) {\n        var parentNodeGroupDim = this.getGroupDimensionByKey(node.key || node.data.key);\n        // if any siblings have children then route Y down the length of the parent group dimension\n        if (parentNode && this.hasNextSiblingWithChildren(parentNode) && parentNodeGroupDim && shouldAddY) {\n            linkY = parentNodeGroupDim.y + parentNodeGroupDim.height;\n            pointsToAdd.push([linkX, linkY]);\n        } else {\n            // ElseIf/Else blocks have no siblings, add x-axis HORIZONTAL GAP around parent block\n            pointsToAdd.push([linkX, linkY]);\n        }\n\n        // add x-axis HORIZONTAL GAP around parent block only if separate node\n        if (parentNodeGroupDim && node !== parentNode) {\n            linkX = parentNodeGroupDim.x + parentNodeGroupDim.width;\n        }\n        pointsToAdd.push([linkX, linkY]);\n        return {\n            x: linkX,\n            y: linkY\n        }\n    };\n\n    // Route edge down/around logic\n    // this method will set 4 route points\n    FlowDiagramLayout.prototype.routeDownAroundSiblingElseBlocks = function(fromNode, fromPosition, x, pointsToAdd, targetNode) {\n        var linkX = x;\n        var linkY = fromPosition.y;\n        if (!this.hasParentDecisionBlock(fromNode, true)) {\n            // check if we need to route edge down and around a sibling group\n            // will be either IF, ELSEIF, ELSE\n            var parentKey = this.getRelation(fromNode, \"parent\");\n            var ancestorParentNode = this.getAncestorIfNode(fromNode);\n            var parentNode = this.getParentNode(fromNode) || ancestorParentNode;\n            var parentIfNodeKey = parentKey;\n            var isElseBlock = this.isElseNodeKey(parentKey);\n            var isCatchBlock = this.isCatchNode(parentNode);\n            var skipElseBlock = false;\n            if (isElseBlock) {\n                var elseNode = this._hiddenElseLinks.get(parentKey);\n                var parentIfNode = this.getCurrentBlockIfNode(elseNode);\n                if (elseNode && parentIfNode.key) {\n                    parentIfNodeKey = parentIfNode.key;\n                }\n                if (ancestorParentNode && ancestorParentNode.data.key === parentIfNodeKey) {\n                    skipElseBlock = true;\n                }\n                if (targetNode && parentIfNodeKey === targetNode.key) {\n                    skipElseBlock = true;\n                }\n            } else if (!isCatchBlock) {\n                // route down and around any sibling elseif, else blocks in current IF block\n                var topIfNode = this.getCurrentBlockIfNode(parentNode); // this.getAncestorIfNode(fromNode).data.name)\n                // Previous we only routed down (shouldAddY) when targetNode.data.order >= topIfNode.data.order\n                // this is not correct, if elseif or else have children we should always route down\n                const shouldAddY = true;\n\n                var newXnewY = this.addRoutePointsDownAround(topIfNode, parentNode, linkX, linkY, pointsToAdd, shouldAddY);\n                linkX = newXnewY.x;\n                linkY = newXnewY.y;\n                // if target is outside of current IF block, also need to route down/around\n                if (!targetNode || topIfNode.key !== targetNode.key) {\n                    this.addRoutePointsDownAround(targetNode, targetNode, linkX, linkY, pointsToAdd, shouldAddY);\n                }\n            }\n\n            if (targetNode && !skipElseBlock) { // route down and around any parent sibling elseif, else blocks\n                this.addRoutePointsDownAround(targetNode, targetNode, linkX, linkY, pointsToAdd, false);\n            }\n        }\n    };\n\n    FlowDiagramLayout.prototype.findParentDecisionBlock = function(node) {\n        var parentNode = this.getParentNode(node);\n        if (!parentNode) {\n            return false;\n        }\n        if (this.isDecisionBlock(parentNode)) {\n            return parentNode;\n        } else {\n            return this.findParentDecisionBlock(parentNode);\n        }\n    };\n\n    FlowDiagramLayout.prototype.hasParentDecisionBlock = function(node, onlyDirectParent) {\n        var parentNode = this.getParentNode(node);\n        if (!parentNode) {\n            return false;\n        }\n        if (this.isDecisionBlock(parentNode)) {\n            return true;\n        } else if (onlyDirectParent) {\n            return false;\n        } else {\n            return this.findParentDecisionBlock(parentNode);\n        }\n    };\n\n    // if source is inside DECISION block\n    // this method will set 2 route points\n    FlowDiagramLayout.prototype.routeDownAroundDecisionBranches = function(fromNode, pointsToAdd) {\n        var linkY = pointsToAdd[pointsToAdd.length - 1][1];\n        var linkX;\n        var parentDecisionNode = this.findParentDecisionBlock(fromNode);\n        if (parentDecisionNode) {\n            if (this.hasNextSiblingWithChildren(parentDecisionNode)) {\n                var makeADecisionNode = this.getParentNode(parentDecisionNode);\n                var decisionBranchGroupDim = this.getGroupDimensionByKey(parentDecisionNode) || this.getNodeDimension(parentDecisionNode);\n                var decisionGroupDim = this.getGroupDimensionByKey(makeADecisionNode.key) || this.getNodeDimension(makeADecisionNode);\n                if (decisionBranchGroupDim && decisionGroupDim) {\n                    linkX = decisionBranchGroupDim.x + decisionBranchGroupDim.width + LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n                    pointsToAdd.push([linkX, linkY]);\n                    linkY = decisionGroupDim.y + decisionGroupDim.height;\n                    pointsToAdd.push([linkX, linkY]);\n                }\n            }\n        }\n    };\n\n    // GoBackTo label position depends on all GoBackTo edges to have the same number of points\n    FlowDiagramLayout.prototype.addExtraRoutePoints = function(pointsToAdd) {\n        if (pointsToAdd.length < LAYOUT_CONFIGURATION.GOBACKTO_ROUTE_POINTS) {\n            while (pointsToAdd.length < LAYOUT_CONFIGURATION.GOBACKTO_ROUTE_POINTS) {\n                // add an extra of the last x,y points\n                pointsToAdd.push(pointsToAdd[pointsToAdd.length - 1]);\n            }\n        }\n    };\n\n    FlowDiagramLayout.prototype.calculateGoBackToEdgePoints = function(link, fromPosition, linkX, linkY) {\n        var pointsToAdd = [];\n        // add edge point on the RIGHT of node (at fromPort)\n        pointsToAdd.push([fromPosition.x, fromPosition.y]);\n        // add a RIGHT GAP (x-axis) point from GoBackTo source node\n        linkX = fromPosition.x + LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n        pointsToAdd.push([linkX, fromPosition.y]);\n\n        var linkXoriginal = linkX;\n        var largestSiblingBlockLinkX = 0;\n        var fromNode = link.fromNode;\n        var toNode = link.toNode;\n        var toNodeKey = toNode.data.key;\n        var largestSibKey = largestSibKey;\n        var largestSibNodeGroupDim;\n        var largestSibNode = toNode;\n\n        if (this.isStageNode(toNode) && this.stageNodeAssociatedMap[toNode.key]) {\n            toNodeKey = this.stageNodeAssociatedMap[toNode.key];\n            toNode = this._nodes.get(toNodeKey);\n        }\n\n        /*\n            Find largest group dimension width between siblings, starting with GOBACK TARGET to logic block that contains GOBACK SOURCE\n            this.targetSiblingMap[toNodeKey] - array of sibling nodes starting with Target to logic block that contains Source\n            Note: GOBACK edges should only merge when going back to same TARGET\n            edges that wrap around the same logic block (ie. SOURCE has same ANCESTOR) should be spaced appart\n        */\n        if (this.targetSiblingMap[toNodeKey]) {\n            var siblingKeys = this.targetSiblingMap[toNodeKey];\n            for (var i = 0; i < siblingKeys.length; i++) {\n                var sibKey = siblingKeys[i];\n                var sibNode = this._nodes.get(sibKey);\n                if (sibNode) {\n                    var sibNodeDimension = this.getNodeDimension(sibNode);\n                    var sibNodeGroupDim = this.getGroupDimensionByKey(sibKey) || sibNodeDimension;\n                    if (sibNodeGroupDim) {\n                        var sibx = sibNodeGroupDim.x || 0;\n                        var sibw = sibNodeGroupDim.width || 0;\n                        var sibX = sibx + sibw;\n                        if (sibX > largestSiblingBlockLinkX) {\n                            largestSiblingBlockLinkX = sibX;\n                            largestSibKey = sibKey;\n                            largestSibNodeGroupDim = sibNodeGroupDim;\n                            largestSibNode = sibNode;\n                        }\n                    }\n                }\n            }\n            // increase the group boundary to include the GOBACK edge around\n            if (this.isLogicBlockNode(largestSibNode)) {\n                if (largestSibKey && largestSibNodeGroupDim && !this.targetHasGoBackEdge[toNodeKey]) {\n                    largestSibNodeGroupDim.width += LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n                    largestSibNodeGroupDim.height += LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n                    largestSiblingBlockLinkX += LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n                    this.setGroupDimensionByKey(largestSibKey, largestSibNodeGroupDim);\n                    this.targetHasGoBackEdge[toNodeKey] = true;\n                }\n            }\n        }\n\n        var topParentNode = largestSibNode;\n        if (this.isDecisionNode(largestSibNode)) {\n            topParentNode = this.getParentNode(fromNode);\n        }\n        this.routeDownAroundSiblingElseBlocks(fromNode, fromPosition, linkX, pointsToAdd, topParentNode);\n        this.routeDownAroundDecisionBranches(fromNode, pointsToAdd);\n        this.addExtraRoutePoints(pointsToAdd);\n\n        linkX = pointsToAdd[pointsToAdd.length - 1][0];\n        linkY = pointsToAdd[pointsToAdd.length - 1][1];\n\n        // ADD THE x-axis HORIZONTAL GAP - based on GOBACK TARGET BLOCK\n        // point around the TARGET block\n        var toNodeDimension = this.getNodeDimension(largestSibNode);\n        var toNodeGroupDim = this.getGroupDimensionByKey(largestSibKey) || toNodeDimension || 0;\n        var linkXofLargestGroup = linkXoriginal;\n\n        // get group boundary of target (to) node, adjust edge x outside the boundary, set y to node y\n        if (toNodeGroupDim) {\n            linkXofLargestGroup = toNodeGroupDim.x + toNodeGroupDim.width;\n            if (this.isDecisionNode(largestSibNode)) {\n                linkXofLargestGroup += LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n            }\n            if (linkXofLargestGroup < largestSiblingBlockLinkX) {\n                linkXofLargestGroup = largestSiblingBlockLinkX;\n            }\n        }\n\n        // go outside group block X\n        if (linkXofLargestGroup) {\n            pointsToAdd.push([linkXofLargestGroup, linkY]);\n        } else {\n            pointsToAdd.push([linkX, linkY]);\n        }\n        return pointsToAdd;\n    };\n\n    FlowDiagramLayout.prototype.routeLinks = function(linksIntoResult, horizontalY, sortByOrder) {\n        var fromNodeBoundary;\n        var fromPortBoundary;\n        var toNodeBoundary;\n        var toPortBoundary;\n        var fromPosition;\n        var toPosition;\n        if (linksIntoResult.verticalLink) {\n            try {\n                fromNodeBoundary = linksIntoResult.verticalLink.fromNode.actualBounds;\n                fromPortBoundary = linksIntoResult.verticalLink.fromPort.actualBounds;\n                toNodeBoundary = linksIntoResult.verticalLink.toNode.actualBounds;\n                toPortBoundary = linksIntoResult.verticalLink.toPort.actualBounds;\n                if (\n                    fromNodeBoundary &&\n                    fromPortBoundary &&\n                    toNodeBoundary &&\n                    toPortBoundary\n                ) {\n                    var vpts = linksIntoResult.verticalLink.points.copy();\n                    vpts.clear();\n                    fromPosition = this.getBottomPosition(fromNodeBoundary, fromPortBoundary);\n                    toPosition = this.getTopPosition(toNodeBoundary, toPortBoundary);\n                    if (\n                        this.isFlowTriggerOrSubflowInputsOutputs(linksIntoResult.verticalLink.fromNode) ||\n                        this.isPathBroken(linksIntoResult.verticalLink.fromNode)\n                    ) {\n                        // Trigger and PathBroken nodes are special case because\n                        // their port size is incorrect. Should get it fixed!\n                        fromPosition.x = toPosition.x;\n                    }\n                    vpts.add(new go.Point(fromPosition.x, fromPosition.y));\n                    vpts.add(new go.Point(toPosition.x, toPosition.y));\n                    linksIntoResult.verticalLink.points = vpts;\n                }\n            } catch (error) {}\n        }\n        if (linksIntoResult.sideLink) {\n            try {\n                fromNodeBoundary = linksIntoResult.sideLink.fromNode.actualBounds;\n                fromPortBoundary = linksIntoResult.sideLink.fromPort.actualBounds;\n                toNodeBoundary = linksIntoResult.sideLink.toNode.actualBounds;\n                toPortBoundary = linksIntoResult.sideLink.toPort.actualBounds;\n                if (\n                    fromNodeBoundary &&\n                    fromPortBoundary &&\n                    toNodeBoundary &&\n                    toPortBoundary\n                ) {\n                    var spts = linksIntoResult.sideLink.points.copy();\n                    spts.clear();\n                    fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n                    toPosition = this.getTopPosition(toNodeBoundary, toPortBoundary);\n                    spts.add(new go.Point(fromPosition.x, fromPosition.y));\n                    spts.add(new go.Point(toPosition.x, fromPosition.y));\n                    spts.add(new go.Point(toPosition.x, toPosition.y));\n                    linksIntoResult.sideLink.points = spts;\n                }\n            } catch (error) {}\n        }\n        var customLinks = linksIntoResult.customLinks;\n        if (sortByOrder) {\n            customLinks = customLinks.sort(function(a, b) {\n                if (a.data.order > b.data.order) {\n                    return -1;\n                } else if (a.data.order < b.data.order) {\n                    return 1;\n                }\n                return 0;\n            });\n        }\n\n        var linkIt = customLinks.iterator;\n        var linkX;\n        var linkY;\n        while (linkIt.next()) {\n            var index = linkIt.key;\n            var link = linkIt.value;\n            if (link && link.fromNode) {\n                fromNodeBoundary = link.fromNode.actualBounds;\n                fromPortBoundary = link.fromPort.actualBounds;\n                toNodeBoundary = link.toNode.actualBounds;\n                toPortBoundary = link.toPort.actualBounds;\n                if (\n                    fromNodeBoundary &&\n                    fromPortBoundary &&\n                    toNodeBoundary &&\n                    toPortBoundary\n                ) {\n                    var pts = link.points.copy();\n                    pts.clear();\n                    if (this.isConditionalFalsePort(link.fromPortId) || this.isBreakPort(link.fromPortId)) {\n                        fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n                        pts.add(new go.Point(fromPosition.x, fromPosition.y));\n                        var groupDimension = this.getNodeDimension(link.fromNode);\n                        if (groupDimension) {\n                            linkX = groupDimension.x + groupDimension.width;\n                            pts.add(new go.Point(linkX, fromPosition.y));\n                        }\n                    } else if (this.isGoBackToOutputPort(link.fromPortId) && sortByOrder) {\n                        if (this.invalidBound(link.fromNode)) {\n                            return;\n                        } else {\n                            // set from node point (GOBACK source node)\n                            fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n                            linkY = fromPosition.y;\n\n                            var pointsToAdd = this.calculateGoBackToEdgePoints(link, fromPosition, linkX, linkY);\n                            this.addExtraRoutePoints(pointsToAdd);\n                            pointsToAdd.forEach(function(a, i) {\n                                pts.add(new go.Point(a[0], a[1]));\n                            });\n                            // update our x, y based on last points added\n                            linkX = pointsToAdd[pointsToAdd.length - 1][0];\n                            linkY = pointsToAdd[pointsToAdd.length - 1][1];\n                        }\n                    } else {\n                        fromPosition = this.getBottomPosition(fromNodeBoundary, fromPortBoundary);\n                        linkX = fromPosition.x;\n                        pts.add(new go.Point(linkX, fromPosition.y));\n                    }\n                    // parallel branch edges will all have the same y-axis\n                    if (horizontalY || this.isBreakNode(link.fromNode)) {\n                        linkY =\n                            toNodeBoundary.y - (customLinks.size) - LAYOUT_CONFIGURATION.EDGE_GAP - LAYOUT_CONFIGURATION.EDGE_GAP_LARGE;\n                    } else {\n                        linkY =\n                            toNodeBoundary.y - (customLinks.size - 1 - index) * LAYOUT_CONFIGURATION.EDGE_GAP - LAYOUT_CONFIGURATION.EDGE_GAP_LARGE;\n                    }\n                    pts.add(new go.Point(linkX, linkY));\n                    toPosition = this.getTopPosition(toNodeBoundary, toPortBoundary);\n                    pts.add(new go.Point(toPosition.x, linkY));\n                    pts.add(new go.Point(toPosition.x, toPosition.y));\n                    link.points = pts;\n                }\n            }\n        }\n    };\n\n    // traverse up till we find the sibling node of a parent\n    FlowDiagramLayout.prototype.findAllParents = function(node, parentList) {\n        if (!node) {\n            return parentList;\n        }\n\n        if (node.data.parent) {\n            parentList.push({\n                key: node.data.parent,\n                parentKey: node.data.parent\n            });\n        }\n        var parentNode = this._nodes.get(node.data.parent);\n        return this.findAllParents(parentNode, parentList);\n    };\n\n    // return additional x-axis spacing based on GOBACK targets inside the conditional block\n    FlowDiagramLayout.prototype.additionalGoBackEdgeSpacing = function(sourceNodeKey) {\n        // number of GOBACK targets inside the conditional block\n        var goBackAdditionalGap = 0;\n        if (sourceNodeKey) {\n            if (this.goBackToEdgesToProcess[sourceNodeKey]) {\n                var edgeCount = this.goBackToEdgesToProcess[sourceNodeKey];\n                goBackAdditionalGap = LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO * edgeCount;\n                // this is used to notify when children are done processing that boundary will need extra space for the GOBACK edge\n                this.additionalGoBackToWidth = goBackAdditionalGap;\n            }\n        }\n        return goBackAdditionalGap;\n    };\n\n    FlowDiagramLayout.prototype.updateBackLink = function(link, additional, isHorizontal) {\n        var GAP_ADDITIONAL = additional || 0;\n        if (this.invalidBound(link.fromNode) || this.invalidBound(link.toNode)) {\n            return;\n        }\n        var fromNodeBoundary = link.fromNode.actualBounds;\n        var fromPortBoundary = link.fromPort.actualBounds;\n        var toNodeBoundary = link.toNode.actualBounds;\n        var toPortBoundary = link.toPort.actualBounds;\n        var loopBoundary = this.getNodeDimension(link.toNode);\n        if (\n            fromNodeBoundary &&\n            fromPortBoundary &&\n            toNodeBoundary &&\n            toPortBoundary &&\n            loopBoundary\n        ) {\n            var pts = link.points.copy();\n            pts.clear();\n            var fromPosition = this.getBottomPosition(fromNodeBoundary, fromPortBoundary);\n            var yGap = LAYOUT_CONFIGURATION.EDGE_GAP;\n            if (isHorizontal) {\n                fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n                yGap = 0;\n            }\n            pts.add(new go.Point(fromPosition.x, fromPosition.y));\n            var linkY = fromPosition.y + yGap;\n            pts.add(new go.Point(fromPosition.x, linkY));\n            var linkX = loopBoundary.x + loopBoundary.width + GAP_ADDITIONAL;\n            pts.add(new go.Point(linkX, linkY));\n            var toPosition = this.getRightPosition(toNodeBoundary, toPortBoundary);\n            pts.add(new go.Point(linkX, toPosition.y));\n            pts.add(new go.Point(toPosition.x, toPosition.y));\n            link.points = pts;\n        }\n    };\n\n    FlowDiagramLayout.prototype.createContinueLink = function(link) {\n        if (this.invalidBound(link.fromNode) || this.invalidBound(link.toNode)) {\n            return;\n        }\n        var fromNodeBoundary = link.fromNode.actualBounds;\n        var fromPortBoundary = link.fromPort.actualBounds;\n        var toNodeBoundary = link.toNode.actualBounds;\n        var toPortBoundary = link.toPort.actualBounds;\n        var loopBoundary = this.getNodeDimension(link.toNode);\n        if (\n            fromNodeBoundary &&\n            fromPortBoundary &&\n            toNodeBoundary &&\n            toPortBoundary &&\n            loopBoundary\n        ) {\n            var pts = link.points.copy();\n            pts.clear();\n            fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n            var pointsToAdd = [];\n            //initial routing points\n            pointsToAdd.push([fromPosition.x, fromPosition.y]);\n            var linkX = fromPosition.x + LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n            pointsToAdd.push([linkX, fromPosition.y]);\n\n            //routing down from else-if, if or decision\n            this.routeDownAroundSiblingElseBlocks(link.fromNode, fromPosition, linkX, pointsToAdd, link.toNode);\n            this.routeDownAroundDecisionBranches(link.fromNode, pointsToAdd);\n            linkX = loopBoundary.x + loopBoundary.width;\n            var linkY = pointsToAdd[pointsToAdd.length - 1][1];\n            pointsToAdd.push([linkX, linkY]);\n\n            //final routing points\n            var toPosition = this.getRightPosition(toNodeBoundary, toPortBoundary);\n            pointsToAdd.push([linkX, toPosition.y]);\n            pointsToAdd.push([toPosition.x, toPosition.y]);\n            pointsToAdd.forEach(function(a, i) {\n                pts.add(new go.Point(a[0], a[1]));\n            });\n            link.points = pts;\n        }\n    };\n\n    FlowDiagramLayout.prototype.createBreakLink = function(link) {\n        if (this.invalidBound(link.fromNode) || this.invalidBound(link.toNode)) {\n            return;\n        }\n        var parentloopKey = link.fromNode.data.data.parent_loop.key;\n        var loopNode = this._nodes.get(parentloopKey);\n\n        var fromNodeBoundary = link.fromNode.actualBounds;\n        var fromPortBoundary = link.fromPort.actualBounds;\n        var toNodeBoundary = link.toNode.actualBounds;\n        var toPortBoundary = link.toPort.actualBounds;\n        var loopBoundary = this.getNodeDimension(loopNode);\n        if (\n            fromNodeBoundary &&\n            fromPortBoundary &&\n            toNodeBoundary &&\n            toPortBoundary &&\n            loopBoundary\n        ) {\n            var pts = link.points.copy();\n            pts.clear();\n            fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n            var pointsToAdd = [];\n            //initial routing points\n            pointsToAdd.push([fromPosition.x, fromPosition.y]);\n            var linkX = fromPosition.x + LAYOUT_CONFIGURATION.EDGE_GAP_GOBACKTO;\n            pointsToAdd.push([linkX, fromPosition.y]);\n\n            //routing down from else-if, if or decision\n            this.routeDownAroundSiblingElseBlocks(link.fromNode, fromPosition, linkX, pointsToAdd, link.toNode);\n            this.routeDownAroundDecisionBranches(link.fromNode, pointsToAdd);\n            var goBackAdditionalGap = this.additionalGoBackEdgeSpacing(parentloopKey);\n            linkX = loopBoundary.x + loopBoundary.width + LAYOUT_CONFIGURATION.EDGE_GAP + goBackAdditionalGap;\n            var linkY = pointsToAdd[pointsToAdd.length - 1][1];\n            pointsToAdd.push([linkX, linkY]);\n\n            //final routing points\n            var toPosition = this.getTopPosition(toNodeBoundary, toPortBoundary);\n            pointsToAdd.push([linkX, toPosition.y - LAYOUT_CONFIGURATION.EDGE_GAP - LAYOUT_CONFIGURATION.EDGE_GAP_LARGE]);\n            pointsToAdd.push([toPosition.x, toPosition.y - LAYOUT_CONFIGURATION.EDGE_GAP - LAYOUT_CONFIGURATION.EDGE_GAP_LARGE]);\n            pointsToAdd.push([toPosition.x, toPosition.y]);\n            pointsToAdd.forEach(function(a, i) {\n                pts.add(new go.Point(a[0], a[1]));\n            });\n            link.points = pts;\n        }\n    };\n\n    // Reverse traversal of node tree to assign additional widths to parent and previousSibling nodes\n    FlowDiagramLayout.prototype.setParentAdditionalXAxis = function(node, groupBoundaryWidth, nodeDimensionWidth) {\n        // look for parent first - if no parent, skip this entirely\n        var parentNodeKey = this.getRelation(node, \"parent\");\n        if (parentNodeKey) {\n            var parentNode = this._nodes.get(parentNodeKey);\n            if (parentNode && !this.isCatchNode(parentNode)) {\n                this.nodeCenterAlignAdditionalXAxisMap[parentNodeKey] = (groupBoundaryWidth / 2) - (nodeDimensionWidth / 2);\n                this.setParentAdditionalXAxis(parentNode, groupBoundaryWidth, nodeDimensionWidth);\n            }\n\n            // a sibling here would share the same parent\n            // ex. the \"false\" branch of a conditional node needs to adjust the width if there is a DoParallel in any\n            // the \"true\" children or any of the \"false\" siblings\n            var previousSiblingNodeKey = this.getRelation(node, \"previousSibling\");\n            var previousSiblingNode = this.diagram.findNodeForKey(previousSiblingNodeKey);\n            if (previousSiblingNode) {\n                this.nodeCenterAlignAdditionalXAxisMap[previousSiblingNodeKey] = (groupBoundaryWidth / 2) - (nodeDimensionWidth / 2);\n                var siblingNode = this._nodes.get(previousSiblingNodeKey);\n                if (siblingNode) {\n                    this.setParentAdditionalXAxis(siblingNode, groupBoundaryWidth, nodeDimensionWidth);\n                }\n            }\n        }\n    };\n\n    FlowDiagramLayout.prototype.adjustNextNodeYAxis = function(currNode, nextNode, y) {\n        var d = this.getNodeDimension(currNode) || currNode.actualBounds;\n        y = d.y + d.height + this.getLinkHeightToNode(nextNode, this.x);\n        return y;\n    };\n\n    // returns input node's first ancestor node that is either Parallel Block or Decision Block\n    FlowDiagramLayout.prototype.getAncestorBlockNode = function(node) {\n        if (node && node.data && node.data.parent) {\n            var currentNode = this._nodes.get(node.data.parent);\n            var previousKeys = {};\n            previousKeys[node.key] = true;\n            while (currentNode) {\n                if (previousKeys[currentNode.key])\n                    return null;\n                previousKeys[currentNode.key] = true;\n                if (this.isParallelBlock(currentNode) || this.isDecisionBlock(currentNode))\n                    return currentNode;\n                if (currentNode && currentNode.data && currentNode.data.parent) {\n                    currentNode = this._nodes.get(currentNode.data.parent);\n                } else {\n                    return null;\n                }\n            }\n        }\n        return null;\n    };\n\n    FlowDiagramLayout.prototype.moveNodeTo = function(node, x, y) {\n        if (node) {\n            // if the node is ENDIF node and there was a processing of nodes on ELSEIF or ELSE branch because\n            // of a stage node within the branch, then increase the y position of the ENDIF node because the node boundaries\n            // on the IF branch are calculated after the calculations in ELSEIF or ELSE branch which causes the ENDIF node's\n            // y position to be less than what is needed\n            if (this.isEndIf(node) && node.data && node.data[SOURCE_NODE_KEYS.SOURCE_IF] && this.ifWithElseIforElse[node.data[SOURCE_NODE_KEYS.SOURCE_IF]]) {\n                node.moveTo(x - node.actualBounds.width / 2, y + LAYOUT_CONFIGURATION.IF_WITH_ELSE_OR_ELSE_IF_OFFSET);\n            } else {\n                var newX = x - (node.actualBounds.width / 2);\n                // DEF0367718: instead of blindly moving the node, check if the position will actually change\n                // If x/y are both same, we would be asking the diagram to move the node to its same position, which somehow gets the node \"stuck\"\n                if (newX !== node.actualBounds.x || y !== node.actualBounds.y) {\n                    node.moveTo(newX, y);\n                }\n            }\n        }\n    };\n\n    // processes nextNode and possibly its siblings if it is a stage node\n    FlowDiagramLayout.prototype.processStageNodeOnIfElseIfOrElseLink = function(fromNode, nextNode, x, y) {\n        var result;\n        if (nextNode, fromNode, this.isStageNode(nextNode)) {\n            if (this.isIfNode(fromNode)) {\n                if (fromNode.data && fromNode.data.key) {\n                    this.ifWithElseIforElse[fromNode.data.key] = true;\n                }\n            } else if (this.isElseIfNode(fromNode)) {\n                var siblingNode = fromNode;\n                // iterate through previous sibling to reach if node\n                while (this.isElseIfNode(siblingNode)) {\n                    var previousSiblingNodeKey = this.getRelation(siblingNode, \"previousSibling\");\n                    if (previousSiblingNodeKey) {\n                        siblingNode = this._nodes.get(previousSiblingNodeKey);\n                    }\n                }\n                if (this.isIfNode(siblingNode)) {\n                    if (siblingNode.data && siblingNode.data.key) {\n                        this.ifWithElseIforElse[siblingNode.data.key] = true;\n                    }\n                }\n            }\n            result = this.processRootLevelNodes(nextNode, x, y);\n        }\n        return result;\n    };\n\n    FlowDiagramLayout.prototype.renderParallelBranch = function(link, parallelX, parallelY, boundaryWidth, groupBoundaryBegin, node, returnedNextNodeLoop, firstBranchX, lastBranchX) {\n        if (link) {\n            var index = this.getNodeIndex(link);\n            // each parallel block will start at the x-axis of the previous node boundary width\n            parallelX = this.calculateBlockXAxis(parallelX, boundaryWidth, index);\n            // if we have children ensure parent relation has been set\n            var toNode = link.toNode;\n            if (toNode && toNode.data) {\n                if (!toNode.data.relation) {\n                    toNode.data.relation = {};\n                }\n                toNode.data.relation.parent = node.data.key;\n            }\n            if (this.isStageNode(toNode) && this.stageNodeAssociatedMap[toNode.key]) {\n                var toNodeKey = this.stageNodeAssociatedMap[toNode.key];\n                toNode = this._nodes.get(toNodeKey);\n            }\n            // render parallel branch children\n            var result = this.renderChildrenHorizontal(parallelX, parallelY, link, groupBoundaryBegin);\n            // union with block dimension\n            var blockBoundary = this.getNodeDimension(toNode);\n            if (blockBoundary) {\n                var groupBoundaryBeginCopy = groupBoundaryBegin.copy();\n                groupBoundaryBegin = groupBoundaryBeginCopy.unionRect(blockBoundary);\n                // update width based on branch block width\n                boundaryWidth = blockBoundary.width;\n                // capture first and last branch x-axis so we can use to center\n                if (firstBranchX === 0) {\n                    firstBranchX = blockBoundary.x;\n                }\n                lastBranchX = blockBoundary.x;\n            }\n            // only attempt to grab the next node if we haven't already found the endParallel node\n            if (!this.isEndParallel(returnedNextNodeLoop) || !this.isEndDecision(returnedNextNodeLoop)) {\n                returnedNextNodeLoop = result.nextNode;\n            }\n        }\n        return {\n            parallelX: parallelX,\n            boundaryWidth: boundaryWidth,\n            groupBoundaryBegin: groupBoundaryBegin,\n            firstBranchX: firstBranchX,\n            lastBranchX: lastBranchX,\n            returnedNextNodeLoop: returnedNextNodeLoop\n        };\n    };\n\n    FlowDiagramLayout.prototype.getNextSiblingOutOfIf = function(node) {\n        if (this.isIfNode(node)) {\n            var nextSiblingId;\n            while (true) {\n                nextSiblingId = this.getRelation(node, \"nextSibling\");\n                if (!nextSiblingId) {\n                    break;\n                }\n                var nextSibling = this._nodes.get(nextSiblingId);\n                if (!nextSibling) {\n                    // hidden else node\n                    nextSiblingId =\n                        this._hiddenElseLinks.get(nextSiblingId).nextSibling;\n                    break;\n                } else {\n                    if (!this.isIfNode(nextSibling) && !this.isElseIfNode(nextSibling)) {\n                        break;\n                    }\n                }\n                node = nextSibling;\n            }\n            return nextSiblingId;\n        } else {\n            return this.getRelation(node, \"nextSibling\");\n        }\n    };\n\n    FlowDiagramLayout.prototype.renderSiblings = function(x, y, node) {\n        var nextNode = this.walk(node, x, y);\n        var boundary = this.getNodeDimension(node);\n\n        while (true) {\n            var nextSibling = this.getNextSiblingOutOfIf(node);\n            if (!nextNode || nextNode.data.key !== nextSibling) {\n                break;\n            }\n            node = nextNode;\n            var linkHeight = this.getLinkHeightToNode(node, x);\n            nextNode = this.walk(node, x, y + boundary.height + linkHeight);\n            boundary = boundary.unionRect(this.getNodeDimension(node));\n        }\n        return {\n            nextNode: nextNode,\n            boundary: boundary,\n        };\n    };\n\n    FlowDiagramLayout.prototype.moveStageNode = function(nextNextNode, nextNode) {\n        // moves nextNextNode if it ia stage node and nextNode is not invalidBound()\n        if (this.isStageNode(nextNextNode) && nextNode && nextNode.actualBounds && !this.invalidBound(nextNode)) {\n            var nextX = nextNode.actualBounds.x + LAYOUT_CONFIGURATION.NODE_GAP_HORIZONTAL_STAGE;\n            var nextY = nextNode.actualBounds.y + nextNode.actualBounds.height + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_WITH_LABEL;\n            nextNextNode.moveTo(nextX, nextY);\n        }\n    };\n\n    // only IF and ELSEIF can have sibling\n    FlowDiagramLayout.prototype.renderElseSibling = function(x, y, link, boundary) {\n        var fromNode = link.fromNode;\n        var nodeHeight = fromNode.actualBounds.height;\n        var nextNode = link.toNode;\n        this.updateStageNodeRelation(nextNode);\n        x += boundary.width + LAYOUT_CONFIGURATION.NODE_GAP_HORIZONTAL;\n        y += nodeHeight / 2 + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n        if (fromNode && this.nodeCenterAlignAdditionalXAxisMap[fromNode.data.key]) {\n            x -= this.nodeCenterAlignAdditionalXAxisMap[fromNode.data.key];\n        }\n        if (nextNode && this.nodeCenterAlignAdditionalXAxisMap[nextNode.data.key]) {\n            x += this.nodeCenterAlignAdditionalXAxisMap[nextNode.data.key];\n        }\n        var result;\n        if (this.isIfElseIfLink(link)) {\n            var nextNextNode = this.walk(nextNode, x, y);\n            this.updateStageNodeRelation(nextNextNode);\n            this.moveStageNode(nextNextNode, nextNode);\n            boundary = boundary.unionRect(this.getNodeDimension(nextNode));\n            nextNode = nextNextNode;\n            result = this.processStageNodeOnIfElseIfOrElseLink(fromNode, nextNode, x, y);\n            if (result) {\n                nextNode = result.nextNode;\n            }\n        } else if (this.isElseLink(link) || this.isCatchNodeWithChildren(link.fromNode)) {\n            result = this.renderSiblings(x, y, nextNode);\n            this.updateStageNodeRelation(result.nextNode);\n            if (result) {\n                this.moveStageNode(result.nextNode, nextNode);\n            }\n            boundary = boundary.unionRect(result.boundary);\n            nextNode = result.nextNode;\n            result = this.processStageNodeOnIfElseIfOrElseLink(fromNode, nextNode, x, y);\n            if (result) {\n                nextNode = result.nextNode;\n            }\n        } else {\n            boundary.width += LAYOUT_CONFIGURATION.EDGE_STICK_OUT_RIGHT;\n        }\n        return {\n            nextNode: nextNode,\n            boundary: boundary,\n        };\n    };\n\n    FlowDiagramLayout.prototype.isInCurrentChildren = function(currentChildren, prop) {\n        return prop && currentChildren.indexOf(prop) !== -1;\n    };\n\n    FlowDiagramLayout.prototype.isRelatedToCurrentChildren = function(nextNode, currentChildren) {\n        if (!nextNode || !currentChildren) {\n            return false;\n        }\n        if (this.isInCurrentChildren(currentChildren, nextNode.data.key)) {\n            return true;\n        }\n        var propsToCheck = [];\n        if (nextNode.data) {\n            propsToCheck.push(nextNode.data.endParallelNodeKey);\n            propsToCheck.push(nextNode.data.endDecisionNodeKey);\n            if (nextNode.data.relation) {\n                propsToCheck.push(nextNode.data.relation.parent);\n                propsToCheck.push(nextNode.data.relation.nextSibling);\n            }\n        }\n        for (var i = 0; i < propsToCheck.length; i++) {\n            if (this.isInCurrentChildren(currentChildren, propsToCheck[i])) {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    FlowDiagramLayout.prototype.isAssociatedStageNode = function(nextNode, stageNodeAssociatedMap, currentChildren) {\n        return this.isStageNode(nextNode) && currentChildren.indexOf(stageNodeAssociatedMap[nextNode.data.key]) !== -1;\n    };\n\n    FlowDiagramLayout.prototype.renderChildren = function(x, y, link, boundary) {\n        var currentChildren = this.getRelation(link.fromNode, \"children\", []);\n        var nextNode = link.toNode;\n        var linkHeight = this.getLinkHeight(link);\n        while (this.isRelatedToCurrentChildren(nextNode, currentChildren) ||\n            this.isAssociatedStageNode(nextNode, this.stageNodeAssociatedMap, currentChildren)) {\n            isOneToManyAndInner = this.isOneToManyFlowLogic(nextNode) && nextNode.data && nextNode.data.parent;\n            // x position will be properly adjusted if isOneToManyAndInner\n            var childY = y + boundary.height + linkHeight;\n            var nextNextNode = this.walk(\n                nextNode,\n                x,\n                childY,\n                isOneToManyAndInner && this.preprocessFlag\n            );\n            var nodeDim = this.getNodeDimension(nextNode);\n            boundary = boundary.unionRect(nodeDim);\n            // GOBACKTO edge was added so increase group width\n            if (this.additionalGoBackToWidth) {\n                var additionalWidth = this.additionalGoBackToWidth;\n                boundary.width += additionalWidth;\n                this.additionalGoBackToWidth = false;\n            }\n            nextNode = nextNextNode;\n            linkHeight = this.getLinkHeightToNode(nextNode, x);\n        }\n        return {\n            nextNode: nextNode,\n            boundary: boundary,\n        };\n    };\n\n    // Do the following in Parallel and Make a decision will render children horizontally\n    FlowDiagramLayout.prototype.renderChildrenHorizontal = function(x, y, link, boundary) {\n        var currentChildren = this.getRelation(link.fromNode, \"children\", []);\n        var nextNode = link.toNode;\n        var nextNextNode;\n        while (nextNode && (currentChildren.indexOf(nextNode.data.key) !== -1 ||\n                (this.isStageNode(nextNode) && currentChildren.indexOf(this.stageNodeAssociatedMap[nextNode.data.key]) !== -1))) {\n            if (nextNode.data.extraXOffset) {\n                x += nextNode.data.extraXOffset;\n                nextNode.data.extraXOffset = 0;\n            }\n            var nextBoundary;\n            if (this.isStageNode(nextNode)) {\n                var afterStageNode;\n                var stageDim = nextNode.actualBounds.copy();\n                y = y - LAYOUT_CONFIGURATION.STAGE_TOP_OFFSET;\n                afterStageNode = this.walk(\n                    nextNode,\n                    x,\n                    y\n                );\n                // adjust y-axis\n                y = y + stageDim.height + LAYOUT_CONFIGURATION.STAGE_VERTICAL_LINK;\n                nextNextNode = this.walk(\n                    afterStageNode,\n                    x,\n                    y\n                );\n                nextBoundary = this.getNodeDimension(afterStageNode);\n                boundary.width = nextBoundary.width;\n                nextNode = nextNextNode;\n            } else {\n                nextNextNode = this.walk(\n                    nextNode,\n                    x,\n                    y\n                );\n                nextBoundary = this.getNodeDimension(nextNode);\n                boundary.width = nextBoundary.width;\n                nextNode = nextNextNode;\n            }\n        }\n        // set the parallel block end edge height\n        boundary.height += LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n        return {\n            nextNode: nextNode,\n            boundary: boundary,\n        };\n    };\n\n    // capture sibling nodes between target and source, based on the parent level of target\n    // need this to determine the largest block need to calculate GOBACK source x\n    FlowDiagramLayout.prototype.recursiveCaptureSiblings = function(key, targetKey, lastKey) {\n        var node = this._nodes.get(key);\n        if (!key || !node || !targetKey) {\n            return;\n        }\n        // capture\n        if (!this.targetSiblingMap[targetKey]) {\n            this.targetSiblingMap[targetKey] = [];\n            // include target node\n            this.targetSiblingMap[targetKey].push(key);\n        }\n        // if we are at the source block then stop\n        if (key === lastKey) {\n            return;\n        }\n        if (node.data && node.data.relation && node.data.relation.nextSibling) {\n            var nextSiblingKey = node.data.relation.nextSibling;\n            if (!this.targetSiblingMap[targetKey].includes(nextSiblingKey)) {\n                this.targetSiblingMap[targetKey].push(nextSiblingKey);\n            }\n            return this.recursiveCaptureSiblings(nextSiblingKey, targetKey, lastKey);\n        }\n    };\n\n    // traverse up till we find the parent of GOBACK source node that matches the GOBACK target parent\n    FlowDiagramLayout.prototype.findSourceNodeParentMatchingTargetScope = function(node, parentKey) {\n        if (!node || !node.data) {\n            return \"\";\n        }\n\n        var nodeParent = node.data.parent;\n        if (nodeParent === parentKey && !this.isElseIfNode(node)) {\n            return node.data.key; // we found a sibling of parent\n        }\n        // check if parent is ELSE, if so set to previousSibling\n        var parentNode = this._nodes.get(nodeParent);\n        if (this._hiddenElseLinks.get(nodeParent) && !this.isIfNode(parentNode) && !this.isIfNode(node)) {\n            nodeParent = this._hiddenElseLinks.get(nodeParent).previousSibling;\n        }\n        if (this.isElseIfNode(node)) {\n            nodeParent = node.data.relation.previousSibling;\n        }\n        return this.findSourceNodeParentMatchingTargetScope(parentNode, parentKey);\n    };\n\n    // GOBACKTO we need to capture linksOutOf that go back to target node for later routing\n    FlowDiagramLayout.prototype.captureGoBackToEdges = function(node) {\n        var linkOutOf = node.findLinksOutOf();\n        while (linkOutOf.next()) {\n            var link = linkOutOf.value;\n            if (link && link.data && link.data.to) {\n                var toNode = this._nodes.get(link.data.to);\n                if (!toNode) { // handle if toNode is Stage\n                    if (this.stageNodeAssociatedMap[link.data.to]) {\n                        toNode = this._nodes.get(this.stageNodeAssociatedMap[link.data.to]);\n                    } else {\n                        return;\n                    }\n                }\n                // capture Target node order to sort edges desc so we can process bottom up\n                link.data.order = toNode.data.order;\n                this.goBackToFromLinks.add(link);\n            }\n        }\n    };\n\n    FlowDiagramLayout.prototype.captureBreakContinueEdges = function(node) {\n        var linkOutOf = node.findLinksOutOf();\n        while (linkOutOf.next()) {\n            var link = linkOutOf.value;\n            this.breakContinueFromLinks.add(link);\n        }\n    };\n\n    FlowDiagramLayout.prototype.processOneToManyNode = function(node, boundary, x, y, isPreprocess) {\n        // need to keep track when we have nested parallel nodes to properly do nested center alignment\n        this.nestedParallelCount += 1;\n        if (this.nestedParallelCount > 1 && this.parallelInfo[node.key]) {\n            this.parallelInfo[node.key].parentParallelKey = this.currentParallelNodeKey;\n        }\n        // PARALLEL BLOCK group dimensions should include their corresponding END node\n        this.enlargeGroupDimension(node);\n        var groupBoundaryBegin = boundary.copy();\n        var linkIt = node.findLinksOutOf();\n        var link;\n        var returnedNextNodeLoop;\n        // all parallel blocks will have the same y-axis\n        var parallelY = y + boundary.height + (this.isDecisionNode(node) ? LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_DECISION : LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_PARALLEL);\n        var parallelX = x;\n        var boundaryWidth = boundary.width;\n        var branchCount = 0;\n        var firstBranchX = 0;\n        var lastBranchX = 0;\n        var parallelNodeKey = node.data.key;\n        if (this.parallelMap[parallelNodeKey]) {\n            parallelX += this.parallelMap[parallelNodeKey].parallelX;\n        }\n        // Temperary workaround until fix add branch so nodes are added to end rather than beginning\n        var linkList = new go.List();\n        while (linkIt.next()) {\n            var linkToSort = linkIt.value;\n            linkList.add(linkToSort);\n        }\n        var linkItSorted = linkList.sort(function(a, b) {\n            // sort by arrayPosition rather than order, also handle StageType\n            return (a.toNode.data.arrayPosition || a.toNode.data.componentIndexes_value) - (b.toNode.data.arrayPosition || b.toNode.data.componentIndexes_value);\n        }).iterator;\n        branchCount = linkItSorted.count;\n        var endNode = null;\n        // process parallel branches\n        while (linkItSorted.next()) {\n            link = linkItSorted.value;\n            var results = this.renderParallelBranch(link, parallelX, parallelY, boundaryWidth, groupBoundaryBegin, node, returnedNextNodeLoop, firstBranchX, lastBranchX);\n            parallelX = results.parallelX;\n            boundaryWidth = results.boundaryWidth;\n            groupBoundaryBegin = results.groupBoundaryBegin;\n            firstBranchX = results.firstBranchX;\n            lastBranchX = results.lastBranchX;\n            returnedNextNodeLoop = results.returnedNextNodeLoop;\n\n            // If end node found, save it for later. Otherwise, this will be lost on next iteration\n            // Helps to address DEF0341349\n            if (this.isEndParallel(returnedNextNodeLoop) || this.isEndDecision(returnedNextNodeLoop)) {\n                endNode = returnedNextNodeLoop;\n            }\n        }\n        var groupBoundaryFinal = groupBoundaryBegin;\n        if (isPreprocess) {\n            // if we are pre-processing for center align\n            if (this.isCenterAlignEnabled(branchCount, node, this.parallelMap)) {\n                var currentX = '';\n                // DEF0344421: to adjust the x-axis when we have nested 1-to-many nodes\n                if (this.nestedParallelCount > 1) {\n                    currentX = firstBranchX;\n                    this.nestedParallelCount -= 1;\n                }\n                if (firstBranchX < 0) {\n                    currentX = '';\n                }\n                parallelX = this.calculateOneToManyCenterAlignOffset(firstBranchX, lastBranchX, currentX, this.x);\n                var nodeDim = this.getNodeDimension(node);\n                var groupBoundaryWidth = groupBoundaryFinal.width;\n                var nodeDimensionWidth = nodeDim.width;\n                var ancestorBlockNode = this.getAncestorBlockNode(node);\n                if (ancestorBlockNode && ancestorBlockNode.actualBounds) {\n                    // This will shift the ancestorBlockNode x coordinate based on the current parallel/decision's number of branches/children\n                    var parentBranchCount = 0;\n                    if (this.parallelInfo[node.key] && this.parallelInfo[node.key].parentParallelKey && this.parallelInfo[this.parallelInfo[node.key].parentParallelKey]) {\n                        parentBranchCount = this.parallelInfo[this.parallelInfo[node.key].parentParallelKey].count;\n                    }\n                    // This will shift the x coordinate based on the current parallel/decision's number of branches/children\n                    if (branchCount > 0 && nodeDimensionWidth > 0 && parentBranchCount > 1) {\n                        // Before shifting, check for an associated stage.\n                        var rootBlockNode;\n                        var associatedStageNodeData = this.diagram.model.nodeDataArray.find(function(node) {\n                            return node.associated_node_key === ancestorBlockNode.key;\n                        });\n                        if (associatedStageNodeData) {\n                            // If it exists, it is considered the true root of the block\n                            rootBlockNode = this._nodes.get(associatedStageNodeData.key);\n                        } else {\n                            // Otherwise, the ancestor is the true root of the block\n                            rootBlockNode = ancestorBlockNode;\n                        }\n                        rootBlockNode.data.extraXOffset = (branchCount - 1) * nodeDimensionWidth / 2;\n                    }\n                }\n                this.parallelMap[node.key] = {\n                    parallelX: parallelX\n                };\n\n                this.nodeCenterAlignAdditionalXAxisMap[node.key] = ((groupBoundaryWidth / 2) - (nodeDimensionWidth / 2));\n                this.setParentAdditionalXAxis(node, groupBoundaryWidth, nodeDimensionWidth);\n            }\n        } else {\n            // after we process the horizontal children (branches) then process ENDPARALLEL node\n            if (endNode) {\n                parallelY = groupBoundaryFinal.y + groupBoundaryFinal.height + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_WITH_LABEL;\n                endNode.moveTo(x, parallelY);\n                var nextNextNode = this.walk(endNode, x, parallelY);\n                var nextBoundary = this.getNodeDimension(endNode);\n                groupBoundaryFinal = groupBoundaryFinal.unionRect(nextBoundary);\n                returnedNextNodeLoop = nextNextNode;\n            } else {\n                // when there is no ENDPARALLEL (i.e. all branches have path broken) then\n                // calculate y based on DFIP starting y (groupBoundaryFinal.y) plus group height\n                // (groupBoundaryFinal.height)\n                parallelY = groupBoundaryFinal.y + groupBoundaryFinal.height;\n            }\n            // if next node is undefined then a path broken will be added\n            // we capture the coordinates in order to position the path broken with the ENDPARALLEL node\n            if (!returnedNextNodeLoop && this.endNodePathBrokenMap[parallelNodeKey]) {\n                this.pathBrokenNodeDimensions[this.endNodePathBrokenMap[parallelNodeKey]].x = x;\n                this.pathBrokenNodeDimensions[this.endNodePathBrokenMap[parallelNodeKey]].y = parallelY + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_PB;\n                groupBoundaryFinal.y = groupBoundaryFinal.y + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK_WITH_LABEL;\n            }\n        }\n        this.setGroupDimension(node, groupBoundaryFinal);\n        return returnedNextNodeLoop;\n    };\n\n    FlowDiagramLayout.prototype.processSimpleNode = function(node) {\n        linkIt = node.findLinksOutOf();\n        if (linkIt.next()) {\n            return linkIt.value.toNode;\n        } else {\n            return undefined;\n        }\n    };\n\n    FlowDiagramLayout.prototype.processConditionalNode = function(node, boundary, x, y) {\n        var groupBoundaryConditional = boundary;\n        var linkIt = node.findLinksOutOf();\n        var linkTrue, linkFalse;\n        while (linkIt.next()) {\n            var link = linkIt.value;\n            if (this.isConditionalTruePort(link.fromPortId)) {\n                linkTrue = link;\n            } else if (this.isConditionalFalsePort(link.fromPortId)) {\n                linkFalse = link;\n            }\n        }\n        var returnedNextNodeConditional;\n        if (linkTrue) {\n            var resultTrue = this.renderChildren(\n                x,\n                y,\n                linkTrue,\n                groupBoundaryConditional\n            );\n            groupBoundaryConditional = resultTrue.boundary;\n            returnedNextNodeConditional = resultTrue.nextNode;\n        }\n        if (linkFalse) {\n            var resultFalse = this.renderElseSibling(\n                x,\n                y,\n                linkFalse,\n                groupBoundaryConditional\n            );\n            groupBoundaryConditional = resultFalse.boundary;\n            if (!returnedNextNodeConditional)\n                returnedNextNodeConditional = resultFalse.nextNode;\n        }\n        this.setGroupDimension(node, groupBoundaryConditional);\n\n        // If this is for a path broken source node, store the coordinates\n        if (this.endNodePathBrokenMap[node.key]) {\n            var pathBrokenX = x;\n            this.pathBrokenNodeDimensions[this.endNodePathBrokenMap[node.key]].x = pathBrokenX;\n            var pathBrokenY = groupBoundaryConditional.y + groupBoundaryConditional.height + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n            this.pathBrokenNodeDimensions[this.endNodePathBrokenMap[node.key]].y = pathBrokenY;\n        }\n        return returnedNextNodeConditional;\n    };\n\n    FlowDiagramLayout.prototype.processBlockNode = function(node, boundary, x, y) {\n        var groupBoundaryLoop = boundary;\n        var linkIt = node.findLinksOutOf();\n        var linkLoop;\n        if (linkIt.next()) {\n            linkLoop = linkIt.value;\n        }\n        var returnedNextNodeLoop;\n        if (linkLoop) {\n            var result = this.renderChildren(\n                x,\n                y,\n                linkLoop,\n                groupBoundaryLoop\n            );\n            groupBoundaryLoop = result.boundary;\n            returnedNextNodeLoop = result.nextNode;\n        }\n        if (this.isDoLoopNode(node)) {\n            groupBoundaryLoop.width += LAYOUT_CONFIGURATION.EDGE_STICK_OUT_RIGHT * 2;\n        } else if (this.isLoopNode(node)) {\n            groupBoundaryLoop.width += LAYOUT_CONFIGURATION.EDGE_STICK_OUT_RIGHT;\n        }\n        this.setGroupDimension(node, groupBoundaryLoop);\n        // If this is for a path broken source node, store the coordinates\n        if (this.endNodePathBrokenMap[node.key]) {\n            this.pathBrokenNodeDimensions[this.endNodePathBrokenMap[node.key]].x = x;\n            this.pathBrokenNodeDimensions[this.endNodePathBrokenMap[node.key]].y = groupBoundaryLoop.y + groupBoundaryLoop.height + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n        }\n        return returnedNextNodeLoop;\n    };\n\n    FlowDiagramLayout.prototype.processContinueNode = function(node) {\n        var linkIt = node.findLinksOutOf();\n        var linkContinue;\n        while (linkIt.next()) {\n            var link = linkIt.value;\n            linkContinue = link;\n        }\n        if (linkContinue) {\n            if (this.invalidBound(linkContinue.fromNode) || this.invalidBound(linkContinue.toNode)) {\n                return;\n            }\n            var fromNodeBoundary = linkContinue.fromNode.actualBounds;\n            var fromPortBoundary = linkContinue.fromPort.actualBounds;\n            var toNodeBoundary = linkContinue.toNode.actualBounds;\n            var toPortBoundary = linkContinue.toPort.actualBounds;\n            if (\n                fromNodeBoundary &&\n                fromPortBoundary &&\n                toNodeBoundary &&\n                toPortBoundary\n            ) {\n                var pts = linkContinue.points.copy();\n                pts.clear();\n                var fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n                var toPosition = this.getRightPosition(toNodeBoundary, toPortBoundary);\n                var yGap = LAYOUT_CONFIGURATION.EDGE_GAP_LARGE;\n                pts.add(new go.Point(fromPosition.x, fromPosition.y));\n                pts.add(new go.Point(fromPosition.x + yGap, fromPosition.y));\n                pts.add(new go.Point(fromPosition.x + yGap, toPosition.y));\n                pts.add(new go.Point(toPosition.x, toPosition.y));\n                linkContinue.points = pts;\n            }\n        }\n        return undefined;\n    };\n\n    FlowDiagramLayout.prototype.processContinueNode = function(node) {\n        var linkIt = node.findLinksOutOf();\n        var linkContinue;\n        while (linkIt.next()) {\n            var link = linkIt.value;\n            linkContinue = link;\n        }\n        if (linkContinue) {\n            if (this.invalidBound(linkContinue.fromNode) || this.invalidBound(linkContinue.toNode)) {\n                return;\n            }\n            var fromNodeBoundary = linkContinue.fromNode.actualBounds;\n            var fromPortBoundary = linkContinue.fromPort.actualBounds;\n            var toNodeBoundary = linkContinue.toNode.actualBounds;\n            var toPortBoundary = linkContinue.toPort.actualBounds;\n            if (\n                fromNodeBoundary &&\n                fromPortBoundary &&\n                toNodeBoundary &&\n                toPortBoundary\n            ) {\n                var pts = linkContinue.points.copy();\n                pts.clear();\n                var fromPosition = this.getRightPosition(fromNodeBoundary, fromPortBoundary);\n                var toPosition = this.getRightPosition(toNodeBoundary, toPortBoundary);\n                var yGap = LAYOUT_CONFIGURATION.EDGE_GAP_LARGE;\n                pts.add(new go.Point(fromPosition.x, fromPosition.y));\n                pts.add(new go.Point(fromPosition.x + yGap, fromPosition.y));\n                pts.add(new go.Point(fromPosition.x + yGap, toPosition.y));\n                pts.add(new go.Point(toPosition.x, toPosition.y));\n                linkContinue.points = pts;\n            }\n        }\n        return undefined;\n    };\n\n    FlowDiagramLayout.prototype.processBreakContinueNode = function(linkIt) {\n        while (linkIt.next()) {\n            var link = linkIt.value;\n            if (this.isBreakNode(link.fromNode))\n                this.createBreakLink(link);\n            else\n                this.createContinueLink(link);\n        }\n        return undefined;\n    };\n\n    FlowDiagramLayout.prototype.processEndNode = function(node) {\n        var sourceNodeKey = this.getSourceNodeKey(node);\n        var goBackAdditionalGap = this.additionalGoBackEdgeSpacing(sourceNodeKey);\n        var renderLinkBackHorizontal = false;\n\n        // works for both ENDLOOP with 2 links of linkContinue and linkBack\n        // and ENDIF with 1 link of linkContinue\n        var linkIt = node.findLinksOutOf();\n        var linkContinue, linkBack;\n        while (linkIt.next()) {\n            var link = linkIt.value;\n            if (this.isLoopBackPort(link.toPortId)) {\n                if (this.isUntilLoopOutputPort(link.fromPortId)) {\n                    renderLinkBackHorizontal = true;\n                }\n                linkBack = link;\n            } else {\n                linkContinue = link;\n            }\n        }\n        if (linkBack) {\n            this.updateBackLink(linkBack, goBackAdditionalGap, renderLinkBackHorizontal);\n        }\n        // IF and LOOP group dimensions should include their corresponding END node\n        this.enlargeGroupDimension(node, goBackAdditionalGap);\n        if (linkContinue) {\n            return linkContinue.toNode;\n        } else {\n            return undefined;\n        }\n    };\n\n    // Post process certain links such as go back to and try catch since those rely on completed walks\n    FlowDiagramLayout.prototype.postProcessLinks = function(y, x) {\n        // Routing break continue links\n        var linksBrCo = this.breakContinueFromLinks;\n        var linkOutOfBrCo = linksBrCo.iterator;\n        this.processBreakContinueNode(linkOutOfBrCo);\n\n        // Routing go back to links\n        var links = this.goBackToFromLinks;\n        var linkOutOf = links.iterator;\n        var linksOutOfResult = this.categorizeLinksInto(linkOutOf, x);\n        this.routeLinks(linksOutOfResult, y, true);\n    };\n\n    FlowDiagramLayout.prototype.walk = function(node, x, y, isPreprocess) {\n        if (this._dimensions.has(node.data.key)) {\n            // the node has been visited\n            return;\n        }\n        var linkIt = node.findLinksInto();\n        var linksIntoResult = this.categorizeLinksInto(linkIt, x);\n        if (this.shouldUpdateNodeY(node, linksIntoResult, this.stageNodesMap)) {\n            y = this.updateNodeY(\n                linksIntoResult.verticalLink,\n                linksIntoResult.customLinks,\n                node,\n                y,\n                this.isGoBackToTargetNode(node)\n            );\n        }\n\n        if (!isPreprocess) {\n            this.moveNodeTo(node, x, y);\n        } else {\n            this.moveNodeTo(node, 0, 0);\n        }\n\n        if (!this.isDecisionBlock(node)) {\n            var isHorizontalY = this.isEndParallel(node) || this.isEndDecision(node);\n            this.routeLinks(linksIntoResult, isHorizontalY);\n        }\n        // keep track of current logic block in the case we hit a path broken\n        if (this.isGroupParentNode(node)) {\n            this.currentLogicBlockKeys.push(node.key);\n        }\n\n        var boundary = node.actualBounds.copy();\n        this.setNodeDimension(node, boundary);\n        var type = this.getNodeShapeType(node);\n        switch (type) {\n            case NODE_TYPES.SIMPLE:\n                return this.processSimpleNode(node);\n            case NODE_TYPES.CONDITIONAL:\n                return this.processConditionalNode(node, boundary, x, y);\n            case NODE_TYPES.BLOCK:\n                return this.processBlockNode(node, boundary, x, y);\n            case NODE_TYPES.END:\n                return this.processEndNode(node);\n            case NODE_TYPES.CONTINUE:\n                return this.processContinueNode(node);\n            case NODE_TYPES.ONE_TO_MANY:\n                return this.processOneToManyNode(node, boundary, x, y, isPreprocess);\n            case NODE_TYPES.GO_BACK_TO:\n                return undefined;\n            case NODE_TYPES.ADD_A_NODE:\n                return this.postProcessLinks(y, x);\n        }\n    };\n\n    // returns nextNode after the walk iteration has been exhausted\n    FlowDiagramLayout.prototype.processRootLevelNodes = function(nextNode, x, y) {\n        while (nextNode) {\n            var nextNextNode = this.walk(nextNode, x, y);\n            y = this.adjustNextNodeYAxis(nextNode, nextNextNode, y);\n            var linkIt = nextNode.findLinksOutOf();\n            if (this.isPathBrokenLoopNode(nextNode, linkIt.count)) {\n                y = y + LAYOUT_CONFIGURATION.HEIGHT_VERTICAL_LINK;\n            }\n            // check for path broken\n            if (!nextNextNode) {\n                var pathBrokenKey = this.endNodePathBrokenMap[nextNode.data.key];\n                if (!pathBrokenKey) {\n                    while (this.currentLogicBlockKeys.length && !pathBrokenKey) {\n                        pathBrokenKey = this.endNodePathBrokenMap[this.currentLogicBlockKeys.pop()];\n                    }\n                }\n                if (pathBrokenKey && this.pathBrokenNodeDimensions[pathBrokenKey] &&\n                    !isNaN(this.pathBrokenNodeDimensions[pathBrokenKey].x) &&\n                    !isNaN(this.pathBrokenNodeDimensions[pathBrokenKey].y)) {\n                    nextNextNode = this._nodes.get(pathBrokenKey);\n                    x = this.pathBrokenNodeDimensions[pathBrokenKey].x;\n                    y = this.pathBrokenNodeDimensions[pathBrokenKey].y;\n                    // clear logic block key\n                    this.currentLogicBlockKeys = [];\n                }\n            }\n            // check for last node (Add a node)\n            if (!nextNextNode) {\n                if (!this._dimensions.has(this.end.data.key)) {\n                    nextNextNode = this.end;\n                }\n            }\n            nextNode = nextNextNode;\n        }\n        return {\n            nextNode: nextNode,\n            x: x,\n            y: y\n        };\n    };\n\n    // if we have PARALLEL (1-to-many) nodes then pre-walk to calculate each branch dimensions to determine center alignment\n    FlowDiagramLayout.prototype.preprocessParallelNodes = function(parallelNodes) {\n        this.preprocessFlag = true;\n        var parallelIt = parallelNodes.iterator;\n        if (this.isCenterAlignEnabled()) {\n            while (parallelIt.next()) {\n                var node = parallelIt.value;\n                this.currentParallelNodeKey = node.data.key;\n                this.walk(node, 0, 0, this.preprocessFlag);\n                this.nestedParallelCount = 0;\n            }\n            this._dimensions.clear();\n        }\n        this.currentParallelNodeKey = '';\n        this.preprocessFlag = false;\n    };\n\n    //pre-process go-back targets - find siblings between target and source\n    FlowDiagramLayout.prototype.preprocessGoBackTo = function() {\n        var targetIt = this.goBackToTargetNodes.iterator;\n        while (targetIt.next()) {\n            var targetNodekey = targetIt.value || \"\";\n            var sourceNodeKey = this.goBackToTargetMap[targetNodekey];\n            var targetNode = this._nodes.get(targetNodekey);\n            var sourceNode = this._nodes.get(sourceNodeKey);\n            if (targetNode) {\n                var targetNodeData = targetNode.data || {};\n                // find source parent that matches target parent level\n                var targetNodeParentKey = targetNodeData.parent || \"\";\n                var sourceParentKey = this.findSourceNodeParentMatchingTargetScope(sourceNode, targetNodeParentKey);\n                this.recursiveCaptureSiblings(targetNodekey, targetNodekey, sourceParentKey);\n                if (sourceNodeKey && !this.goBackToNodeToTopParentMap[sourceNodeKey]) {\n                    this.goBackToNodeToTopParentMap[sourceNodeKey] = sourceParentKey;\n                    // capture counts of targets within a parent logic block\n                    if (!this.goBackToEdgesToProcess[sourceParentKey]) {\n                        this.goBackToEdgesToProcess[sourceParentKey] = 1;\n                    } else {\n                        this.goBackToEdgesToProcess[sourceParentKey] = this.goBackToEdgesToProcess[sourceParentKey] + 1;\n                    }\n                }\n            }\n        }\n    };\n\n    // initial traverse of nodes to find trigger, end node, path broken, hidden else, stage, and parallel nodes\n    FlowDiagramLayout.prototype.preprocessNodes = function(nodes, parallelNodes) {\n        var it = nodes.iterator;\n        var currNodeKey;\n        while (it.next()) {\n            var node = it.value;\n            currNodeKey = node.key;\n            this._nodes.set(node.key, node);\n            this._hiddenElseLinks.remove(node.key);\n            if (this.isFlowTriggerOrSubflowInputsOutputs(node)) {\n                this.trigger = node;\n            } else if (this.isFlowEnd(node)) {\n                this.end = node;\n            } else if (this.isPathBroken(node)) {\n                if (node.data && node.data.key) {\n                    this.pathBrokenNodeDimensions[node.data.key] = {};\n                    // Store the key of the source node that caused this path broken\n                    var sourceKey = this.findPathBrokenSourceNodeKey(node);\n                    this.endNodePathBrokenMap[sourceKey] = node.data.key;\n                }\n            } else if (this.isOneToManyFlowLogic(node) && !this.isEndDoLoop(node)) {\n                parallelNodes.add(node);\n                var linkIt = node.findLinksOutOf();\n                var branchCnt = linkIt.count;\n                this.parallelInfo[node.key] = {\n                    count: branchCnt,\n                    name: node.data.name,\n                    parentParallelKey: ''\n                };\n            } else if (this.isStageNode(node)) {\n                if (node.data && node.data.key && node.data.associated_node_key) {\n                    this.stageNodesMap[node.data.associated_node_key] = node.data.key;\n                    this.stageNodeAssociatedMap[node.data.key] = node.data.associated_node_key;\n                }\n            } else if (this.isParallelBlock(node) || this.isDecisionBlock(node)) {\n                // DEF0323375: incremental updates causes issue with parallel branches alignment because nodes have preset actualBounds\n                // DEF0367718: this may not be needed anymore (see moveNodeTo function)\n                node.moveTo(0, 0);\n            } else if (this.isGoBackToNode(node)) {\n                node.moveTo(0, 0);\n                if (node.data && node.data.data && node.data.data.go_back_to_step) {\n                    var targetKey = node.data.data.go_back_to_step;\n                    this.goBackToTargetMap[targetKey] = node.data.key;\n                    this.goBackToTargetNodes.add(targetKey);\n                }\n                this.captureGoBackToEdges(node);\n            } else if (this.isContinueNode(node) || this.isBreakNode(node)) {\n                node.moveTo(0, 0);\n                this.captureBreakContinueEdges(node);\n            }\n            // ex. IF, ELSEIF\n            var nextSiblingId = this.getRelation(node, \"nextSibling\");\n            if (nextSiblingId && !this._nodes.has(nextSiblingId)) {\n                // nextSibling is a hidden ELSE node\n                if (!this._hiddenElseLinks.has(nextSiblingId)) {\n                    this._hiddenElseLinks.set(nextSiblingId, {});\n                }\n                this._hiddenElseLinks.get(nextSiblingId).key = nextSiblingId;\n                this._hiddenElseLinks.get(nextSiblingId).previousSibling = node.data.key;\n            }\n            var previousSiblingId = this.getRelation(node, \"previousSibling\");\n            if (previousSiblingId && !this._nodes.has(previousSiblingId)) {\n                // previousSibling is a hidden ELSE node\n                if (!this._hiddenElseLinks.has(previousSiblingId)) {\n                    this._hiddenElseLinks.set(previousSiblingId, {});\n                }\n                var elseNode = this._hiddenElseLinks.get(previousSiblingId);\n                elseNode.key = previousSiblingId;\n                elseNode.nextSibling = node.data.key;\n                if (this.isEndIf(node) || this.isPathBroken(node)) {\n                    elseNode.parent = node.data.sourceIfNodeKey; // set the parent IF node for the hidden else\n                }\n            }\n            var parentId = this.getRelation(node, \"parent\");\n            // if parent is ELSE capture children\n            if (parentId && this._hiddenElseLinks.has(parentId)) {\n                if (!this._hiddenElseLinks.get(parentId).children) {\n                    this._hiddenElseLinks.get(parentId).children = [];\n                }\n                this._hiddenElseLinks.get(parentId).children.push(node.data.key);\n            }\n        }\n        this.lastNodeKey = currNodeKey;\n    };\n\n    FlowDiagramLayout.prototype.getNodesAsList = function(nodes) {\n        var nodeList = new go.List();\n        var nodesIt = nodes.iterator;\n        while (nodesIt.next()) {\n            var nodeToSort = nodesIt.value;\n            nodeList.add(nodeToSort);\n        }\n        return nodeList;\n    };\n\n    FlowDiagramLayout.prototype.sortByStage = function(nodeList) {\n        var sortedNodes = nodeList.sort(function(a, b) {\n            if (!a.data || !a.data.instanceType) {\n                return 0;\n            }\n            if (a.data.instanceType === INSTANCE_TYPES.STAGE_TYPE) {\n                return -1;\n            }\n            return 0;\n        });\n        return sortedNodes;\n    };\n\n    FlowDiagramLayout.prototype.sortNodesByStageInstance = function(nodes) {\n        var nodeList = this.getNodesAsList(nodes);\n        return this.sortByStage(nodeList);\n    };\n\n    //  CUSTOM LAYOUT LOGIC\n    FlowDiagramLayout.prototype.doLayout = function() {\n\n        try {\n            if (!this.diagram) {\n                return;\n            }\n            this._resetMapData();\n            var nodes = this.diagram.nodes;\n            var parallelNodes = new go.List();\n\n            this.trigger;\n            this.end;\n            this.lastNodeKey = '';\n            this.parallelMap = {};\n            this.parallelInfo = {};\n            this.preprocessFlag = true;\n            this.nestedParallelCount = 0;\n            this.currentParallelNodeKey = '';\n            this.nodeCenterAlignAdditionalXAxisMap = {};\n            this.endNodePathBrokenMap = {};\n            this.pathBrokenNodeDimensions = {};\n            this.stageNodesMap = {};\n            this.stageNodeAssociatedMap = {};\n            this.ifWithElseIforElse = {};\n            this.goBackToTargetMap = {};\n            this.goBackToNodeToTopParentMap = {};\n            this.goBackToFromLinks = new go.List();\n            this.goBackToTargetNodes = new go.List();\n            this.targetSiblingMap = {};\n            this.goBackToEdgesToProcess = {};\n            this.additionalGoBackToWidth = false;\n            this.targetHasGoBackEdge = {};\n            this.currentLogicBlockKeys = [];\n            this.breakContinueFromLinks = new go.List();\n\n            // DEF0396233: in preprocessing nodes goback needs to know about any stage nodes associated with the target node\n            // incremental updates can add Stage node at the end of the list which is causing the issue\n            var sortedNodes = this.sortNodesByStageInstance(nodes);\n\n            // find trigger, end nodes, capture hidden else, path broken, stage relations, and parallel node details\n            this.preprocessNodes(sortedNodes, parallelNodes);\n\n            // couldn't find a trigger node or an end node\n            if (!this.trigger || !this.end) {\n                return;\n            }\n\n            this.diagram.startTransaction(\"Flow Diagram Layout\");\n            // start on the left, at Layout.arrangementOrigin\n            this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n            this.x = this.arrangementOrigin.x;\n            this.y = this.arrangementOrigin.y;\n\n            //pre-process go-back targets to capture siblings between target and source\n            this.preprocessGoBackTo();\n\n            // pre-process any 1-to-many nodes to calculate center alignment\n            this.preprocessParallelNodes(parallelNodes);\n\n            // iterate nodes and walk each one\n            this.processRootLevelNodes(this.trigger, this.x, this.y);\n\n            this.diagram.commitTransaction(\"Flow Diagram Layout\");\n            this._resetMapData();\n        } catch (e) {\n            console.error(\"Failed to Execute Layout Logic: \", e);\n        }\n    };\n\n    return $(FlowDiagramLayout);\n}","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/a4f5f4d7ca80209b2a32be23119ae821","value":"a4f5f4d7ca80209b2a32be23119ae821"},"sys_update_name":"sn_diagram_builder_configuration_f7052724c3d030101099006c2840dd80","left_panel":"false","enable_dragging":"false","name":"Flow Diagram","header":"false","left_component":"","sys_policy":""}]}