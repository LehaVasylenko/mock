{"result":[{"default_height":"","version_container_id":"","access":"public","description":"The Change Approval Policy activity can create group and user approvals according to the associated Change Approval Policy record. Using the current Change Request and any other inputs defined in the Policy Input script field the activity can evaluate the Change Approval Policy record and apply the corresponding Answer's for each matching Decision.\r\n\r\nAny rejection to an approval generated by this activity will result in the Rejected transition.\r\n\r\nIf no Decisions are matched from the Change Approval Policy then the result of this activity will be Approved.\r\n\r\nThe Answer's associated to each Decision record from the Change Approval Policy dictate the behavior of the approval.\r\n\r\nThe following items are the configurable fields for a Change Approval Definition (Answer).\r\n\r\n* Approval Action\r\n    * Approve: add an approved Approval record for the current Change Request for the specified User\r\n    * Reject: add a rejected Approval record for the current Change Request for the specified User\r\n    * Add a user approval: add an Approval for the current Change Request for the specified User\r\n    * Add a group approval: add a Group Approval for the current Change Request for the specified Group\r\n\r\n* Approver Source\r\n    * Approval Definition: derive the approver from the Change Approval Definition record, either the User or Group field according to the Approval Action\r\n    * Change Request: derive the approver from a field on the Change Request record, either the User field or Group field according to the Approval Action\r\n\r\n* Mandatory (Does not apply to the Approve and Reject Approval Actions)\r\n    * True: whilst there are no rejections for the current activity, the activity will wait until a response is received for the generated Approval(s)\r\n    * False: response for the generated Approval(s) is not required in the event that there is an approval\r\n\r\n* Wait for (Applies to Group Approvals)\r\n    * First response: the first member of the group to approve will mean the group approval is approved\r\n    * All responses: every member of the group must approve to set the group approval as approved\r\n\r\nKeep in mind: \r\n* This activity contains script fields. Do not use the 'current.update()' method in these script fields because it may cause recursive updates to the current record\r\n* If the associated Change Approval Policy cannot be resolved or is inactive then the result of this activity will be Rejected","sys_updated_on":"2018-10-26 08:20:42","sys_class_name":"wf_activity_definition","sys_id":"08ffb1f1730123008ef62d2b04f6a743","sys_updated_by":"admin","sys_created_on":"2018-10-10 07:27:17","action":"false","sys_name":"Change Approval Policy","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"change_request","image":"","default_width":"","base_provider":"","sys_mod_count":"122","sys_tags":"","script":"var Change_Approval_PolicyActivityHandler = Class.create();\nChange_Approval_PolicyActivityHandler.prototype = Object.extendsObject(global.ChangePolicyApprovalActivity, {\n\n\tinitialize: function() {\n\t\tglobal.ChangePolicyApprovalActivity.prototype.initialize.call(this, current, gs, activity, context, workflow);\n\t},\n\n\ttype: \"Change_Approval_PolicyActivityHandler\"\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/463c67f704352210559073c06a02f76b","value":"463c67f704352210559073c06a02f76b"},"sys_update_name":"wf_activity_definition_08ffb1f1730123008ef62d2b04f6a743","js_class_name":"Change_Approval_Policy","name":"Change Approval Policy","attributes":"generate=approval,approval=true","style":"","category":"Change Policy","sys_policy":"read"},{"default_height":"","version_container_id":"","access":"","description":"The Notification activity sends an email or SMS message to specified users or to all members of a group.\r\n\r\n The activity state tells the workflow engine how to handle the record being executed.  Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n","sys_updated_on":"2014-10-23 17:38:38","sys_class_name":"wf_activity_definition","sys_id":"0a6c97790a0a0b2756919eb960284334","sys_updated_by":"harry.nelson","sys_created_on":"2008-08-28 17:47:52","action":"false","sys_name":"Notification","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/notification.png","default_width":"","base_provider":"","sys_mod_count":"21","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar NotificationActivityHandler = Class.create();\nNotificationActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      var to = this._getToIds();\n      gs.eventQueue(\"workflow.notification\", current, activity.activity + \",\" + activity.context, to.join(','));\n   },\n   \n   _getToIds: function() {\n      return this._getIds(activity.vars.email_to, activity.vars.email_to_group, activity.vars.email_to_script);\n   },\n   \n   _getIds: function(users, groups, script) {\n      var users = users + '';\n      var groups = groups + '';\n      var script = script + '';\n      var ids = {};\n      \n      // users\n      if (users) {\n         var users = (users + \"\").split(',');\n         for (var i = 0; i < users.length; i++)\n            ids[users[i]] = true;\n      }\n      \n      // groups\n      if (groups) {\n         var groups = (groups + \"\").split(',');\n         for (var i = 0; i < groups.length; i++)\n            ids[groups[i]] = true;\n      }\n      \n      // is there a script?\n      this._addScriptedUsers(ids);\n      \n      // return an array\n      var ret = [];\n      for (var id in ids)\n         ret.push(id);\n      \n      return ret;\n   },\n   \n   _addScriptedUsers: function(ids) {\n      if (!activity.vars.advanced)\n         return;\n      \n      var script = activity.vars.email_to_script + '';\n      if (!script)\n         return;\n      \n      var answer = this.runScript(script);\n      if (answer) {\n      \t answer = answer.toString();\n         var users = answer.split(',');\n         for (var i = 0; i < users.length; i++)\n            ids[users[i]] = true;\n      }\n   },\n   \n   type: 'NotificationActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_0a6c97790a0a0b2756919eb960284334","js_class_name":"Notification","name":"Notification","attributes":"","style":"","category":"Notifications","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Set Values activity sets the value of any field on the current record. \r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n \r\nKeep in mind: \r\n*Using the Set Values activity to set the 'Approval' field on a task does not cancel pending approvals. To approve a task in a workflow, use the Approval Action activity.","sys_updated_on":"2014-10-22 17:59:47","sys_class_name":"wf_activity_definition","sys_id":"1ca8d7cf0a0a0b265e9a000c2c08248c","sys_updated_by":"harry.nelson","sys_created_on":"2008-10-20 23:51:52","action":"false","sys_name":"Set Values","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/set_value.png","default_width":"","base_provider":"","sys_mod_count":"7","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Set_ValuesActivityHandler = Class.create();\nSet_ValuesActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      var values = this.js(activity.vars.values + '');\n      if (values)\n         current.applyEncodedQuery(values);      \n   },\n\n   type: 'Set_ValuesActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_1ca8d7cf0a0a0b265e9a000c2c08248c","js_class_name":"Set_Values","name":"Set Values","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Approval Coordinator activity is a container for one or more Approval - User, Approval - Group, and Manual Approval activities.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nThe result value of the Approval Coordinator activity depends on the actions taken by the approvers and the conditions specified in the 'Wait for' field. Possible result values are:\r\n*Approved\r\n*Rejected\r\n*Deleted\r\n*Cancelled\r\n\r\nKeep in mind: \r\n*When the Approval Coordinator activity completes, the activity sets all pending approvals created by any of the Approval Coordinator's child activities to No Longer Required. \r\n*If a single user receives multiple approval requests in the same workflow, such as when a user is both a product approver and an executive approver, the workflow skips any approvals for that user after the first.","sys_updated_on":"2018-01-14 03:53:57","sys_class_name":"wf_activity_definition","sys_id":"283e8bb80a2581021d036a052ffc3433","sys_updated_by":"harry.nelson","sys_created_on":"2008-10-23 05:48:11","action":"false","sys_name":"Approval Coordinator","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task","image":"images/heisenberg_icons/workflow/approval_coordinator.png","default_width":"","base_provider":"","sys_mod_count":"91","sys_tags":"","script":"/**\n * The Approval Coordinator watches group and user child approval activities.\n */\n/* global WFActivityHandler, WorkflowApprovalUtils, workflow, activity, current, gs, GlideRecord */\n/* eslint-disable strict, eqeqeq, dot-notation, quotes */\nvar Approval_CoordinatorActivityHandler = Class.create();\nApproval_CoordinatorActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n\tDETERMINE_APPROVAL_STATE_EVENT: \"determineApprovalState\",\n\n\tinitialize: function() {\n\t\tWFActivityHandler.prototype.initialize.call(this);\n\t\tthis.approvalUtils = new WorkflowApprovalUtils();\n\t},\n\n\tonExecute: function() {\n\t\tvar approvalIds = this._removeGroupDuplicates();\n\t\tthis.approvalUtils.setGroupApprovalsByIds(approvalIds, 'requested', '', [ 'not requested', 'rejected', 'not_required' ]);\n\t\tapprovalIds = this._removeUserDuplicates();\n\t\tthis.approvalUtils.setUserApprovalsByIds(approvalIds, 'requested', '', [ 'not requested', 'rejected', 'not_required' ]);\n\n\t\tactivity.state = 'waiting';\n\t\t// only now that we have all of our child approvals created can we ask the children\n\t\t// to determine their state, and subsequently our state.  We have to do this AFTER\n\t\t// all of the children have created their approvals since we handle the duplicate removals\n\t\t// and removing duplicates can impact their approval state.\n\t\tworkflow.registerForEvent(this.DETERMINE_APPROVAL_STATE_EVENT);\n\t\tworkflow.fireEvent(this.DETERMINE_APPROVAL_STATE_EVENT);\n\t\tworkflow.unregisterForEvent(this.DETERMINE_APPROVAL_STATE_EVENT);\n\t},\n\n\tonDetermineApprovalState: function() {\n\t\t// our children have finished, determine our overall state now\n\t\tthis.determineState();\n\t},\n\n\t// See if we are done\n\tonUpdate: function() {\n\t\tthis.determineState();\n\t},\n\n\t/**\n\t * Create the approvals as a forward-looking process in which we just create, but do not\n\t * process the approvals. This allows the approvals to be generated up front before the\n\t * workflow runs such that the approvals are visible prior to being requested.\n\t */\n\t_generate: function(approvalOrder, startAt, noCreateFlag) {\n\t\tif (noCreateFlag)\n\t\t\treturn;\n\n\t\tthis._removeGroupDuplicates();\n\t\tthis._removeUserDuplicates();\n\t},\n\n\tdetermineState: function() {\n\t\tif (current.approval == 'cancelled') {\n\t\t\tactivity.state = 'finished';\n\t\t\tactivity.result = 'cancelled';\n\t\t\treturn;\n\t\t}\n\n\t\tvar state = this._determineOverallState();\n\t\tif (state == 'skipped') {\n\t\t\tactivity.state = 'finished';\n\t\t\tactivity.result = state;\n\t\t} else if ((state == 'approved') || (state == 'rejected')) {\n\t\t\tvar ids = this._getAMGroupApprovalIds();\n\t\t\tif (ids.length > 0)\n\t\t\t\tthis.approvalUtils.setPendingGroupApprovalsByIds(ids, 'not_required');\n\n\t\t\tids = this._getAMUserApprovalIds();\n\t\t\tif (ids.length > 0)\n\t\t\t\tthis.approvalUtils.setPendingUserApprovalsByIds(ids, 'not_required');\n\n\t\t\tactivity.state = 'finished';\n\t\t\tactivity.result = state;\n\t\t}\n\t},\n\n\t// The approval coordinator was cancelled\n\tonCancel: function() {\n\t\tvar ids = this._getAMGroupApprovalIds();\n\t\tif (ids.length > 0)\n\t\t\tthis.approvalUtils.setPendingGroupApprovalsByIds(ids, 'cancelled');\n\n\t\tids = this._getAMUserApprovalIds();\n\t\tif (ids.length > 0)\n\t\t\tthis.approvalUtils.setPendingUserApprovalsByIds(ids, 'cancelled');\n\n\t\tactivity.state = 'cancelled';\n\t\tactivity.result = 'cancelled';\n\t},\n\n\t// Determine the overall state of the approvals (approved, rejected or '')\n\t_determineOverallState: function() {\n\t\tvar counts = this._getChildTaskResults();\n\t\tvar waitFor = activity.vars.wait_for;\n\t\tif (waitFor == 'script') {\n\t\t\tif (!activity.vars.approval_script)\n\t\t\t\treturn 'approved';\n\n\t\t\t// Set up information to be passed to the script\n\t\t\t// overall counts\n\t\t\tworkflow.prepareScriptVariable('counts', counts);\n\t\t\tvar state = this.runScript(activity.vars.approval_script);\n\t\t\tworkflow.removeScriptVariable('counts');\n\t\t\treturn state;\n\t\t}\n\n\t\t// Overall state\n\t\tvar rejectHandling = activity.vars.reject_handling;\n\t\tif (counts['total'] == 0)\n\t\t\treturn 'skipped';\n\n\t\tif ((counts['rejected'] > 0) && (rejectHandling == 'reject'))\n\t\t\treturn 'rejected';\n\n\t\tif ((waitFor == 'any' || waitFor == 'first_any') && (counts['approved'] > 0))\n\t\t\treturn 'approved';\n\n\t\tif ((waitFor == 'first_any') && (counts['rejected'] > 0))\n\t\t\treturn 'rejected';\n\n\t\tif ((waitFor == 'all') && (counts['approved'] == counts['total']))\n\t\t\treturn 'approved';\n\n\t\tif ((counts['rejected'] + counts['approved']) == counts['total'])\n\t\t\treturn 'rejected'; // we are complete - we have to make a decision\n\n\t\treturn '';\n\t},\n\n\t_getAMGroupApprovalIds: function() {\n\t\tvar ids = [];\n\t\tvar approvals = this.approvalUtils.getGroupApprovalsByApprovalManager(current.sys_id, activity.activity.sys_id);\n\t\tfor (var id in approvals)\n\t\t\tids.push(id);\n\n\t\treturn ids;\n\t},\n\n\t_getAMUserApprovalIds: function() {\n\t\tvar ids = [];\n\t\tvar approvals = this.approvalUtils.getUserApprovalsByApprovalManager(current.sys_id, activity.activity.sys_id);\n\t\tfor (var id in approvals)\n\t\t\tids.push(id);\n\n\t\treturn ids;\n\t},\n\n\t_getChildTaskResults: function() {\n\t\tvar counts = {\n\t\t\ttotal: 0,\n\t\t\trequested: 0,\n\t\t\tapproved: 0,\n\t\t\trejected: 0,\n\t\t\tcancelled: 0\n\t\t};\n\n\t\tvar children = new GlideRecord('wf_executing');\n\t\tchildren.addQuery('parent', activity.sys_id);\n\t\tchildren.query();\n\t\twhile (children.next()) {\n\t\t\tthis._restartManualApprovals(children);\n\t\t\tvar state = children.result.toString();\n\t\t\tif (state == 'skipped')\n\t\t\t\tcontinue;\n\n\t\t\tif (!state)\n\t\t\t\tstate = 'requested';\n\t\t\telse\n\t\t\t\tstate = state.replace(/\\s/g, \"_\");\n\n\t\t\tif (!counts[state])\n\t\t\t\tcounts[state] = 0;\n\n\t\t\tcounts[state] = counts[state] + 1;\n\t\t\tif (state == 'approved' || state == 'requested' || state == 'rejected')\n\t\t\t\tcounts.total++;\n\t\t}\n\n\t\tif (gs.getProperty('glide.workflow_approval_utils.log') == 'true') {\n\t\t\tvar debugString = \"Approvals for: \" + activity.name;\n\t\t\tfor ( var s in counts)\n\t\t\t\tdebugString += \" \" + s + \"=\" + counts[s];\n\t\t\tthis.debug(debugString);\n\t\t}\n\t\treturn counts;\n\t},\n\t\n\t// PRB1115684: There was a bug that allowed a Manual Approval activity to \n\t// restart after an update when contained in an executing Approval Coordinator\n\t// Added property to preserve the behavior for existing customers\n\t_restartManualApprovals: function(child) {\n\t    if (gs.getProperty('glide.manual.approval.pickup_on_update', \"false\") == \"false\")\n\t\t\treturn;\n\n\t\tif (event == this.DETERMINE_APPROVAL_STATE_EVENT)\n\t\t\treturn;\n\t\t\n\t\tif (child.activity.activity_definition.name != 'Manual Approvals')\n\t\t\treturn;\n\n\t\tif (child.state == 'waiting')\n\t\t\treturn;\n\n\t\tchild.state = 'waiting';\n\t\tchild.result = '';\n\t\tchild.setWorkflow(false);\n\t\tchild.update();\n\n\t\t// only now that we have all of our child approvals created can we ask the manual children\n\t\t// to determine their state, and subsequently our state.  We have to do this AFTER\n\t\t// any new manual approvals might get created.\n\t\tworkflow.registerForEvent(this.DETERMINE_APPROVAL_STATE_EVENT);\n\t\tworkflow.fireEvent(this.DETERMINE_APPROVAL_STATE_EVENT);\n\t\tworkflow.unregisterForEvent(this.DETERMINE_APPROVAL_STATE_EVENT);\n\t},\n\n\t// Remove any groups that are referenced more than one time (so that we only ask for that\n\t// group approval once)\n\t_removeGroupDuplicates: function() {\n\t\tvar gr = new GlideRecord('sysapproval_group');\n\t\tvar approvalIds = [];\n\n\t\t// handles group approval\n\t\tvar approvals = this.approvalUtils.getGroupApprovalsByApprovalManager(current.sys_id, activity.activity.sys_id);\n\t\tapprovalIds = approvalIds.concat(this._removeDuplicates(gr, approvals, false));\n\n\t\treturn approvalIds;\n\t},\n\n\t// Remove any users that are referenced more than one time (so that we only ask for that\n\t// user approval once)\n\t_removeUserDuplicates: function() {\n\t\tvar gr = new GlideRecord('sysapproval_approver');\n\t\tvar approvalIds = [];\n\n\t\t// handles user approval\n\t\tvar approvals = this.approvalUtils.getUserApprovalsByApprovalManager(current.sys_id, activity.activity.sys_id);\n\t\tapprovalIds = approvalIds.concat(this._removeDuplicates(gr, approvals, true));\n\n\t\treturn approvalIds;\n\t},\n\n\t/**\n\t * removes approval duplicates.\n\t * if it is user approval, then isUserApproval should be true, otherwise false.\n\t */\n\t_removeDuplicates: function(gr, approvals, isUserApproval) {\n\t\tvar deDup = \"true\" == gs.getProperty('glide.workflow.approval.remove_duplicates','false');\n\n\t\tvar approvalIds = [];\n\t\tvar approverObject = {};\n\t\tvar approvalObjects = {};\n\t\tvar approverId = null;\n\t\tfor (var id in approvals) {\n\t\t\tvar info = approvals[id];\n\t\t\tif (info.state == 'cancelled' || info.state == 'not_required')\n\t\t\t\tcontinue;\n\n\t\t\tif ( gs.getProperty('glide.workflow.approval.readd_approved_rejected', 'false') == 'true')\n\t\t\t\tif (info.state == 'approved' || info.state == 'rejected')\n\t\t\t\t\tcontinue;\n\n\t\t\tapproverId = info.approver_id;\n\t\t\t/* eslint-disable curly */\n\t\t\t// We must remove duplicate groups as legacy behavior, but we should only remove duplicate users when explicitly instructed to\n\t\t\tif ((deDup || !isUserApproval) && approverObject[approverId]) {\n\t\t\t\tif (gr.get(id)) {\n\t\t\t\t\tif (isUserApproval)\n\t\t\t\t\t\tthis.approvalUtils.addApprovalHistoryGR(current, gs.getMessage(\"Duplicate user approval removed for {0}.\", [ gr.approver.name\n\t\t\t\t\t\t\t\t.toString() ]));\n\t\t\t\t\telse\n\t\t\t\t\t\tthis.approvalUtils.addApprovalHistoryGR(current, gs.getMessage(\"Duplicate group approval removed for {0}.\", [ gr.assignment_group.name\n\t\t\t\t\t\t\t\t.toString() ]));\n\n\n\t\t\t\t\t// Before we delete we need to ensure the other Approval Activities watch for the remaining\n\t\t\t\t\t// Sysapproval record to be approved/rejected.  Don't update if we simply removed a duplicate group.\n\t\t\t\t\tif (isUserApproval && deDup)\n\t\t\t\t\t\tthis._updateApprovalIDs(id, approvalObjects[approverId], info.activity_id);\n\t\t\t\t\tif (!isUserApproval && deDup)\n\t\t\t\t\t\tthis._updateGroupApprovalIDs(id, approvalObjects[approverId], info.activity_id, approvals[approvalObjects[approverId]].activity_id);\n\n\t\t\t\t\tgr.setWorkflow(false);\n\t\t\t\t\tgr.deleteRecord();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tapproverObject[approverId] = true;\n\t\t\t\tapprovalObjects[approverId] = id;\n\t\t\t\tapprovalIds.push(id);\n\t\t\t}\n\t\t}\n\n\t\treturn approvalIds;\n\t},\n\n\t_updateApprovalIDs: function(old_approvalId, new_approvalID, activityID) {\n\t\tvar child = new GlideRecord('wf_executing');\n\t\tchild.addQuery('activity', activityID);\n\t\tchild.addQuery('parent', activity.sys_id);\n\t\tchild.query();\n\t\tif (!child.next())\n\t\t\treturn;\n\n\t\tif (child.scratchpad.nil())\n\t\t\treturn;\n\t\tvar re = new RegExp(old_approvalId, 'g');\n\t\tchild.scratchpad = child.getDisplayValue(\"scratchpad\").replace(re, new_approvalID);;\n\t\tchild.update();\n\t},\n\t\n\t_updateGroupApprovalIDs: function(old_approvalId, new_approvalID, activityID, sourceActivityId) {\t\t\t\t\n\t\tvar child = new GlideRecord('wf_executing');\n\t\tchild.addQuery('activity', activityID);\n\t\tchild.addQuery('parent', activity.sys_id);\n\t\tchild.query();\n\t\tif (!child.next()) \n\t\t\treturn;\n\t\t\n\t\tif (child.scratchpad.nil())\n\t\t\treturn;\n\t\t\n\t\tvar source = new GlideRecord('wf_executing');\n\t\tsource.addQuery('activity', sourceActivityId);\n\t\tsource.addQuery('parent', activity.sys_id);\n\t\tsource.query();\n\t\t\t\n\t\tif (!source.next())\n\t\t\treturn;\n\t\t\t\n\t\tif (source.scratchpad.nil())\n\t\t\treturn;\n\t\t\n\t\tvar sSp = source.getDisplayValue(\"scratchpad\");\n\t\tvar cSp = child.getDisplayValue(\"scratchpad\");\n\t\tvar oldGrp = old_approvalId;\n\t\tvar newGrp = new_approvalID;\n\t\tfor (var oldGrpUserIdx in cSp[oldGrp]) {\n\t\t\tvar oldGrpUser = cSp[oldGrp][oldGrpUserIdx];\n\t\t\tcSp[\"approval_ids\"] = cSp[\"approval_ids\"].filter(function(item) { return item !== oldGrpUser;});\t\t\n\t\t}\n\t\tcSp[\"approval_ids\"] = cSp[\"approval_ids\"].filter(function(item) { return item !== oldGrp;});\n\t\tdelete cSp[oldGrp];\n\t\t\n\t\tcSp[\"approval_ids\"].push(newGrp);\n\t\tfor (var newGrpUserIdx in sSp[newGrp]) {\n\t\t\tvar newGrpUser = sSp[newGrp][newGrpUserIdx];\n\t\t\tcSp[\"approval_ids\"].push(newGrpUser);\n\t\t}\n\t\tcSp[newGrp] = sSp[newGrp];\n\t\tchild.scratchpad = cSp;\n\t\tchild.update();\n\t},\n\t\n\ttype: 'Approval_CoordinatorActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_283e8bb80a2581021d036a052ffc3433","js_class_name":"Approval_Coordinator","name":"Approval Coordinator","attributes":"container=354e911f0a0a029a00e6a0e6ad74206f;35433da80a0a029a0028c639a1e51eb4;533e39330a6a803f54a9619525b0a7e7,approval=true","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Turnstile activity counts how many times a workflow passes through the same point. \r\n \r\nUse this activity to prevent infinite loops. This activity is useful when the workflow includes Rollback or Rollback To activities.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using the 'activity.result' variable from within a script field of the activity. By default, the activity script evaluates if the activity should continue to iterate or stop. Possible result values are: \r\n*Continue: the 'Allowed iterations' value is greater than the number of times the workflow accessed this activity.\r\n*Cancel: the workflow accessed this activity more times than the 'Allowed iterations' value.","sys_updated_on":"2014-10-22 17:47:11","sys_class_name":"wf_activity_definition","sys_id":"29bdded40a0a0b1d0062a5b4bdf81dd7","sys_updated_by":"harry.nelson","sys_created_on":"2008-09-03 19:44:20","action":"false","sys_name":"Turnstile","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/turnstile.png","default_width":"","base_provider":"","sys_mod_count":"20","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar TurnstileActivityHandler = Class.create();\nTurnstileActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n   var schpdName = 'iterations_' + activity.activity.sys_id;\n      WFActivityHandler.prototype.initialize.call(this);\n      if (!workflow.scratchpad[schpdName]) {\n         workflow.scratchpad[schpdName] = 1;\n      }\n   },\n\n   onExecute: function() {\n      // implement activity definition code here\n      var schpdName = 'iterations_' + activity.activity.sys_id;\n\n      var iterCountVar = parseInt(workflow.scratchpad[schpdName], 10);\n      var iterAllowedVar = parseInt(activity.vars.iterations, 10);\n\n      if (iterCountVar > iterAllowedVar) {\n         //Youve iterated too many times...stop iterating\n         activity.result = 'cancel';\n\n      } else {\n         //Still iterating\n         iterCountVar ++;\n\n         workflow.scratchpad[schpdName] = iterCountVar;\n\n         activity.result = 'continue';\n      }\n   },\n\n   type: 'TurnstileActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_29bdded40a0a0b1d0062a5b4bdf81dd7","js_class_name":"Turnstile","name":"Turnstile","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Creates On-Call escalation log provided group and source information","sys_updated_on":"2020-03-04 11:44:46","sys_class_name":"wf_activity_definition","sys_id":"2c50dd00c7d200100c54885827c260e6","sys_updated_by":"admin","sys_created_on":"2020-01-07 13:11:07","action":"false","sys_name":"On-Call: Log Escalation Start","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"12","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Log_Escalation_StartActivityHandler = Class.create();\nOn_Call__Log_Escalation_StartActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n\t/**\n     * Set activity to error\n     *\n     * @param message\n     */\n    throwError: function(message) {\n        this.error(message, \"\");\n        this.setResultFaulted(message);\n    },\n\t\n\tonExecute: function() {\n\t\tvar groupId = '';\n\t\tvar table = '';\n\t\tvar source = '';\n\t\tvar parentEscalationLevel = '';\n\t\tvar category = '';\n\t\tvar channels = '';\n\t\tvar ignoreDefReminders = false;\n\n\t\ttry {\n\t\t\tgroupId = this.runScript(activity.vars.group_id + '');\n\t\t\ttable = this.runScript(activity.vars.table + '');\n\t\t\tsource = this.runScript(activity.vars.source + '');\n\t\t\tparentEscalationLevel = this.runScript(activity.vars.parent_escalation_level + '');\n\t\t\tcategory = this.runScript(activity.vars.category + '');\n\t\t\tchannels = this.runScript(activity.vars.channels + '');\n\t\t\tignoreDefReminders = activity.vars.ignore_definition_reminders;\n\t\t} catch (e) {\n\t\t\tthis.throwError(e.message);\n\t\t\tactivity.state = 'faulted';\n\t\t\treturn;\n\t\t}\n\n\t\tvar workflowDefinition = context.workflow.sys_id + '';\n\t\tvar workflowContext = context.sys_id + '';\n\t\t\n\t\tvar ocEscalationUtil = new OnCallEscalationUtil();\n\t\tvar result = ocEscalationUtil.logEscalationStart(groupId, table, source, workflowDefinition, workflowContext, parentEscalationLevel, category, channels, ignoreDefReminders);\n\n\t\tif (result && result.escalationLogEnabled) {\n            if (result.success) {\n                workflow.scratchpad.escalationSysId = result.logGr.getUniqueValue();\n            } else {\n                var msg = '';\n                if (result.error)\n                    msg = result.error.msg;\n                return this.throwError(msg);\n            }\n        }\n\t\t\n\t\tactivity.state = 'finished';\n\n\t},\n\n   type: 'On_Call__Log_Escalation_StartActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_2c50dd00c7d200100c54885827c260e6","js_class_name":"On_Call__Log_Escalation_Start","name":"On-Call: Log Escalation Start","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Approval - User activity creates a user approval record or a set of user approval records.\n\nUse this activity to request approval records from individual users or users within a group.\n\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\n*Executing: the workflow engine starts the 'run' function of the activity. \n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \n*Finished: the activity finished running. See the result value for the outcome of the activity.\n*Cancelled: this activity or the workflow that contains this activity was canceled.\n*Error: a JavaScript error occurred. Review the logs for error details.\n\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value is the final approval disposition. This disposition depends on the actions taken by the approvers and the conditions specified in the 'Wait for' and 'When Anyone Rejects' fields. Possible result values are: \n*Approved\n*Rejected\n*Skipped\n*Deleted\n*Cancelled\n\nKeep in mind: \n*This activity contains script fields. Do not use the current.update() method in these script fields because this may cause recursive updates to the current record.\n*If the activity cannot find records for the approvers assigned in the 'User' field, the default result of the approval is 'Skipped' and the workflow moves through the Approved transition.","sys_updated_on":"2017-04-03 21:20:29","sys_class_name":"wf_activity_definition","sys_id":"35433da80a0a029a0028c639a1e51eb4","sys_updated_by":"cmitchell","sys_created_on":"2007-11-12 19:17:38","action":"false","sys_name":"Approval - User","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/approval_user.png","default_width":"","base_provider":"","sys_mod_count":"189","sys_tags":"","script":"// Workflow activity definition handler class\n\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n// For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Approval___UserActivityHandler = Class.create();\nApproval___UserActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n      this.approvalUtils = new WorkflowApprovalUtils();\n      this.setDatesFlag = false;\n   },\n   \n   onExecute: function() {\n      /**\n       * Create the approvals and wait for them to either be approved or rejected.\n       */\n      \n      // did we pre-generate the approvals?\n      var approvals;\n      var genObj = this._getGenerateObj(activity.activity.toString());\n      if (genObj && genObj.approvals) {\n         approvals = genObj.approvals;\n         if (approvals.length > 0) {\n\t\t\tvar state = this.approvalUtils.getUserApprovalStateById(approvals);\n\t\t\t if( state && state != 'not requested') {\n\t\t\t\t this.approvalUtils.setUserApprovalsByIds(approvals, 'not_required', '', ['not requested']);\n\t\t\t\t activity.state = state;\n                 activity.result = state; \n\t\t\t } else\n\t\t\t\tthis.approvalUtils.setUserApprovalsByIds(approvals, 'requested', '', ['not requested']);\n         }\n      } else {\n         // if we are a child of an Approval Manager activity, then we\n         // create the approvals in a Not Requested state and let the AM\n         // remove any duplicates before setting the approvals to Requested\n         var state;\n         if (activity.activity.parent.nil())\n            state = 'requested';\n         else\n            state = 'not requested';\n         \n         this._setDueDate(\"\");\n         approvals = this._createApprovals(state);\n      }\n      this._removeGenerateObj(activity.activity.toString());\n      \n      // any approvals?\n      if (approvals.length == 0)\n         activity.result = 'skipped';\n      else\n         activity.state = 'waiting';\n      \n      // save the list of approval ids\n      activity.scratchpad.approval_ids = approvals;\n      \n      // If we are maintaining approval states (from the previous execution of the workflow),\n      // then we need to determine our current state unless we are a child activity, in which\n      // case we will be asked to determine our state after our parent has removed any duplicates\n      if ((approvals.length > 0) && (workflow.scratchpad.maintainStateFlag == true) && activity.activity.parent.nil())\n        this._onUpdate();\n   },\n   \n   onDetermineApprovalState: function() {\n      this._onUpdate();\n   },\n   \n   // The task has changed, see if we need to update our approval state\n   onUpdate: function() {\n      this._onUpdate();\n   },\n\t\n   // override this to provide the proper stage state\n   getFinalStageState: function() {\n\t   return new WFApprovalStages().getApprovalState(current, current.stage, activity);\n   },\n\t\n   _onUpdate: function() {\n      var state = this._determineOverallState();\n      if (state && (state != 'requested')) {\n         this.approvalUtils.setPendingUserApprovalsByIds(activity.scratchpad.approval_ids, 'not_required');\n         activity.state = 'finished';\n         activity.result = state;\n      } else if ((state == 'requested') && (activity.result != state)) {\n         // changed back to requested state (unapprove can do this)\n         activity.state = 'waiting';\n         activity.result = '';\n      }\n   },\n   \n   // The approval was cancelled\n   onCancel: function() {\n      this.approvalUtils.setPendingUserApprovalsByIds(activity.scratchpad.approval_ids, 'cancelled');\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n   },\n   \n   /**\n    * Create the approvals as a forward-looking process in which we just create, but do not\n    * process the approvals.  This allows the approvals to be generated up front before the\n    * workflow runs such that the approvals are visible prior to being requested.\n    */\n   _generate: function(approvalOrder, startAt, noCreateFlag) {\n      this.approvalUtils = new WorkflowApprovalUtils();\n      var genObj = {};\n      this._setDueDate(startAt);\n      this.setDatesFlag = true;\n      if (!noCreateFlag)\n         genObj.approvals = this._createApprovals('not requested', approvalOrder);\n      genObj.duration = this.duration;\n      return genObj;\n   },\n   \n   // Create the approval(s) based on the variables that are specified\n   _createApprovals: function(state, approvalOrder) {\n      this.existingIds = this._getExistingApprovals();\n      var userIds = this._getUserIds();\n      var approvalIds = this._buildApprovals(userIds, state, approvalOrder);\n      this._checkDroppedApprovals(approvalIds);\n      return approvalIds;\n   },\n   \n   _getExistingApprovals: function() {\n      var ids = {};\n      gr = new GlideRecord('sysapproval_approver');\n      gr.initialize();\n\t  \n\t  var table = current.getRecordClassName();\n      // For non task related tables, add the query on document id \n\t   // For task relatd tables add the query based on sysapproval as this is what is being set while creating new approval\n\t   if( table != null && this.approvalUtils.isTask(table) ) {\n\t\t // Task table\n\t\t gr.addQuery('sysapproval', current.sys_id);  \n      } else {\n         // Non task table  \n         gr.addQuery('document_id', current.sys_id);  \t  \n\t  }\n      gr.addQuery('wf_activity', activity.activity.sys_id);\n      gr.addQuery('state', '!=', 'cancelled');\n      gr.query();\n      while (gr.next())\n         ids[gr.approver.toString()] = gr.sys_id.toString();\n      \n      return ids;\n   },\n   \n   _getUserIds: function() {\n      // does the condition match?\n      if (!this._isConditionMatch())\n         return [];\n      \n      var users = {};\n      var groups = {};\n      \n      // users\n      this.approvalUtils.addIdsToApprovalList(users, activity.vars.users + '');\n      \n      // groups\n      this.approvalUtils.addIdsToApprovalList(groups, activity.vars.groups + '');\n     \n\t   // additional approvers script\n      if (activity.vars.advanced && activity.vars.approver_script) {\n      \t try {\n        \tvar ids = this.runScript(activity.vars.approver_script);\n        \tif (ids) {\n            \tif (typeof(ids) == 'string') {\n               \t\tids = ids.split(',');\n               \t}\n           \t\tthis.approvalUtils.addUsersAndGroupsToApprovalList(users, groups, ids);\n        \t}\n         } catch (ex) {\n         \tif (JSUtil.isEmpty(users)) {\n         \t\t//no other approver and the advanced script failed = fault\n         \t\tthrow 'No Approval User selected and advanced script encountered an error:'+ ex.message;\n         \t} else {\n         \t\t//at least one approver came from the other fields in the activity, log the error but no fault\n            \tworkflow.error('advanced script encountered an error:' + ex.message);\n            }\n         }\n      }\n\t   \n\t for (var id in groups) {\n         var ids = this.approvalUtils.getMembersOfGroup(id);\n         this.approvalUtils.addIdsToApprovalList(users, ids);\n      }\n      \n      return users;\n   },\n   \n   _buildApprovals: function(userIds, state, approvalOrder) {\n      var approvalIds = [];\n      for (var id in userIds)\n         approvalIds.push(this._createApproval(id, state, approvalOrder));\n      \n      return approvalIds;\n   },\n   \n   /**\n    * Create a new use approval or update an existing user approval\n    */\n    _createApproval: function(userId, state, approvalOrder) {\n      var approvalId;\n      if (this.existingIds && this.existingIds[userId]) {\n         approvalId = this.existingIds[userId];\n         this._setApprovalState(approvalId, state);\n      } else\n      approvalId = this._createNewApproval(userId, state, approvalOrder);\n      \n      return approvalId;\n   },\n \n     //fdt- expanding approval - user to be generic. To that end, back-setting the legacy taks\n     //values for backwards compatability, but going forward adding document_id/source table\n     //sysapproval is only valid if the table is of type task, otherwise\n     //the type approval is for a non-task derived table in which case the document_id\n     //is derived from the current.getUniqueValue() and getRecordClassName();\n   \n    _createNewApproval: function(userId, state, approvalOrder) {\n      var approval = new GlideRecord('sysapproval_approver');\n      approval.initialize();\n      var table = current.getRecordClassName();\n      var guid = current.getUniqueValue();\n      //fdt logic added for generic approval       \n      // if this is a task table, then keep the sysapproval insynch with document id\n      // this will keep all the service catalog workflows working\n      if( table != null && this.approvalUtils.isTask(table) ) {\n         approval.sysapproval = current.sys_id; \n\t\t approval.sysapproval.setRefRecord(current);\n\t  }\n      approval.document_id = guid;\n\t  approval.document_id.setRefRecord(current);\n      approval.source_table = table; \n      approval.approver = userId;\n      approval.approval_column = this.js(activity.vars.approval_column);\n      approval.approval_journal_column = this.js(activity.vars.approval_history);\n\n      approval.wf_activity = activity.activity.sys_id;\n      approval.state = state;\n      if (approvalOrder)\n         approval.order = approvalOrder;\n      \n      approval.expected_start.setValue(this.expected_start);\n      approval.due_date.setValue(this.due_date);\n      return approval.insert();\n   },\n   \n   _setDueDate: function(startAt) {\n      this.expected_start = new GlideDateTime();\n      if (startAt)\n         this.expected_start.setValue(startAt);\n      \n      var wd = new WorkflowDuration();\n      wd.setActivity(this);\n      wd.setStartDateTime(startAt);\n      wd.setWorkflow(context.schedule, context.timezone);\n      wd.calculate(activity.vars.__var_record__);\n      this.due_date = new GlideDateTime(wd.getEndDateTime());\n      this.duration = wd.getTotalSeconds() * 1000;\n   },\n   \n   /**\n    * Set the state of the approval to the specified state\n    */\n   _setApprovalState: function(approvalId, state) {\n      if (workflow.scratchpad.maintainStateFlag == true)\n         return;\n      \n      var approval = new GlideRecord('sysapproval_approver');\n      if (!approval.get(approvalId))\n         return;\n      \n      approval.state = state;\n      if (this.setDatesFlag) {\n         approval.expected_start.setValue(this.expected_start);\n         approval.due_date.setValue(this.due_date);\n      }\n      approval.update();\n   },\n   \n   /**\n    * Delete any approvals that we previously created but did not match during\n    * this creation pass\n    */\n   _checkDroppedApprovals: function(approvalIds) {\n      if (!this.existingIds)\n         return;\n      \n      var prevIds = {};\n      for (var id in this.existingIds)\n         prevIds[this.existingIds[id]] = true;\n      \n      for (var i = 0; i < approvalIds.length; i++)\n         prevIds[approvalIds[i]] = false;\n      \n      var dropIds = [];\n      for (var id in prevIds) {\n         if (prevIds[id])\n            dropIds.push(id);\n      }\n      \n      if (dropIds.length > 0) {\n         var gr = new GlideRecord('sysapproval_approver');\n         gr.addQuery('sys_id', dropIds);\n         gr.query();\n         while (gr.next()) {\n            this.approvalUtils.addApprovalHistoryGR(current, gs.getMessage(\"User approval for {0} deleted since it no longer matches approval rule {1}.\", [gr.approver.name.toString(), activity.activity.name.toString()]));\n            gr.deleteRecord();\n         }\n      }\n   },\n   \n   _isConditionMatch: function() {\n      if (!activity.vars.condition.toString())\n         return true;\n      \n      return GlideFilter.checkRecord(current, activity.vars.condition);\n   },\n   \n   // Determine the overall state of the approvals (approved, rejected or '')\n   _determineOverallState: function() {\n     var ids = activity.scratchpad.approval_ids;\n     if (!ids)\n         return 'skipped';\n\n      var waitFor = activity.vars.wait_for;\n      var ret = this.approvalUtils.getUserIdListApprovalCounts(ids);\n      if (waitFor == 'script') {\n         if (!activity.vars.approval_script)\n            return 'approved';\n         \n         workflow.prepareScriptVariable('counts', ret.counts);\n         workflow.prepareScriptVariable('approvalIDs', ret.approvalIDs);\n         var state = this.runScript(activity.vars.approval_script);\n         return state;\n      }\n      \n      var rejectHandling = activity.vars.reject_handling;\n      ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0)\n         return 'skipped';\n      \n      if ((ret.counts['rejected'] > 0) && (rejectHandling == 'reject'))\n         return 'rejected';\n      \n      if ((waitFor == 'any' || waitFor == 'first') && (ret.counts['approved'] > 0))\n         return 'approved';\n      \n      if ((waitFor == 'first') && (ret.counts['rejected'] > 0))\n         return 'rejected';\n      \n      if ((waitFor == 'all') && (ret.counts['approved'] == ret.counts['total']))\n         return 'approved';\n      \n      if ((ret.counts['rejected'] + ret.counts['approved']) == ret.counts['total']) {\n         // we are complete - we have to make a decision\n         return 'rejected';\n      }\n\n      return 'requested';\n   },\n   \n   type: 'Approval___UserActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_35433da80a0a029a0028c639a1e51eb4","js_class_name":"Approval___User","name":"Approval - User","attributes":"generate=approval,approval=true","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Approval - Group activity creates a group approval record or set of group approval records. The activity generates approval records for each member of the group. As opposed to user approvals, ServiceNow tracks group approvals at the group level. Group approvals let you see which groups approve or reject the request along with the users responsible for the group level approval.\r\n\r\nUse this activity to request approvals from users within a group.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity or the workflow that contains this activity was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value is the final approval disposition. This disposition depends on the actions take by the approvers and the conditions specified in the 'Wait for' and 'When Anyone Rejects' fields. Possible result values are: \r\n*Approved\r\n*Rejected\r\n*Skipped\r\n*Deleted\r\n*Cancelled\r\n \r\nKeep in mind: \r\n*This activity contains script fields. Do not use the 'current.update()' method in these script fields because it may cause recursive updates to the current record.\r\n*If the approval group assigned in the 'Groups' field can not be resolved, the default result of the approval is Skipped and will result in the Approved transition.","sys_updated_on":"2019-05-02 16:06:52","sys_class_name":"wf_activity_definition","sys_id":"354e911f0a0a029a00e6a0e6ad74206f","sys_updated_by":"david.airmet@snc","sys_created_on":"2007-11-12 19:20:49","action":"false","sys_name":"Approval - Group","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task","image":"images/heisenberg_icons/workflow/approval_group.png","default_width":"","base_provider":"","sys_mod_count":"223","sys_tags":"","script":"/**\n * Group approvals are tracked by the group but requested from all group members\n */\n\nvar Approval___GroupActivityHandler = Class.create();\nApproval___GroupActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n      this.approvalUtils = new WorkflowApprovalUtils();\n      this.setDatesFlag = false;\n   },\n   \n   onExecute: function() {\n      /**\n       * Create the approvals and (optionally) wait for them to either be approved or rejected.\n       */\n      \n      // did we pre-generate the approvals?\n      var approvals;\n\t  var groupMap = [];\n      var genObj = this._getGenerateObj(activity.activity.toString());\n      if (genObj && genObj.approvals) {\n         approvals = genObj.approvals;\n\t\t groupMap = genObj.groupMap;\n         if (approvals.length > 0) {\n            // In order to maintain the approval state if we revisit this approval activity\n            // we need to only request those approvals that are currently in a Not Requested state\n\t\t\t \n\t\t\t var state = this._determineOverallState();\n\t\t\t if (state && state != 'skipped') {\n\t\t\t\t this.approvalUtils.setGroupApprovalsByIds(approvals, 'not_required', '', ['not requested']);\n\t\t\t\t activity.state = state;\n                 activity.result = state;\t \n\t\t\t } else\n\t\t\t\t this.approvalUtils.setGroupApprovalsByIds(approvals, 'requested', '', ['not requested']);\n         }\n      } else {\n         // if we are a child of an Approval Manager activity, then we\n         // create the approvals in a Not Requested state and let the AM\n         // remove any duplicates before setting the approvals to Requested\n         var state;\n         if (activity.activity.parent.nil())\n            state = 'requested';\n         else\n            state = 'not requested';\n         \n         this._setDueDate(\"\");\n         approvals = this._createApprovals(state);\n\t\t groupMap = this.approvalUtils.getUserApprovalIdsForGroups(approvals);\n      }\n      this._removeGenerateObj(activity.activity.toString());\n      \n      // any approvals?\n      if (approvals.length == 0)\n         activity.result = 'skipped';\n      else\n         activity.state = 'waiting';\n      \n      // save the list of group approval ids\n\t  for (var idx in groupMap)\n\t\t  activity.scratchpad[idx] = groupMap[idx];\n      activity.scratchpad.approval_ids = approvals;\n\n      // If we are maintaining approval states (from the previous execution of the workflow),\n      // then we need to determine our current state unless we are a child activity, in which\n      // case we will be asked to determine our state after our parent has removed any duplicates\n      if ((approvals.length > 0) && (workflow.scratchpad.maintainStateFlag == true) && activity.activity.parent.nil())\n         this._onUpdate();\n   },\n\n   // override this to provide the proper stage state\n   getFinalStageState: function() {\n\t   return new WFApprovalStages().getApprovalState(current, current.stage, activity);\n   },\n\n   onDetermineApprovalState: function() {\n      this.forceState = true;\n      this._onUpdate();\n   },\n   \n   // The task has changed, see if we need to update our approval state\n   onUpdate: function() {\n      this._onUpdate();\n   },\n   \n   _onUpdate: function() {\n      var state = this._determineOverallState();\n      if (GlideStringUtil.notNil(state) && (state != 'requested')) {\n         this.approvalUtils.setPendingGroupApprovalsByIds(activity.scratchpad.approval_ids, 'not_required');\n         activity.state = 'finished';\n         activity.result = state;\n      } else if ((state == 'requested') && (activity.result != state)) {\n         // changed back to requested state (unapprove can do this)\n         activity.state = 'waiting';\n         activity.result = '';\n      } else if ((GlideStringUtil.nil(state)) && (GlideStringUtil.nil(activity.result))) {\n         // deleting the Group approval with cascade delete to approvals can do this\n         activity.state = 'finished';\n         activity.result = 'skipped';\n      }\n   },\n   \n   // The approval was cancelled\n   onCancel: function() {\n      this.approvalUtils.setPendingGroupApprovalsByIds(activity.scratchpad.approval_ids, 'cancelled');\n\t  this.approvalUtils.setPendingUserApprovalsByGroup(activity.scratchpad.approval_ids, 'cancelled');\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n   },\n   \n   /**\n    * Create the approvals as a forward-looking process in which we just create, but do not\n    * process the approvals.  This allows the approvals to be generated up front before the\n    * workflow runs such that the approvals are visible prior to being requested.\n    */\n   _generate: function(approvalOrder, startAt, noCreateFlag) {\n      this.approvalUtils = new WorkflowApprovalUtils();\n      var genObj = {};\n      this._setDueDate(startAt);\n      this.setDatesFlag = true;\n      if (!noCreateFlag) {\n         genObj.approvals = this._createApprovals('not requested', approvalOrder);\n\t\t genObj.groupMap = this.approvalUtils.getUserApprovalIdsForGroups(genObj.approvals);\n\t  }\n      genObj.duration = this.duration;\n      return genObj;\n   },\n   \n   // Create the approval(s) based on the variables that are specified\n   _createApprovals: function(state, approvalOrder) {\n      this.existingIds = this._getExistingApprovals();\n      var groupIds = this._getGroupIds();\n      var approvalIds = this._buildApprovals(groupIds, state, approvalOrder);\n      this._checkDroppedApprovals(approvalIds);\n      return approvalIds;\n   },\n   \n   _getExistingApprovals: function() {\n      var ids = {};\n      gr = new GlideRecord('sysapproval_group');\n      gr.initialize();\n      gr.addQuery('parent', current.sys_id);\n      gr.addQuery('wf_activity', activity.activity.sys_id);\n      gr.addQuery('approval', '!=', 'cancelled');\n      gr.query();\n      while (gr.next())\n         ids[gr.assignment_group.toString()] = gr.sys_id.toString();\n      \n      return ids;\n   },\n   \n   _getGroupIds: function() {\n      // does the condition match?\n      if (!this._isConditionMatch())\n         return [];\n      \n      var groups = {};\n      \n      // groups\n      this.approvalUtils.addIdsToApprovalList(groups, activity.vars.groups + '');\n      \n      // additional approvers script\n      if (activity.vars.advanced && activity.vars.approver_script) {\n      \ttry {\n        \tvar ids = this.runScript(activity.vars.approver_script);\n\t        if (ids) {\n\t           if (typeof(ids) == 'string') {\n\t              ids = ids.split(','); \n\t           }\n\t           this.approvalUtils.addIdsToApprovalList(groups, ids);\n\t        }\n         } catch (ex) {\n         \tif (JSUtil.isEmpty(groups)) {\n         \t\t//no other approver and the advanced script failed = fault\n         \t\tthrow 'No Approval Group selected and advanced script encountered an error:'+ ex.message;\n         \t} else {\n         \t\t//at least one approver came from the other fields in the activity, log the error but no fault\n            \tworkflow.error('advanced script encountered an error:' + ex.message);\n            }\n         }\n      }\n      \n      return groups;\n   },\n   \n   _buildApprovals: function(groupIds, state, approvalOrder) {\n      var approvalIds = [];\n      for (var id in groupIds) {\n         var approvalId = this._createApproval(id, state, approvalOrder);\n         if (approvalId)\n            approvalIds.push(approvalId);\n      }\n\t   \n      return approvalIds;\n   },\n   \n   /**\n    * Create a new group approval or update an existing group approval\n    */\n   _createApproval: function(groupId, state, approvalOrder) {\n      var approvalId;\n      if (this.existingIds && this.existingIds[groupId]) {\n         approvalId = this.existingIds[groupId];\n         this._setApprovalState(approvalId, state);\n      } else\n      approvalId = this._createNewApproval(groupId, state, approvalOrder);\n      \n      return approvalId;\n   },\n   \n   _createNewApproval: function(groupId, state, approvalOrder) {\n      // make sure there are users of the group before creating it\n      var ids = this.approvalUtils.getMembersOfGroup(groupId);\n      if (ids.length == 0)\n         return \"\";\n      \n      var approval = new GlideRecord('sysapproval_group');\n      approval.assignment_group = groupId;\n      approval.parent = current.sys_id;\n\t  approval.parent.setRefRecord(current);\n      approval.wf_activity = activity.activity.sys_id;\n      approval.approval = state;\n      if (approvalOrder)\n         approval.order = approvalOrder;\n      \n      approval.expected_start.setValue(this.expected_start);\n      approval.due_date.setValue(this.due_date);\n      return approval.insert();\n   },\n   \n   _setDueDate: function(startAt) {\n      this.expected_start = new GlideDateTime();\n      if (startAt)\n         this.expected_start.setValue(startAt);\n      \n      var wd = new WorkflowDuration();\n      wd.setActivity(this);\n      wd.setStartDateTime(startAt);\n      wd.setWorkflow(context.schedule, context.timezone);\n      wd.calculate(activity.vars.__var_record__);\n      this.due_date = new GlideDateTime(wd.getEndDateTime());\n      this.duration = wd.getTotalSeconds() * 1000;\n   },\n   \n   /**\n    * Set the state of the approval to the specified state\n    */\n   _setApprovalState: function(approvalId, state) {\n      if (workflow.scratchpad.maintainStateFlag == true)\n         return;\n      \n      var approval = new GlideRecord('sysapproval_group');\n      if (!approval.get(approvalId))\n         return;\n      \n      approval.approval = state;\n      if (this.setDatesFlag) {\n         approval.expected_start.setValue(this.expected_start);\n         approval.due_date.setValue(this.due_date);\n      }\n      approval.update();\n   },\n   \n   /**\n    * Delete any approvals that we previously created but did not match during\n    * this creation pass\n    */\n   _checkDroppedApprovals: function(approvalIds) {\n      if (!this.existingIds)\n         return;\n      \n      var prevIds = {};\n      for (var id in this.existingIds)\n         prevIds[this.existingIds[id]] = true;\n      \n      for (var i = 0; i < approvalIds.length; i++)\n         prevIds[approvalIds[i]] = false;\n      \n      var dropIds = [];\n      for (var id in prevIds) {\n         if (prevIds[id])\n            dropIds.push(id);\n      }\n      \n      if (dropIds.length > 0) {\n         var gr = new GlideRecord('sysapproval_group');\n         gr.addQuery('sys_id', dropIds);\n         gr.query();\n         while (gr.next()) {\n            this.approvalUtils.addApprovalHistoryGR(current, gs.getMessage(\"Group approval for {0} deleted since it no longer matches approval rule {1}.\", [gr.assignment_group.name.toString(), activity.activity.name.toString()]));\n            gr.deleteRecord();\n         }\n      }\n   },\n   \n   _isConditionMatch: function() {\n      if (!activity.vars.condition.toString())\n         return true;\n      \n      return GlideFilter.checkRecord(current, activity.vars.condition);\n   },\n   \n   // Determine the overall state of the approvals (approved, rejected or '')\n   _determineOverallState: function() {\n      var ids = activity.scratchpad.approval_ids;\n      if (!ids)\n         return 'skipped';\n      \n      var waitFor = activity.vars.wait_for;\n      if (waitFor == 'script') {\n         if (!activity.vars.approval_script)\n            return 'approved';\n         \n         // Set up information to be passed to the script\n         //    overall counts\n         var ret = this.approvalUtils.getGroupIdListApprovalCounts(ids);\n         ret.counts['total'] -= ret.counts['not_required'];\n         ret.counts['total'] -= ret.counts['duplicate'];\n         ret.counts['total'] -= ret.counts['cancelled'];\n         workflow.prepareScriptVariable('counts', ret.counts);\n         workflow.prepareScriptVariable('approvalIDs', ret.approvalIDs);\n         \n         //    group level counts and user ids\n         var groups = {};\n\t\t var groupRet = {};\n         for (var i = 0; i < ids.length; i++) {\n            var id = ids[i];\n\t\t\t \n\t\t\t// Jakarta: \n\t\t\t// We now track the approvals in the scratchpad for better \n\t\t\t// detection of duplicate user approvals that were deleted\n\t\t\tif (GlideStringUtil.notNil(activity.scratchpad[id]) && typeof activity.scratchpad[id] !== \"undefined\")\n\t\t\t\tgroupRet = this.approvalUtils.getGroupUserApprovalCounts(activity.scratchpad[id]);\n\t\t\telse\n\t\t\t\tgroupRet = this.approvalUtils.getUserGroupApprovalCounts(id);\n\t\t\t \n            groups[id] = {};\n            groups[id].approvalIDs = groupRet.approvalIDs;\n            for (var s in groupRet.counts)\n               groups[id][s] = groupRet.counts[s];\n         } \n         \n         workflow.prepareScriptVariable('groups', groups);\n         var newState = this.runScript(activity.vars.approval_script);\n         workflow.removeScriptVariable('groups');\n         workflow.removeScriptVariable('approvalIDs');\n         workflow.removeScriptVariable('counts');\n\t\t  \n\t\t // If the newState is not requested then it has changed to Approved, Rejected, Cancelled\n\t\t // or a custom state so mark any remaining Group approvals to No Longer Required\n\t\t if (newState && GlideStringUtil.notNil(newState) && (newState != 'requested')) {\n\t\t\t var groupApprovals = new GlideRecord('sysapproval_group');\n\t\t\t groupApprovals.addQuery('sys_id', ids);\n\t\t\t groupApprovals.query();\n\t\t\t while (groupApprovals.next()) {\n\t\t\t\t groupApprovals.approval = newState;\n\t\t\t\t if (gs.getProperty('glide.workflow.approval.group_match_state', \"true\") == \"true\") {\n\t\t\t\t\tgroupApprovals.state = this._determineGrApprovalNewState(newState);\n\t\t\t\t\tif (newState != 'not requested') {\n\t\t\t\t\t\tgroupApprovals.active = false;\n\t\t\t\t\t\tgroupApprovals.closed_by = gs.getUserID();\n\t\t\t\t\t\tgroupApprovals.closed_at = gs.nowDateTime();\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t\t groupApprovals.setWorkflow(false);\n\t\t\t\t groupApprovals.update();\n\t\t\t\t this.approvalUtils.setPendingUserApprovalsByGroup(groupApprovals.sys_id, 'not_required');\n\t\t\t }\n\t\t\t if (gs.getProperty('glide.workflow.approval.group_script_history', \"true\") == \"true\")\n\t\t\t\t this.approvalUtils.addApprovalHistoryGR(current, gs.getMessage(\"Approval state changed to '{0}' by 'Approval Script'.\", [newState]));\n\n\t\t }\n\t\t  \n\t\t if (!newState || GlideStringUtil.nil(newState))\n\t\t\t newState = 'requested';\n\t\t  \n         return newState;\n      }\n      \n      // check for approval state change within each group\n      var rejectHandling = activity.vars.reject_handling;\n      var changed = false;\n      var groupApprovals = new GlideRecord('sysapproval_group');\n      groupApprovals.addQuery('sys_id', ids);\n      groupApprovals.query();\n      while (groupApprovals.next()) {\n         if (this._determineGroupState(groupApprovals, waitFor, rejectHandling))\n            changed = true;\n      }\n      \n      if (!changed && !this.forceState)\n         return '';\n      \n      // And then the overall state\n      var ret = this.approvalUtils.getGroupIdListApprovalCounts(ids);\n      ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['duplicate'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0)\n         return 'skipped';\n      \n      if ((ret.counts['rejected'] > 0) && (rejectHandling == 'reject'))\n         return 'rejected';\n      \n      if ((waitFor == 'any' || waitFor == 'first_any') && (ret.counts['approved'] > 0))\n         return 'approved';\n      \n      if ((waitFor == 'first_any') && (ret.counts['rejected'] > 0))\n         return 'rejected';\n      \n      if ((waitFor == 'all' || waitFor == 'any_each' || waitFor == 'first_each') && (ret.counts['approved'] == ret.counts['total']))\n         return 'approved';\n      \n      if ((ret.counts['rejected'] + ret.counts['approved']) == ret.counts['total']) {\n         // we are complete - we have to make a decision\n         return 'rejected';\n      }\n      \n      return 'requested';\n   },\n\t\n\t// Get approval state based on approval (same logic as BR \"SNC - Match state to approval\")\n   _determineGrApprovalNewState: function(approval) {      \n      if (approval === 'not requested')\n         return '-5'; // Pending\n\n      else if (approval === 'requested')\n         return '1'; // Open\n\n      else if (approval === 'approved' || approval === 'rejected')\n         return '3'; // Closed Complete\n\n      else if (approval === 'cancelled')\n         return '4'; // Closed Incomplete\n\n      else if (approval === 'not_required')\n         return '7'; // Closed Skipped\n   },\n   \n   // Determine approval state for a group approval\n   _determineGroupState: function(gr, waitFor, rejectHandling) {\n      if (gr.admin_override == true)\n         return true;\t\t// force a determination of overall state since this might be the first change for admin override\n      \n      var currentState = gr.approval + '';\n      var newState = \"requested\";\n      var user;\n      var ret = {};\n\t\n\t  // Jakarta: \n\t  // We now track the approvals in the scratchpad for better \n\t  // detection of duplicate user approvals that were deleted\n\t  if (GlideStringUtil.notNil(activity.scratchpad[gr.sys_id]) && typeof activity.scratchpad[gr.sys_id] !== \"undefined\")\n\t\t  ret = this.approvalUtils.getGroupUserApprovalCounts(activity.scratchpad[gr.sys_id]);\n\t  else\n\t\t  ret = this.approvalUtils.getUserGroupApprovalCounts(gr.sys_id);\n\t   \n      ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0) {\n\t\t  if (currentState == 'rejected')\n\t\t\t  newState = 'rejected';\n\t\t else if (currentState == 'cancelled')\n\t\t\t  newState = 'cancelled';\n\t\t else if (currentState == 'not_required')\n\t\t\t  newState = 'not_required';\n         else\n\t\t\t newState = 'approved';\n         \n      } else if ((waitFor == 'first_any' || waitFor == 'first_each') && (ret.counts['rejected'] > 0)) {\n         // first response with a rejection\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n         \n      } else if ((waitFor == 'first_any' || waitFor == 'first_each') && (ret.counts['approved'] > 0)) {\n         // first response with an approval\n         newState = 'approved';\n         user = ret.approvalIDs['approved'][0];\n         \n      } else if ((rejectHandling == 'reject') && (ret.counts['rejected'] > 0)) {\n         // first reject and rejection handling is reject immed.\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n         \n      } else if ((waitFor == 'any' || waitFor == 'any_each') && (ret.counts['approved'] > 0)) {\n         // any approval and we have one\n         newState = 'approved';\n         user = ret.approvalIDs['approved'][0];\n         \n      } else if ((waitFor == 'all') && (ret.counts['approved'] == ret.counts['total'])) {\n         // all approval and we have all\n         newState = 'approved';\n         \n      } else if ((waitFor == 'any' || waitFor == 'any_each') && (ret.counts['rejected'] == ret.counts['total'])) {\n         // any approval, but everyone has rejected\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n      }\n      \n      // If all approvals are 'not_required' and currentState is rejected, cancelled, not_required, or approve\n\t  // Then the group approval was either rejected, cancelled, not_required, or approved\n      if (newState && (currentState != newState)) {\n         gr.approval = newState;\n         if (user)\n            gr.approval_user = user;\n         else if (newState == 'requested')\n            gr.approval_user = \"\";\n         \n         this._setGroupApprovalComment(gr, currentState, newState, user);\n         \n         gr.update();\n         return true;\n      }\n\t  \n\t  // Check for the Approval coming from Group Approval record (sysapproval_group)\n\t  if (newState && (currentState == newState))\n\t\t  return true;\n\t   \n      return false;\n   },\n   \n   _setGroupApprovalComment: function(gr, currentState, newState, user) {\n      var groupName = gr.assignment_group.name.toString();\n      // PRB1326306 dot-walking doesn't work in cross domain group approval\n      if (!groupName && gr.assignment_group) {\n         var agGr = new GlideRecord(gr.assignment_group.getReferenceTable());\n         agGr.addQuery('sys_id', gr.assignment_group.toString());\n         agGr.queryNoDomain();\n         if (agGr.next())\n            groupName = agGr.name.toString();\n      }\n      var userName = this.approvalUtils.getUserName(user);\n      var comment;\n      if (newState == 'requested')\n         comment = gs.getMessage(\"Group approval for {0} reset to requested due to user approval change from {1} to requested ({2}).\", [groupName, currentState, activity.activity.name.toString()]);\n      \n      else if (newState == 'approved') {\n         if (user)\n            comment = gs.getMessage(\"Group approval for {0} approved by user {1} ({2}).\", [groupName, userName, activity.activity.name.toString()]);\n         else\n            comment = gs.getMessage(\"Group approval for {0} approved by all users ({1}).\", [groupName, activity.activity.name.toString()]);\n      }\n      \n      else if (newState == 'rejected') {\n         if (user)\n            comment = gs.getMessage(\"Group approval for {0} rejected by user {1} ({2}).\", [groupName, userName, activity.activity.name.toString()]);\n         else\n            comment = gs.getMessage(\"Group approval for {0} rejected by all users ({1}).\", [groupName, activity.activity.name.toString()]);\n      }\n      \n      if (comment)\n         this.approvalUtils.addApprovalHistoryGR(current, comment);\n   },\n\t\n   type: 'Approval___GroupActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_354e911f0a0a029a00e6a0e6ad74206f","js_class_name":"Approval___Group","name":"Approval - Group","attributes":"generate=approval,approval=true","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"Launch either a single sub-flow multiple times, or different sub-flows, all in parallel.\n\nThe preferred usage is to provide a WorkflowCoordinator object as the input variable named 'inputs'.   \n\nThe activity will first look in the workflow scratchpad for an object with the name provided and if not found will check for it as a global variable.\n\nAn alternative usage would be to provide a workflow (name or sys_id) and an array of input variables. \nIn this case, a workflow name or ID must be provided.\n\nBoth parameters are object names but can be derived from scripts by using the javascript: prefix:\n\n// in this example, a factory provides an appropriate WorkflowCoordinator instance which is pre-populated with \n// input variables, and information about which workflow(s) to run.  The workflow field is not used. since this information\n// is provided by the coordinator.\n//\nINPUTS: ${ WorkflowFactory.getChangeManagementWorkflow(current) };\n\n\n\n// in this example a Javascript class named MyWorkflowInputs returns an array of input vars and a workflow name \n// from two separate static methods\n//\nINPUTS:  ${ MyWorkflowInputs.getInputs() }\nWORKFLOW: ${ MyWorkflowInputs.getWorkflow() }\n\n\n","sys_updated_on":"2017-08-04 22:08:32","sys_class_name":"wf_activity_definition","sys_id":"35ef56111b211100adca1e094f071315","sys_updated_by":"harry.nelson@snc","sys_created_on":"2013-12-09 03:28:15","action":"false","sys_name":"Parallel Flow Launcher","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"john.maher","table":"global","image":"images/heisenberg_icons/workflow/parallel.png","default_width":"","base_provider":"","sys_mod_count":"291","sys_tags":"","script":"// Launch multiple flows in parallel.\n//\nvar Parallel_Flow_LauncherActivityHandler = Class.create();\nParallel_Flow_LauncherActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n\tinitialize: function() {\n\t\tWFActivityHandler.prototype.initialize.call(this);\n\t},\n\n\tonExecute: function() {\n\t\t// If we were passed a workflow coordinator as inputs, then just use that.\n\t\t//\n\t\tvar data = this.js(activity.vars.inputs+'');\n\t\t\n\t\n\t\t// If the user selects a workflow by reference, then use it\n\t\t// otherwise use by name-or-id\n\t\t//\n\t\tdata = interpretInputs(this, data);\n\t\tif (data == null)\n\t\t\treturn fault(\"Inputs must be a valid array\");\n\n\t\tvar coordinator = usingWorkflowByReference()\n\t\t\t\t\t\t\t\t? this._getCoordinatorByReference(data) \n\t\t\t\t\t\t\t\t: this._getCoordinatorFromInput(data);\n\n\t\tsetMaxValues(coordinator);\n\t\t\n\t\t// We require inputs in a WorkflowCoordinator object as the 'input' var \n\t\t//\n\t\t// Alternatively if inputs is an array or a script function that generates \n\t\t// an array or a workflow coordinator then that is used. \n\t\t//\n\t\tif (coordinator == null) {\n\t\t    workflow.debug('Parallel_Flow_LauncherActivity: cound not create coordinator');\n\t\t\treturn;\n\t\t}\n\n\t\tif (coordinator.getError() != '')\n            return fault(coordinator.getError());\n\n\t\t// attempt to start first batch of 'poolsize' workflows\n\t\tvar status = coordinator.start(activity);\n\n\t\tswitch (status) {\n\t\t\t\tcase 'finished':\n\t\t\t\t\tactivity.state  = 'waiting';\n\t\t\t\t\tactivity.result = 'finished';\n\t\t\t\t\tworkflow.debug('last flow has completed');\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase 'continuing':\n\t\t\t\t\tactivity.state  = 'waiting';\n\t\t\t\t\tactivity.result = 'continue';\n\t\t\t\t\tworkflow.debug('waiting for more flows to complete');\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase 'waiting':\n\t\t\t\t\tactivity.state  = 'waiting';\n\t\t\t\t\tactivity.result = 'continue';\n\t\t\t\t\tworkflow.debug('waiting for more flows to complete');\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase 'error':\n\t\t\t\t\tworkflow.fault(coordinator.getError());  //faulting sets the state and result\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tactivity.result = 'failure';\n\t\t\t\t\tactivity.state = 'finished';\n\t\t\t\t\tworkflow.debug('ERROR unexpected onFinish state:' + status);\n\t\t\t\t\tbreak;\n\t\t}\n\n\t\t\n        function usingWorkflowByReference() {\n\t\t\treturn !activity.vars.workflow_scripted;\n\t    }\n\t\t\n\n\t\tfunction interpretInputs(self, data) {\n\n            var ary = data;\n\n\t\t\t// if its an array in string form parse and use it\n\t\t\tif (typeof(ary) == 'string') {\n\t\t\t\tdata = data.trim();\n\n                if (data.length == 0)\n                    return [];\n\n                try {\n                    // try pure eval\n                    ary = self.runScript(data);\n                } catch (ex) {\n                    // try decode\n                    ary = new JSON().decode(data); // this.js(data);\n                }\n\n\t\t\t\t//workflow.debug('vars.inputs is:' + JSUtil.describeObject(ary));\n\t\t\t}\n\n\t\t\t// Is it an array?  If so assume an array of inputs for the child\n\t\t\t// flows and the flow to run MUST be provided in the 'workflow'\n\t\t\t// input variable.\n\t\t\tif ( !(ary instanceof Array) ) {\n\t\t\t    // no good!\n\t\t\t\tthis.setResultFailed('Inputs must be a valid array of inputs or a reference to one');\n                return null;\n            }\n\n\t\t\treturn ary;\n\t\t}\n\t\t\n\t\tfunction setMaxValues(coordinator) {\n\t\t\tif (isNumber(activity.vars.max_flows))\n\t\t\t\tcoordinator.setMax(activity.vars.max_flows);\n\t\t\t\n\t\t\tif (isNumber(activity.vars.max_simultaneous))\n\t\t\t\tcoordinator.setPoolsize(activity.vars.max_simultaneous);\n\t\t}\n\t\t\n\t\tfunction isNumber(n) {\n\t\t\treturn n && n.hasValue() && !isNaN(n+'');\n\t\t}\n\n        function fault(msg) {\n            workflow.error(msg);\n\t\t\tactivity.fault_description = msg;\n            activity.result = 'error';\n            activity.state = 'faulted';\n        }\n\t},\n\n\tonFinal: function(eventName, eventParms) {\n\t\tactivity.state  = 'finished';\n\t\tactivity.result = 'success';\n\t\tworkflow.debug('onFinal() - All flows have completed');\n\t},\n\t\n\tonListener: function(eventName, eventParms) {\n\t\tworkflow.debug('onListener eventName=' + eventName + ' - ' + JSUtil.describeObject(eventParms, 'eventParms'));\n\t\t\n\t\t// workflow state changed - are we done?\n\t\tif (eventParms.isComplete) {\n\t\t\t// workflow.debug('Loading WorkflowCoordinator for activity:' + activity.sys_id);\n\t\t\n\t\t    var coordinator = WorkflowCoordinator.load(activity.activity.sys_id+'');\n\n\t\t\t// Have the workflow coordinator process the results and return the status that determines\n\t\t\t// what do do next (wait, continut, finish).  \n\t\t\t//\n\t\t\t// Also puts the global variables 'flow' and 'coordinator' for the advanced scripts. These \n\t\t\t// are available on the 'onFlowCompleted' path too.\n\t\t\t//\n\t\t\tvar status = coordinator.onFinish(eventParms);\n\t\t\t\n\t\t\tswitch (status) {\n\t\t\t\t\n\t\t\t\tcase 'finished':\n\t\t\t\t\tactivity.state  = 'waiting';   // run transitions\n\t\t\t\t\tactivity.result = 'continue';\n\t\t\t\t\tworkflow.debug('last flow has completed');\n\n\t\t\t\t    this._doFlowComplete(coordinator, 'flow',  eventParms.index);\n\t\t\t\t    this._doFlowComplete(coordinator, 'final', eventParms.index);\n\t\t\t\t\t\n\t\t\t\t\t// queue the exit event.\n\t\t\t\t\tnew Workflow().fireEvent(activity, 'final'); \n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase 'continuing':\n\t\t\t\t\tactivity.state  = 'waiting';    // run transitions\n\t\t\t\t\tactivity.result = 'continue';\n\t\t\t\t\tworkflow.debug('waiting for more flows to complete');\n\t\t\t\t    \n\t\t\t\t\tthis._doFlowComplete(coordinator, 'flow', eventParms.index);\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase 'waiting':\n\t\t\t\t\tactivity.state  = 'waiting';\n\t\t\t\t\tactivity.result = 'continue';\n\t\t\t\t\tworkflow.debug('waiting for more flows to complete');\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tcase 'error':\n\t\t\t\t\tactivity.state  = 'finished';\n\t\t\t\t\tactivity.result = 'failure';\n\t\t\t\t\tworkflow.fault(coordinator.getError());\n\t\t\t\t\tbreak;\n\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tactivity.result = 'failure';\n\t\t\t\t\tactivity.state = 'finished';\n\t\t\t\t\tworkflow.debug('ERROR unexpected onFinish state:' + status);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t},\n\t\n\tonCancel: function(eventName, eventParms) {\n\t\tactivity.state = 'cancelled';\n\t\tactivity.result = 'cancelled';\n\t\t\n\t\t// cancel the subflows\n\t\tvar coord = WorkflowCoordinator.load(activity.activity.sys_id + '');\n\t\tcoord.cancel();\n\t},\n\n\t\n\t_doFlowComplete: function(coordinator, completion, index) {\n\t\tvar completion_type = completion + '_completion';\n\t\t\n\t\t// is there a script?\n\t\tif (!activity.vars['use_' + completion_type + '_script'] )\n\t\t\treturn true;\n      \n\t\tvar script = activity.vars[completion_type + '_script'];\n\t\tif (!script)\n\t\t\treturn true;\n\t\t\n\t\tvar result = this._runCompletionScript(coordinator, script, index);\n\t\treturn result+'';\n\t},\n\n\t_runCompletionScript: function(coordinator, script, index) {\n\t\tif (!script)\n\t\t\treturn null;\n\n\t\treturn this.runScript(script);\n\t},\n\t\n\t_getCoordinatorByReference: function(data) {\n\t\tworkflow.debug('_getCoordinatorByReference w='+ activity.vars.workflow);\n\t\treturn new WorkflowCoordinator({\n\t\t\t\t\t\tworkflow: activity.vars.workflow+'',\n\t\t\t\t\t\t  inputs: data,\n\t\t\t\t\t\t   owner: activity.workflow_version.workflow+'',\n\t\t\t\t\t\t   count: activity.vars.count+'',\n\t\t\t                 max: activity.vars.max_flows+'',\n\t\t\t            poolsize: activity.vars.max_simultaneous+''\n\t\t\t\t});\n\t},\n\t\n\t_getCoordinatorFromInput: function(data) {\n\t\tworkflow.debug('_getCoordinatorFromInput w='+ activity.vars.workflowId);\n\n        var wfs = (activity.vars.workflowId+'').trim();\n\n        var wf = this.runScript(wfs);\n\n\t\t// If it is a global and already a WorkflowCoordinator just use it.\n        if (wf instanceof WorkflowCoordinator)\n            return wf;\n\n        // If it is a scratchpad variable and a serialized WorkflowCoordinator, use that!\n        if (workflow.scratchpad.coordinator && workflow.scratchpad.coordinator[wf])\n            return WorkflowCoordinator.load(wf);\n\n        // create a new one.\n\t\treturn new WorkflowCoordinator({\n\t\t\t\t\t   workflow: wf,\n\t\t\t\t\t\t inputs: data,\n\t\t\t\t\t\t  owner: activity.workflow_version.workflow+'',\n\t\t\t\t\t\t  count: activity.vars.count+'',\n\t\t\t                max: activity.vars.max_flows+'',\n\t\t\t           poolsize: activity.vars.max_simultaneous+''\n\t\t\t\t});\n\t},\n\n\t\n   type: 'Parallel_Flow_LauncherActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_35ef56111b211100adca1e094f071315","js_class_name":"Parallel_Flow_Launcher","name":"Parallel Flow Launcher","attributes":"","style":"","category":"Subflows","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Catalog Task activity creates a record on the Catalog Task [sc_task] table.\r\n \r\nUse this activity to create a catalog task for a user to complete.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are: \r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. The final 'State' value of the catalog task record determines the result value for the Create Task activity. Possible result values are: \r\n*Closed complete\r\n*Closed incomplete\r\n*Closed skipped\r\n*Deleted\r\n*Cancelled\r\n \r\nKeep in mind: \r\n*This activity is only accessible for the workflows running on the Catalog Request Item [sc_request_item] table.","sys_updated_on":"2020-04-21 19:11:42","sys_class_name":"wf_activity_definition","sys_id":"38891b6f0a0a0b1e00efdfdd77602027","sys_updated_by":"admin","sys_created_on":"2008-07-18 23:37:56","action":"false","sys_name":"Catalog Task","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"sc_req_item","image":"images/heisenberg_icons/default/catalog.png","default_width":"","base_provider":"","sys_mod_count":"92","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nworkflow.includeActivityDefinition(\"Create Task\");\n\nvar Catalog_TaskActivityHandler = Class.create();\nCatalog_TaskActivityHandler.prototype = Object.extendsObject(Create_TaskActivityHandler, {\n\n    initialize: function() {\n        Create_TaskActivityHandler.prototype.initialize.call(this);\n    },\n\n    onExecute: function() {\n        Create_TaskActivityHandler.prototype.onExecute.call(this);\n        if (activity.scratchpad.taskID) {\n            this._linkTaskToItemVariables();\n        }\n    },\n\n    _linkTaskToItemVariables: function() {\n        var itemNames = [];\n        var wfNames = [];\n        var names = (activity.vars.task_variables + '').split(',');\n        for (var i = 0; i < names.length; i++) {\n            if (names[i].startsWith('wf.'))\n                wfNames.push(names[i].split('.')[1]);\n            else if (names[i])\n                itemNames.push(names[i]);\n        }\n\n        if (itemNames.length > 0)\n            this._getVariables(itemNames);\n\n        if (wfNames.length > 0)\n            this._getWFVars(wfNames);\n    },\n\n    _getWFVars: function(names) {\n        var vars = new GlideRecord(\"wf_variable\");\n        vars.addQuery('name', names);\n        vars.addQuery('workflow', context.workflow_version.sys_id);\n        vars.query();\n        while (vars.next()) {\n            this._insertVariable(vars.sys_id);\n        }\n    },\n\n    _getVariables: function(names) {\n        var sets = [];\n        var setsGr = new GlideRecord('io_set_item');\n        setsGr.addQuery('sc_cat_item', current.cat_item);\n        setsGr.query();\n        while (setsGr.next())\n            sets.push(setsGr.getValue('variable_set'));\n\n        var varsGr = new GlideRecord('item_option_new');\n        var or1 = varsGr.addQuery('cat_item', current.cat_item);\n        or1.addOrCondition('variable_set', sets);\n\n        var or2 = varsGr.addQuery('name', names);\n        or2.addOrCondition('variable_set.internal_name', names);\n\n        varsGr.query();\n        while (varsGr.next())\n            this._insertVariable(varsGr.getUniqueValue());\n    },\n\n    _insertVariable: function(id) {\n        var gr = new GlideRecord('sc_item_variables_task');\n        gr.initialize();\n        gr.setValue('task', activity.scratchpad.taskID);\n        gr.setValue('variable', id);\n        gr.insert();\n    },\n\n    type: 'Catalog_TaskActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_38891b6f0a0a0b1e00efdfdd77602027","js_class_name":"Catalog_Task","name":"Catalog Task","attributes":"generate=task","style":"","category":"Tasks","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Timer activity causes the workflow to pause for a designated time period.  \r\n\r\nUse this activity to insert delays into specific locations within a workflow.\r\n\r\nThe activity state tells the workflow engine how to handle the executing record. Possible state values are:\r\n*Executing: the Timer activity is in this state very briefly while initializing, after which it immediately changes to 'waiting'.\r\n*Waiting: The workflow engine ignores the activity until the timer reach the specified duration. The engine then re-invokes the activity using a timer event to transition the workflow to the next activity.\r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activty, was cancelled.\r\n*Error: a JavaScript error occured. Review the logs for error details.\r\n\r\nPossible result values are:\r\n*Complete: the activity successfully reached the specified duration.\r\n*Cancelled: the activity or workflow was canceled before the timer reached the specified duration.\r\n\r\nPlease be aware that:\r\n*This activity contains script fields. Do not use the current.update() method in these scripts fields as this may cause recursive updates to the current record.","sys_updated_on":"2022-09-22 17:35:20","sys_class_name":"wf_activity_definition","sys_id":"3961a1da0a0a0b5c00ecd84822f70d85","sys_updated_by":"admin","sys_created_on":"2008-02-21 00:29:42","action":"false","sys_name":"Timer","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/timer.png","default_width":"","base_provider":"","sys_mod_count":"323","sys_tags":"","script":"/**\n * Timer Activity used to wait for some amount of time.  \n *  Takes into account the 'activity.scratchpad.timeLeft' (resuming after pause)\n */\n\nvar TimerActivityHandler = Class.create();\nTimerActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n        this._seconds = 0;\n        this._now = new GlideDateTime();\n    },\n   \n   onExecute: function() {\n      var executeDateTime = this._now; // so that we can consistently calculate again, below\n      activity.state = \"waiting\";\n\n      // calculate our duration, from our (possibly) different \"real\" workflow base time rather than the current time\n      // (a relative duration's start time is critical, for getting the correct duration)\n      var timerStartTime = this._calcTimerStartTime(executeDateTime);\n      var baseTime = this._calcDurationBaseTime(executeDateTime);\n      var totalSecs = this._calcTotalDuration(baseTime);     // total (modified) duration time, not including any schedule\n      var secs = this._seconds;                              // total (modified) duration time, within any schedule\n\n      // now, although we have a \"real\" workflow start time to get the correct overall duration,\n      // we actually need to consume that duration from the start time of this Timer\n      var endTime = this._calcEndTime(timerStartTime, secs);\n      var totalSecsLeft = this._getTotalSecsLeft();\n      \n      // set scheduled job (sys_trigger) to run at the end of the required timer duration\n\t   \n\t   if(totalSecsLeft === 0) {\n\t\t   // Refactored to return faster as we don't need to schedule anything here....\n           this.onTimer();\n\t\t   return;\n\t   }\n      var sched = this._getScheduleOnce(totalSecsLeft, endTime);\n      sched.schedule();\n   },\n   \n   onPause: function() {\n      this.debug('Timer paused: ' + this._now);\n      var pauseDateTime = this._now;\n      var timerStartTime = this._calcTimerStartTime(pauseDateTime);\n      \n      // save for resume\n      this._saveTimeLeft(timerStartTime); // store time remaining, (in schedule, if we have one)\n      \n      // cancel this timer so the schedule (trigger) item is no longer valid\n      var s = new Schedule();\n      s.setDocument(activity);\n      s.setLabel(this._getLabel());\n      s.cancel();\n      // also consider that there may be a job pre upgrade\n      s = new Schedule();\n      s.setDocument(activity);\n      s.setLabel(this._getLegacyLabel());\n      s.cancel();\n      this._saveEndTime();  // blank the end time\n   },\n\n   onResume: function() {\n      this.debug('Timer resumed: ' + this._now);\n      var resumeDateTime = this._now; // so that we can consistently calculate again, below\n\n      // calculate our duration, from our (possibly) different \"real\" workflow start time rather than the current time\n      // (a relative duration's start time is critical, for getting the correct duration)\n      var timerStartTime = this._calcTimerStartTime(resumeDateTime);\n      var baseTime = this._calcDurationBaseTime(resumeDateTime);\n      var totalSecs = this._calcTotalDuration(baseTime);        // total duration time, not including any schedule\n      var secs = this._seconds;                                 // total duration time, within any schedule\n\n      var timeLeft = this._getTimeLeft(); // time that is remaining, within the schedule - value left over from ONPAUSE\n      var timeUsed = (secs - timeLeft); // (time used within the schedule)\n\n      // the Timer may have paused before it reached the real start time.\n      // but the end time may be changed if we are resuming after the original real start time\n      var start = resumeDateTime;\n      if (resumeDateTime.compareTo(timerStartTime) < 0)\n         start = timerStartTime;\n\n      // we know how much time is left on the timer\n      // - we need to add the time left onto the current time, or the (future) timer start time\n      var endTime = this._calcEndTime(start, timeLeft);\n\n\t   if(timeLeft === 0) {\n\t\t   // Refactored to return faster as we don't need to schedule anything here....\n           this.onTimer();\n\t\t   return;\n\t   }\n\n      // create new scheduled job (trigger)\n      var sch = this._getScheduleOnce(timeLeft, endTime);\n      sch.schedule();\n   },\n\n   // Overridden by SLA Percentage Timer\n   onTimer: function() {\n      this.debug('Timer complete (endTime ' + activity.scratchpad.endTime + ') ' + this._getLabel());\n      activity.state = 'finished';\n      activity.result = 'complete';\n   },\n\n   onCancel: function() {\n      var s = new Schedule();\n      s.setDocument(activity);\n      s.setLabel(this._getLabel());\n      s.cancel();\n      // also consider that there may be a job pre upgrade\n      s = new Schedule();\n      s.setDocument(activity);\n      s.setLabel(this._getLegacyLabel());\n      s.cancel();\n      this.debug('Timer cancelled');\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n   },\n\n// ---------- internal methods, below ----------\n\n   _getScheduleOnce: function(secs, endTime) {\n      // record when this activity is due to end\n      this._saveEndTime(endTime);\n      if (secs === 0) {\n         this.onTimer();\n         return;\n      }\n\t   \n\n\t  var label = this._getLabel();\n\t  activity.scratchpad.label=label;\n\n      var script = \"var w = new Workflow(); w.fireEvent(current, 'timer');\";\n      var sched = new ScheduleOnce();\n      sched.script = script;\n      sched.setTime(endTime);\n      sched.setDocument(activity);\n      sched.setLabel(label);\n\t   if (this._runDuringUpgrade())\n         sched.setUpgradeSafe(true);\t\t  \n      return sched;\n   },\n\n   _runDuringUpgrade: function() {\n\t   var rduVar = activity.vars.run_during_upgrade;\n\t   if (JSUtil.nil(rduVar) || rduVar.getValue()==\"property\") {\n\t\t   //activity var doesn't have a value (wf published before upgrade to version with the variable)\n\t\t   //or the var is set to None so the property is in charge\n\t\t   return GlideProperties.getBoolean('glide.workflow.timer.upgrade_safe', false);\n\t   } \n\t   //else the activity var exists and should be in charge\n\t   return rduVar.getValue() == \"always\";\n   },\n\n   _getLabel: function() {\n\t   return \"Workflow\"+activity.context;\n   },\n\n   _getLegacyLabel: function() {\n\t   return \"WFTimer\"+activity.sys_id;\n   },\n      \n   _getEndDate: function() {\n      if (activity.scratchpad.endTime)\n         return this._getEndTime();\n      \n      var sch = new GlideRecord('sys_trigger');\n      sch.addQuery('document_key', activity.sys_id);\n      sch.query();\n      \n      var endDate;\n      if (sch.next()) {\n         endDate = sch.next_action;\n      }\n      return endDate;\n   },\n   \n   // Overridden by SLA Percentage Timer\n   _getTotalSecsLeft: function() {\n       return Math.max(0, this._totalSecs);\n   },\n   \n   // store time remaining on the Timer\n   _saveTimeLeft: function(starttime) {\n      // (Relative Durations don't support pausing, so it doesn't matter\n      //  that the start time is not \"fixed\" here)\n      var now = this._now;\n      if (starttime.compareTo(this._now) > 0)\n         // start is in the future, so measure from there instead\n         now = starttime;\n      \n      var totalTimeLeft = this._calcTotalTimeLeft(now, this._getEndDate());\n      var timeLeft = this._remainingSecs;\n      \n      this.debug('_saveTimeLeft: ' + timeLeft);\n      activity.scratchpad.timeLeft = timeLeft;\n   },\n   \n   // get the stored time remaining for this Timer, on resume\n   _getTimeLeft: function() {\n      this.debug('_getTimeLeft: ' + activity.scratchpad.timeLeft);\n      return parseInt(activity.scratchpad.timeLeft,10);\n   },\n   \n   _saveEndTime: function(endtime) {\n      var et = '';\n      if (endtime)\n         et = endtime.getValue();\n      activity.scratchpad.endTime = et;\n   },\n   \n   _getEndTime: function() {\n      this.debug('_getEndTime (scratchpad)=' + activity.scratchpad.endTime);\n      return new GlideDateTime(activity.scratchpad.endTime);\n   },\n\n   // deduce the \"real\" start time of the Timer\n   // Overridden by SLA Percentage Timer\n   _calcTimerStartTime: function(now) {\n      var timerStartTime = new GlideDateTime(now);\n      if (activity.scratchpad.timerStartTime) {\n         timerStartTime = new GlideDateTime(activity.scratchpad.timerStartTime);\n         this.debug('used timerStartTime ' + timerStartTime);\n      }\n      activity.scratchpad.timerStartTime = timerStartTime.getValue();\n      this.debug('timerStartTime=' + timerStartTime);\n      return timerStartTime;\n   },\n   \n   // deduce the start time basis for the durations to be calculated\n   // Overridden by SLA Percentage Timer\n   _calcDurationBaseTime: function(now) {\n       this.debug(\"now=\" + now);\n       var baseTime = new GlideDateTime(now);\n       return baseTime;\n   },\n\n   // calculate the total time remaining\n   // return total number of seconds, \n   // set this._remainingSecs, this._totalRemainingSecs\n   _calcTotalTimeLeft: function(from, to) {\n      var preWd = new WorkflowDuration();\n      if (to.compareTo(from) < 0) {\n         // from is in the future\n         preWd.setStartDateTime(to);\n         preWd.setEndDateTime(from);\n      }\n      else {\n         preWd.setStartDateTime(from);\n         preWd.setEndDateTime(to);\n      }\n      preWd.setWorkflow(context.schedule, context.timezone);\n      preWd.setActivity(this);\n      preWd.calculateTimeLeft(activity.vars.__var_record__);\n      var totalRemainingSecs = preWd.getTotalSeconds();\n      \n      this._remainingSecs = preWd.getSeconds();\n      this._totalRemainingSecs = preWd.getTotalSeconds();\n      return totalRemainingSecs;\n   },\n   \n   // add duration (within schedule) to start time\n   // returns end time,\n   // sets this._endTime, this._totalSecs\n   _calcEndTime: function(start, duration) {\n      var wd = new WorkflowDuration();\n      wd.setStartDateTime(start);\n      wd.setWorkflow(context.schedule, context.timezone);\n      wd.setActivity(this);\n      wd.addSeconds(activity.vars.__var_record__, duration);\n      var totalSecs = wd.getTotalSeconds();\n      var secs = duration;\n      \n      this._endTime = wd.getEndDateTime();\n      this._totalSecs = totalSecs;\n      return this._endTime;\n   },\n   \n   // the whole duration of this Timer\n   _calcTotalDuration: function(start) {\n      var wd = new WorkflowDuration();\n      wd.setStartDateTime(start);\n      wd.setWorkflow(context.schedule, context.timezone);\n      wd.setActivity(this);\n      wd.calculate(activity.vars.__var_record__);\n      var secs = wd.getSeconds();\n      var totalSecs = wd.getTotalSeconds();\n      \n      this._seconds = secs;\n      this._totalSeconds = totalSecs;\n      this._endTime = wd.getEndDateTime();\n      return totalSecs;\n   },\n\n   // for testing purposes only\n   _setStartDateTime: function(start) {\n      this.testing = true;\n      this._now = start;\n   },\n   \n   type: 'TimerActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_3961a1da0a0a0b5c00ecd84822f70d85","js_class_name":"Timer","name":"Timer","attributes":"","style":"","category":"Timers","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Log Message activity writes information to the workflow log.\r\n\r\nUse this activity to add entries to the workflow's log for debugging or tracing purposes. \r\n\r\nThe 'Message' variable stores the data to add to the log. This variable can be a string or a JavaScript expression that evaluates to a string.","sys_updated_on":"2014-10-22 17:27:23","sys_class_name":"wf_activity_definition","sys_id":"396807940a0a0b5c00afd9f67d9fd7a2","sys_updated_by":"harry.nelson","sys_created_on":"2008-02-21 00:32:41","action":"false","sys_name":"Log Message","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/logging.png","default_width":"","base_provider":"","sys_mod_count":"9","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Log_MessageActivityHandler = Class.create();\nLog_MessageActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      this.info(this.js(activity.vars.message));\n   },\n\n   type: 'Log_MessageActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_396807940a0a0b5c00afd9f67d9fd7a2","js_class_name":"Log_Message","name":"Log Message","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Approval - User activity creates a user approval record or a set of user approval records.\r\n\r\nUse this activity to request approval records from individual users or users within a group.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity. \r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity or the workflow that contains this activity was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value is the final approval disposition. This disposition depends on the actions taken by the approvers and the conditions specified in the 'Wait for' and 'When Anyone Rejects' fields. Possible result values are: \r\n*Approved\r\n*Rejected\r\n*Skipped\r\n*Deleted\r\n*Cancelled\r\n\r\nKeep in mind: \r\n*This activity contains script fields. Do not use the current.update() method in these script fields because this may cause recursive updates to the current record.\r\n*If the activity cannot find records for the approvers assigned in the 'User' field, the default result of the approval is 'Skipped' and the workflow moves through the Approved transition.","sys_updated_on":"2014-06-13 17:47:41","sys_class_name":"wf_activity_definition","sys_id":"435603515f112100a9ad2572f2b477f5","sys_updated_by":"admin","sys_created_on":"2014-06-13 16:04:28","action":"false","sys_name":"Service Approval - User","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"images/workflow/approval_user.gif","default_width":"","base_provider":"","sys_mod_count":"2","sys_tags":"","script":"var Service_Approval___UserActivityHandler = Class.create();\nService_Approval___UserActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\t\n\tinitialize: function() {\n\t\tWFActivityHandler.prototype.initialize.call(this);\n\t\tthis.approvalUtils = new WorkflowApprovalUtils();\n\t\tthis.setDatesFlag = false;\n\t},\n\t\n\tonExecute: function() {\n\t\t/**\n \t\t* Create the approvals and wait for them to either be approved or rejected.\n \t\t*/\n\t\t\n\t\tvar approvals = this._createApprovals('requested');\n\t\t\n\t\t// any approvals?\n\t\tif (approvals.length == 0)\n\t\t\tactivity.result = 'skipped';\n\t\telse\n\t\t\tactivity.state = 'waiting';\n\t\t\n\t\t// save the list of approval ids\n\t\tactivity.scratchpad.approval_ids = approvals;\n\t\t\n\t\tthis._onUpdate();\n\t},\n\t\n\tonDetermineApprovalState: function() {\n\t\tthis._onUpdate();\n\t},\n\t\n\t// The task has changed, see if we need to update our approval state\n\tonUpdate: function() {\n\t\tthis._onUpdate();\n\t},\n\t\n\t// override this to provide the proper stage state\n\tgetFinalStageState: function() {\n\t\treturn new WFApprovalStages().getApprovalState(current, current.stage, activity);\n\t},\n\t\n\t_onUpdate: function() {\n\t\tvar state = this._determineOverallState();\n\t\tif (state && (state != 'requested')) {\n\t\t\tthis.approvalUtils.setPendingUserApprovalsByIds(activity.scratchpad.approval_ids, 'not_required');\n\t\t\tactivity.state = 'finished';\n\t\t\tactivity.result = state;\n\t\t} else if ((state == 'requested') && (activity.result != state)) {\n\t\t\t// changed back to requested state (unapprove can do this)\n\t\t\tactivity.state = 'waiting';\n\t\t\tactivity.result = '';\n\t\t}\n\t},\n\t\n\t// The approval was cancelled\n\tonCancel: function() {\n\t\tthis.approvalUtils.setPendingUserApprovalsByIds(activity.scratchpad.approval_ids, 'cancelled');\n\t\tactivity.state = 'cancelled';\n\t\tactivity.result = 'cancelled';\n\t},\n\t\n\t// Create the approval(s) based on the variables that are specified\n\t_createApprovals: function() {\n\t\tvar userIds = this._getUserIds();\n\t\tvar approvalIds = this._buildApprovals(userIds);\n\t\treturn approvalIds;\n\t},\n\t\n\t_getUserIds: function() {\n\t\tvar users = {};\n\t\t\n\t\tvar ids = this.runScript(activity.vars.approver_script);\n\t\tif (ids) {\n\t\t\tif (typeof(ids) == 'string')\n\t\t\t\tids = ids.split(',');\n\t\t\t\n\t\t\tthis.approvalUtils.addUsersAndGroupsToApprovalList(users, {}, ids);\n\t\t}\n\t\t\n\t\treturn users;\n\t},\n\t\n\t_buildApprovals: function(userIds) {\n\t\tvar approvalIds = [];\n\t\tfor (var id in userIds)\n\t\t\tapprovalIds.push(this._createApproval(id));\n\t\t\n\t\treturn approvalIds;\n\t},\n\t\n\t/**\n \t* Create a new use approval or update an existing user approval\n \t*/\n\t_createApproval: function(userId) {\n\t\tvar approvalId = this._createNewApproval(userId);\n\t\treturn approvalId;\n\t},\n\t\n\t//fdt- expanding approval - user to be generic. To that end, back-setting the legacy taks\n\t//values for backwards compatability, but going forward adding document_id/source table\n\t//sysapproval is only valid if the table is of type task, otherwise\n\t//the type approval is for a non-task derived table in which case the document_id\n\t//is derived from the current.getUniqueValue() and getRecordClassName();\n\t\n\t_createNewApproval: function(userId) {\n\t\tvar approval = new GlideRecord('sysapproval_approver');\n\t\tapproval.initialize();\n\t\tvar table = current.getRecordClassName();\n\t\tvar guid = current.getUniqueValue();\n\t\tapproval.sysapproval = current.sys_id;\n\t\tapproval.sysapproval.setRefRecord(current);\n\t\tapproval.document_id = guid;\n\t\tapproval.document_id.setRefRecord(current);\n\t\tapproval.source_table = table;\n\t\tapproval.approver = userId;\n\t\tapproval.approval_column = 'approval';\n\t\tapproval.approval_journal_column = 'approval_history';\n\t\tapproval.wf_activity = activity.activity.sys_id;\n\t\tapproval.state = 'requested';\n\t\treturn approval.insert();\n\t},\n\t\n\t// Determine the overall state of the approvals (approved, rejected or '')\n\t_determineOverallState: function() {\n\t\tvar ids = activity.scratchpad.approval_ids;\n\t\tif (!ids)\n\t\t\treturn 'approved';\n\t\t\n\t\tvar ret = this.approvalUtils.getUserIdListApprovalCounts(ids);\n\t\t\n\t\tret.counts['total'] -= ret.counts['not_required'];\n\t\tret.counts['total'] -= ret.counts['cancelled'];\n\t\tif (ret.counts['total'] == 0)\n\t\t\treturn 'skipped';\n\t\t\n\t\tif (ret.counts['rejected'] > 0)\n\t\t\treturn 'rejected';\n\t\t\n\t\tif (ret.counts['approved'] > 0)\n\t\t\treturn 'approved';\n\t\t\n\t\tif ((ret.counts['rejected'] + ret.counts['approved']) == ret.counts['total']) {\n\t\t\t// we are complete - we have to make a decision\n\t\t\treturn 'rejected';\n\t\t}\n\t\t\n\t\treturn 'requested';\n\t},\n\t\n\ttype: 'Service_Approval___UserActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/696867b304f12210559073c06a02f721","value":"696867b304f12210559073c06a02f721"},"sys_update_name":"wf_activity_definition_435603515f112100a9ad2572f2b477f5","js_class_name":"Service_Approval___User","name":"Service Approval - User","attributes":"generate=approval","style":"","category":"","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Generate activity immediately creates task or approval records from any task or approval activities placed after the Generate activity in the workflow execution path. Without the Generate activity, the workflow waits to create any records until reaching the associated activity.\r\n\r\nUse this activity to create task or approval records before the workflow reaches the task or approval activity.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n\r\nKeep in mind: \r\n*To prevent the Generate activity from creating records from certain activities, select the 'Skip during generate' check box on the task or approval activity you want to skip.","sys_updated_on":"2017-04-14 20:32:57","sys_class_name":"wf_activity_definition","sys_id":"452273c50a6a803f275dce98b4fa1a50","sys_updated_by":"cmitchell","sys_created_on":"2008-10-28 20:27:50","action":"false","sys_name":"Generate","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task","image":"images/heisenberg_icons/workflow/generate.png","default_width":"","base_provider":"","sys_mod_count":"68","sys_tags":"","script":"/**\n * Generate all approvals and/or tasks in the workflow, setting the order based on the\n * activity's (shortest path) level in the workflow\n */\nvar GenerateActivityHandler = Class.create();\nGenerateActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() { \n\t  this.activity = activity;\n\t   \n\t  if ((typeof SNC.WorkflowPaths) != 'undefined')\n\t\t  this._generateAprovalsAndTasks();\n\t  else\n\t\t  this._generateActivities();\n   },\n\t\n   /**\n \t* As we generate tasks and approvals, we keep track of\n \t* their duration.  For each path along the workflow, we bump the starting\n \t* time we have computed so far using the following algorithm:\n \t*\n \t* \t\tfor a task or approval\n \t* \t\t\tif the start time is earlier than the previous start time\n \t* \t\t\t\twe encountered (in case we see the task/approval more\n \t* \t\t\t\tthan once) - use the earlier start time\n \t*\n \t* \t\tfor a join activity\n \t* \t\t\tif the start time is later than the previous start time\n \t* \t\t\t\twe encountered, use the later start time (this ensures\n \t* \t\t\t\tthat we use the longest path to the join since the\n \t* \t\t\t\tjoin waits for all predecessors to complete)\n \t*/\n\t_generateAprovalsAndTasks: function() {\n\t\tvar paths = new SNC.WorkflowPaths(context.workflow_version.sys_id.getGlideRecord());\n\t\tthis.activitiesMap = paths.getGenerateActivities(this.activity.activity.sys_id.toString());\n\t\tfor (var a = 0; a < this.activitiesMap.size(); a++) {\n\t\t\tvar activity = this.activitiesMap.get(a);\n\t\t\tif (activity.get(\"type\").indexOf(\"generate=approval\") >= 0)\n\t\t\t\tstartDateTime = this._generateNewApproval(activity);\n\t\t\t\n\t\t\tif (activity.get(\"type\").indexOf(\"generate=task\") >= 0)\n\t\t\t\tstartDateTime = this._generateNewTask(activity);\n\t\t}\n\t},\n\t\n\t_generateNewApproval: function(activity) {\n\t   this.generate(activity.get(\"sys_id\"), activity.get(\"order\"), activity.get(\"start\"), this.activity.vars.generate_approvals == false);\n    },\n   \n    _generateNewTask: function(activity) {\n       this.generate(activity.get(\"sys_id\"), activity.get(\"order\"), activity.get(\"start\"), this.activity.vars.generate_tasks == false);\n    },\n   \n   /**\n    * We need to walk each sequence that has conditions that are not skipped\n    * during generate.  As we generate tasks and approvals, we keep track of\n    * their duration.  For each path along the workflow, we bump the starting\n    * time we have computed so far using the following algorithm:\n    *\n    * \t\tfor a task or approval\n    * \t\t\tif the start time is earlier than the previous start time\n    * \t\t\t\twe encountered (in case we see the task/approval more\n    * \t\t\t\tthan once) - use the earlier start time\n    *\n    * \t\tfor a join activity\n    * \t\t\tif the start time is later than the previous start time\n    * \t\t\t\twe encountered, use the later start time (this ensures\n    * \t\t\t\tthat we use the longest path to the join since the\n    * \t\t\t\tjoin waits for all predecessors to complete)\n    */\n   _generateActivities: function() {\n\t  this.walker = new WalkWorkflow(context.workflow_version.sys_id.getGlideRecord());\n      this.walker.walk();\n\t   \n      this.joins = {};\n      this.visited = {};\n      this.ofInterest = {};\n      this.ofInterest[this.activity.activity.sys_id.toString()] = true;\n      this.startDateTime = new GlideDateTime();\n      for (var i = 0; i < this.walker.sequences.length; i++)\n         this._generateSequence(this.walker.sequences[i]);\n\n      this.walker = null;\n   },\n   \n   _generateSequence: function(seq) {\n      if (seq.length == 0)\n         return;\n      \n      var startDateTime = new GlideDateTime(this.startDateTime);\n      // skip any activities that are not of interest\n      var ndx = 0;\n      while (ndx < seq.length) {\n         var id = seq[ndx];\n         if (this.ofInterest[id])\n            break;\n         \n         if (!this.walker.activities[id].isJoin)\n            this.visited[id] = new GlideDateTime(startDateTime);\n         \n         ndx++;\n      }\n      \n      while (ndx < seq.length) {\n         startDateTime = this._generateActivityID(seq[ndx], startDateTime);\n         ndx++;\n      }\n   },\n   \n   _generateActivityID: function(id, startDateTime) {\n      if (this.visited[id])\n         return this.visited[id];\n      \n      var a = this.walker.activities[id];\n      if (!a || !a.attributes)\n         return startDateTime;\n      \n      return this._generateActivity(a, startDateTime);\n   },\n   \n   _generateActivity: function(a, startDateTime) {\n      var id = a.sys_id;\n      if (a.attributes.indexOf(\"generate=approval\") >= 0) {\n         startDateTime = this._generateApproval(a, startDateTime);\n         this.visited[id] = new GlideDateTime(startDateTime);\n         return startDateTime;\n      }\n      \n      if (a.attributes.indexOf(\"generate=task\") >= 0) {\n         startDateTime = this._generateTask(a, startDateTime);\n         this.visited[id] = new GlideDateTime(startDateTime);\n         return startDateTime;\n      }\n      \n      // generate any children if we have them\n      if (a.children.length > 0) {\n         var newStartDateTime = new GlideDateTime(startDateTime);\n         for (var i = 0; i < a.children.length; i++) {\n            var sdt = this._generateActivity(a.children[i], new GlideDateTime(startDateTime));\n            if (sdt.compareTo(newStartDateTime) > 0)\n               newStartDateTime = sdt;\n         }\n         this.visited[id] = new GlideDateTime(newStartDateTime);\n         return newStartDateTime;\n      }\n      \n      if (a.isJoin) {\n         // if we process a join then it is ofInterest since the sequences\n         // are broken at the joins\n         this.ofInterest[id] = true;\n         var join = new GlideDateTime(startDateTime);\n         if (this.joins[id]) {\n            var sdt = this.joins[id];\n            if (sdt.compareTo(startDateTime) > 0)\n               join = sdt;\n         }\n         this.joins[id] = join;\n         return join;\n      }\n      \n      this.visited[id] = new GlideDateTime(startDateTime);\n      return startDateTime;\n   },\n   \n   _generateApproval: function(a, startDateTime) {\n\t   var duration = this.generate(a.sys_id, a.order, startDateTime.getValue(), this.activity.vars.generate_approvals == false);\n       startDateTime.add(duration);\n       return startDateTime;\n   },\n   \n   _generateTask: function(a, startDateTime) {\n      var duration = this.generate(a.sys_id, a.order, startDateTime.getValue(), this.activity.vars.generate_tasks == false);\n      startDateTime.add(duration);\n      return startDateTime;\n   },\n   \n   type: 'GenerateActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_452273c50a6a803f275dce98b4fa1a50","js_class_name":"Generate","name":"Generate","attributes":"","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"Scriptable order guides allow customers to make a single service catalog request that can generate several ordered items.\r\n\r\nAdministrators can configure order guides to run automatically, from a workflow or a script to generate a set of ordered items without manually submitting a service catalog request. \r\nFor example, an onboarding workflow for a new employee can run an order guide to automatically order items for that employee.\r\n\r\nKeep in mind: \r\n*This activity will automatically create a service catalog request.\r\n\r\n**For more info: http://docs.servicenow.com/?context=Running_Order_Guides_Automatically","sys_updated_on":"2014-02-18 11:09:45","sys_class_name":"wf_activity_definition","sys_id":"46359d4e373111003e7d40ed9dbe5d55","sys_updated_by":"admin","sys_created_on":"2013-12-23 16:08:11","action":"false","sys_name":"Scriptable Order Guide","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"14","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Scriptable_Order_GuideActivityHandler = Class.create();\nScriptable_Order_GuideActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n    WAITING: \"waiting\",\n    FINISHED: \"finished\",\n    SUCCESS: \"success\",\n    FAILURE: \"failure\",\n    EMPTY_JSON: \"{}\",\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n        this._log = new GSLog(sc_.LOG_LEVEL, this.type).setLog4J();\n    },\n\n    onExecute: function() {\n        var orderGuideId = activity.vars.order_guide_id + \"\";\n        var json = this._getJSON();\n        this._log.debug(\"[onExecute] JSON: \" + json);\n\n        var sog = new SNC.ScriptableOrderGuide(orderGuideId, current.getTableName(), current.sys_id + \"\", activity.activity + \"\");\n        var result = sog.process(json);\n\n        this._processResult(result, sog);\n    },\n\n    onReprocess: function() {\n        var failure = this._getFailureRecord(current);\n        if (!failure) {\n            this._log.debug(\"[onReprocess] This is not the activity you are looking for!\");\n            return;\n        }\n\n        this._log.debug(\"[onReprocess] Reprocessing activity\");\n        var sog = new SNC.ScriptableOrderGuide(failure.order_guide + \"\", current.getTableName(), current.sys_id + \"\", activity.activity + \"\");\n        var result = sog.reprocess(failure);\n\n        this._processResult(result, sog);\n    },\n\n    onDelete: function() {\n        activity.state = this.FINISHED;\n        activity.result = this.FAILURE;\n        \n        this._log.debug(\"[onDelete] setting activity.result = \" + activity.result);\n        this._log.debug(\"[onDelete] setting activity.state = \" + activity.state);\n    },\n\n    _processResult: function(result, sog) {\n        this._log.debug(\"[_processResult] Result = \" + result);\n        \n        if (result) {\n            if (sog.getRequest() != null)\n                workflow.scratchpad.sc_request = sog.getRequest().sys_id + \"\";\n\n            activity.state = this.FINISHED;\n            activity.result = this.SUCCESS;\n            this._log.debug(\"[_processResult] setting activity.result = \" + activity.result);\n        } else\n            activity.state = this.WAITING;\n\n        this._log.debug(\"[_processResult] setting activity.state = \" + activity.state);\n    },\n\n    _getFailureRecord: function(sourceGR) {\n        var gr = new GlideRecord(sc_.SCRIPTABLE_ORDER_GUIDE_FAILURE);\n        gr.addQuery(\"source_table\", sourceGR.getTableName());\n        gr.addQuery(\"source_document\", sourceGR.sys_id);\n        gr.addQuery(\"wf_activity\", activity.activity);\n        gr.query();\n        if (gr.next()) {\n            this._log.debug(\"[_getFailureRecord] Failure record found\");\n            return gr;\n        }\n\n        this._log.debug(\"[_getFailureRecord] Failure record not found\");\n        return null;\n    },\n\n    _getJSON: function() {\n        var script = activity.vars.script + \"\";\n        if (!script)\n            return this.EMPTY_JSON;\n\n        var answer = this.runScript(script);\n        if (!answer)\n            return this.EMPTY_JSON;\n\n        return answer;\n    },\n\n    type: \"Scriptable_Order_GuideActivityHandler\"\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/3028ab3304f12210559073c06a02f7b7","value":"3028ab3304f12210559073c06a02f7b7"},"sys_update_name":"wf_activity_definition_46359d4e373111003e7d40ed9dbe5d55","js_class_name":"Scriptable_Order_Guide","name":"Scriptable Order Guide","attributes":"","style":"","category":"Service Catalog","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Approval Action activity marks the current task record as approved or rejected.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity or the workflow that contains this activity was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n  \r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value of the activity is the final approval disposition selected by the approver. Possible result values are:  \r\n*Approved\r\n*Rejected\r\n\r\nKeep in mind:\r\n*When an Approval Action activity marks a task as approved, the activity marks all pending approvals as 'No Longer Required'. This activity behaves differently than the Set Values or Run Script activities when used to set the 'Approval' field value.","sys_updated_on":"2015-05-07 22:10:56","sys_class_name":"wf_activity_definition","sys_id":"50a78fa50a6a803f66d064255f7201a5","sys_updated_by":"rick.crawford","sys_created_on":"2008-10-31 02:11:13","action":"false","sys_name":"Approval Action","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/approval_action.png","default_width":"","base_provider":"","sys_mod_count":"33","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Approval_ActionActivityHandler = Class.create();\nApproval_ActionActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n \n     var approvalUtils = new WorkflowApprovalUtils();\n     var apGr = approvalUtils.getApprovalRecord( current.sys_id );\n\n     var col = 'approval';\n     if( apGr.next() ){\n         col = apGr.approval_column.nil() ? col : apGr.getValue('approval_column');\n     }\n    \n     // implement activity definition code here\n     var action = activity.vars.action;\n     if (action == 'approved' || action == 'rejected' || action == 'requested')\n         current.setValue(col,action);\n     else if (action == 'moot') {       \n         approvalUtils.setPendingGroupApprovalsByTask(current.sys_id, 'not_required');\n         approvalUtils.setPendingUserApprovalsByTask(current.sys_id, 'not_required');\n     }\n \n   },\n\n   type: 'Approval_ActionActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_50a78fa50a6a803f66d064255f7201a5","js_class_name":"Approval_Action","name":"Approval Action","attributes":"approval=true","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Manual Approvals activity watches and manages any approvals that users add outside of the workflow process. This activity does not create approval records.\n\nUse this activity to pause the workflow when a user adds a manual approval to a record with an associated workflow. The workflow waits for the approval to be completed before proceeding.\n\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\n*Executing: the workflow engine starts the 'run' function of the activity.\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired.\n*Finished: the activity finished running. See the result value for the outcome of the activity.\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\n*Error: a JavaScript error occurred. Review the logs for error details.\n\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value of Manual Approvals is the final disposition determined by the actions approvers take. Possible result values are:\n*Approved\n*Rejected\n*Deleted\n*Cancelled\n*Error\n\nKeep in mind:\nIf there are no pending manual approvals when this activity executes, the activity immediately completes with a result of 'approved'.","sys_updated_on":"2019-05-03 17:54:40","sys_class_name":"wf_activity_definition","sys_id":"533e39330a6a803f54a9619525b0a7e7","sys_updated_by":"david.airmet@snc","sys_created_on":"2008-10-31 14:14:42","action":"false","sys_name":"Manual Approvals","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task","image":"images/heisenberg_icons/workflow/approval_manual.png","default_width":"","base_provider":"","sys_mod_count":"95","sys_tags":"","script":"/**\n * Handle manual user and group approvals that the user has added to the task.\n * Since these approvals are not managed by any workflow activity, we have to\n * watch these from this activity instead.\n **/\nvar Manual_ApprovalsActivityHandler = Class.create();\nManual_ApprovalsActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n      this.approvalUtils = new WorkflowApprovalUtils();\n   },\n\n   onExecute: function() {\n      // Go ahead and request all of the pending approvals\n      this._requestApprovals('onExecute');\n\n      // Determine our overall state since there usually are no manual approvals\n      if (activity.state != 'finished')\n         activity.state = 'waiting';\n   },\n\n   // The task has changed, see if we need to update our approval state\n   onUpdate: function() {\n      this._onUpdate();\n   },\n\n   // The approval was cancelled\n   onCancel: function() {\n      var ids = this._getApprovalIds();\n      this.approvalUtils.setPendingGroupApprovalsByIds(ids, 'cancelled');\n      this.approvalUtils.setPendingUserApprovalsByIds(ids, 'cancelled');\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n   },\n\n   onDetermineApprovalState: function() {\n\t   this._onUpdate();\n   },\n\n   _onUpdate: function() {\n       // PRB1115684: There was a bug that allowed a Manual Approval activity to\n\t   // restart after an update when contained in an executing Approval Coordinator\n\t   // Added property to preserve the behavior for existing customers\n\t   if (gs.getProperty('glide.manual.approval.pickup_on_update', \"false\") == \"true\")\n\t     this._requestApprovals('_onUpdate');\n\n\t   var ids = this._getApprovalIds();\n       var state = this._determineOverallState(ids);\n       if (activity.result != state) {\n           if ((state == 'approved') || (state == 'rejected') || (state == 'skipped')) {\n               this.approvalUtils.setPendingGroupApprovalsByIds(ids, 'not_required');\n               this.approvalUtils.setPendingUserApprovalsByIds(ids, 'not_required');\n               activity.state = 'finished';\n               activity.result = state;\n           } else if (state == 'requested') {\n        \t   // changed back to requested state (unapprove can do this)\n               activity.state = 'waiting';\n               activity.result = '';\n           }\n       }\n   },\n\n   _requestApprovals: function(eventHandler) {\n\t  var approvals = [];\n\t  var approvalIds = [];\n\t  var approvalGroupIds = [];\n\t  var approvalIdsObject = activity.scratchpad;\n\t  var siblingGroupIds = {};\n\n      // If the property glide.manual.approval.pickup_on_update is true will come through to pick\n      // up any new approvals every update, we don't want to wipe out our existing approval maps\n\t  if (activity.scratchpad != null && activity.scratchpad != \"\") {\n\t\t  approvalIds = activity.scratchpad[\"approval_ids\"];\n\n\t\t  var keys = Object.keys(activity.scratchpad);\n\t\t  for (var k in keys) {\n\t\t\t  if (keys[k] == \"approval_ids\" || keys[k] == \"approver_objects\")\n\t\t\t\t  continue;\n\n\t\t\t  approvalIdsObject[keys[k]] = activity.scratchpad[keys[k]];\n\t\t  }\n\t  }\n\n\t  if (eventHandler != \"onExecute\" && activity.activity.parent != undefined && !GlideStringUtil.nil(activity.activity.parent)) {\n\t\t  // Get all groups approvals for sibling activities.\n\t\t  var siblingGroups = new GlideRecord(\"sysapproval_group\");\n\t\t  siblingGroups.addQuery('wf_activity.parent', activity.activity.parent);\n\t\t  siblingGroups.addQuery('wf_activity', '!=', activity.activity.sys_id);\n\t\t  siblingGroups.addQuery('parent', current.getUniqueValue());\n\t\t  siblingGroups.addQuery('approval', 'not requested').addOrCondition('approval', 'requested');\n\t\t  siblingGroups.query();\n\t\t  while (siblingGroups.next())\n\t\t\t siblingGroupIds[siblingGroups.getValue('assignment_group')] = siblingGroups.getUniqueValue();\n\t  }\n\n\t  // Request all Group Approvals\n\t  var group = new GlideRecord('sysapproval_group');\n\t  group.addQuery('parent', current.sys_id);\n\t  group.addQuery('approval', 'not requested').addOrCondition('approval', 'requested');\n\t  var groupActivityQuery = group.addNullQuery('wf_activity');\n\t  if (eventHandler === \"onExecute\")\n\t\tgroupActivityQuery.addOrCondition('wf_activity', activity.activity.sys_id);\n\t  group.orderBy('sys_created_on','ASC');\n\t  group.query();\n\t  while (group.next()) {\n\t\t  var groupApprovalId = group.getUniqueValue();\n\t\t  var groupId = group.assignment_group;\n\t\t  if (!approvalIdsObject[groupId] && siblingGroupIds[groupId] == undefined) {\n\t\t\t  approvalIds.push(groupApprovalId);\n\t\t\t  approvalGroupIds.push(groupApprovalId);\n\t\t\t  approvalIdsObject[groupId] = true;\n\t\t\t  group.setValue('approval', 'requested');\n\t\t\t  group.setValue('wf_activity', activity.activity.sys_id);\n\t\t\t  group.update();\n\t\t  } else {\n\t\t\t  this.approvalUtils.addApprovalHistoryGR(current, gs.getMessage(\"Duplicate group approval removed for {0}.\", [ group.assignment_group.name.toString() ]));\n\t\t\t  group.setWorkflow(false);\n\t\t\t  group.deleteRecord();\n\t\t  }\n\n\t\t  // get all user approvals\n\t\t  approvals = this._getUserApprovals(groupApprovalId);\n\t\t  activity.scratchpad[groupApprovalId] = approvals;\n\t  }\n\n\t  // Request all User Approvals\n      var approvalsGR = new GlideRecord('sysapproval_approver');\n\t  approvalsGR.addQuery('sysapproval', current.sys_id);\n\t  var qc = approvalsGR.addQuery('state', 'not requested');\n\t  qc.addOrCondition('state', 'requested');\n\t  qc.addOrCondition('group', approvalGroupIds);\n\t  userActivityQuery = approvalsGR.addNullQuery('wf_activity');\n\t  if (eventHandler === \"onExecute\")\n\t\tuserActivityQuery.addOrCondition('wf_activity', activity.activity.sys_id);\n\t  approvalsGR.query();\n\t  while (approvalsGR.next()) {\n\t\t  var approvalId = approvalsGR.getUniqueValue();\n\t\t  var userId = approvalsGR.approver;\n\t\t  approvalIds.push(approvalId);\n\t\t  approvalIdsObject[userId] = true;\n\t\t  approvalsGR.setValue('state', 'requested');\n\t\t  approvalsGR.setValue('wf_activity', activity.activity.sys_id);\n\t\t  approvalsGR.update();\n\t  }\n\n\t  if (approvalIds.length == 0) {\n\t\t  activity.state = \"finished\";\n\t      activity.result = \"skipped\";\n\t  }\n\n\t  activity.scratchpad.approval_ids = approvalIds;\n   },\n\n\t_getUserApprovals: function(groupId) {\n\t\tvar approvals = [];\n\t\tvar approvalsGR = new GlideRecord(\"sysapproval_approver\");\n\t\tapprovalsGR.addQuery(\"group\", groupId);\n\t\tapprovalsGR.query();\n\t\twhile (approvalsGR.next())\n\t\t\tapprovals.push(approvalsGR.getUniqueValue());\n\n\t\treturn approvals;\n\t},\n\n\t// Get the list of manual user and group approvals\n    _getApprovalIds: function() {\n\t   // Jakarta:\n\t   // We now track the approvals in the scratchpad for better\n\t   // detection of duplicate user approvals that were deleted\n\t   if (GlideStringUtil.notNil(activity.scratchpad.approval_ids)) {\n\t\t   return activity.scratchpad.approval_ids;\n\t\t}\n\n       var ids = [];\n       var gr = new GlideRecord('sysapproval_group');\n       gr.addQuery('parent', current.sys_id);\n       gr.addNullQuery('wf_activity');\n       gr.query();\n       while (gr.next())\n          ids.push(gr.sys_id.toString());\n\n       var gr = new GlideRecord('sysapproval_approver');\n       gr.addQuery('sysapproval', current.sys_id);\n       gr.addNullQuery('group');\n       gr.addNullQuery('wf_activity');\n       gr.query();\n       while (gr.next())\n          ids.push(gr.sys_id.toString());\n\n\t   return ids;\n   },\n\n   // Determine the overall state of the approvals (approved, rejected or '')\n   _determineOverallState: function(ids) {\n\t  if (ids.length == 0)\n         return 'skipped';\n\n      var changed = false;\n      var groupApprovals = new GlideRecord('sysapproval_group');\n      groupApprovals.addQuery('sys_id', ids);\n      groupApprovals.query();\n      while (groupApprovals.next()) {\n         if (this._determineGroupState(groupApprovals))\n            changed = true;\n      }\n\n      var waitFor = activity.vars.wait_for;\n      var rejectHandling = activity.vars.reject_handling;\n      var groupRet = this.approvalUtils.getGroupIdListApprovalCounts(ids);\n      var ret = this.approvalUtils.getUserIdListApprovalCounts(ids);\n\n      for (var s in ret.counts) {\n         if (groupRet.counts[s])\n            ret.counts[s] += groupRet.counts[s];\n      }\n\n      ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0)\n         return 'skipped';\n\n      if ((ret.counts['rejected'] > 0) && (rejectHandling == 'reject'))\n         return 'rejected';\n\n      if ((waitFor == 'any' || waitFor == 'first') && (ret.counts['approved'] > 0))\n         return 'approved';\n\n      if ((waitFor == 'first') && (ret.counts['rejected'] > 0))\n         return 'rejected';\n\n      if ((waitFor == 'all') && (ret.counts['approved'] == ret.counts['total']))\n         return 'approved';\n\n      if ((ret.counts['rejected'] + ret.counts['approved']) == ret.counts['total']) {\n         // we are complete - we have to make a decision\n         return 'rejected';\n      }\n\n      return 'requested';\n   },\n\n   // Determine approval state for a group approval\n   _determineGroupState: function(gr) {\n      if (gr.admin_override)\n         return true; // force a determination of overall state since this might be the first change for admin override\n      var currentState = gr.approval + '';\n      if ((currentState == 'not_required') ||\n         (currentState == 'not requested') ||\n      (currentState == 'cancelled'))\n      return false;\n\n      var waitFor = gr.wait_for;\n      var rejectHandling = gr.reject_handling;\n      var newState = \"requested\";\n      var user;\n      var mootPeers = false;\n\n\t  // Jakarta:\n\t  // We now track the approvals in the scratchpad for better\n\t  // detection of duplicate user approvals that were deleted\n      var ret = {};\n\t  if (GlideStringUtil.notNil(activity.scratchpad[gr.sys_id]))\n\t\t  ret = this.approvalUtils.getGroupUserApprovalCounts(activity.scratchpad[gr.sys_id]);\n\t  else\n\t\t  ret = this.approvalUtils.getUserGroupApprovalCounts(gr.sys_id);\n\n\t  ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0) {\n         newState = 'approved';\n         mootPeers = true;\n\n      } else if ((waitFor == 'first') && (ret.counts['rejected'] > 0)) {\n         // first response with a rejection\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n         mootPeers = true;\n\n      } else if ((waitFor == 'first') && (ret.counts['approved'] > 0)) {\n         // first response with an approval\n         newState = 'approved';\n         user = ret.approvalIDs['approved'][0];\n         mootPeers = true;\n\n      } else if ((rejectHandling == 'reject') && (ret.counts['rejected'] > 0)) {\n         // first reject and rejection handling is reject immed.\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n         mootPeers = true;\n\n      } else if ((waitFor == 'any') && (ret.counts['approved'] > 0)) {\n         // any approval and we have one\n         newState = 'approved';\n         user = ret.approvalIDs['approved'][0];\n         mootPeers = true;\n\n      } else if ((waitFor == 'all') && (ret.counts['approved'] == ret.counts['total'])) {\n         // all approval and we have all\n         newState = 'approved';\n         mootPeers = true;\n\n      } else if ((waitFor == 'any') && (ret.counts['rejected'] == ret.counts['total'])) {\n         // any approval, but everyone has rejected\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n      }\n\n      if (newState && (currentState != newState)) {\n         gr.approval = newState;\n         if (user)\n            gr.approval_user = user;\n         else if (newState == 'requested')\n            gr.approval_user = \"\";\n\n         this._setGroupApprovalComment(gr, currentState, newState, user);\n\n         gr.update();\n         return true;\n      }\n      return false;\n   },\n\n   _setGroupApprovalComment: function(gr, currentState, newState, user) {\n      var groupName = gr.assignment_group.name.toString();\n      // PRB1326306 dot-walking doesn't work in cross domain group approval\n      if (!groupName && gr.assignment_group) {\n         var agGr = new GlideRecord(gr.assignment_group.getReferenceTable());\n         agGr.addQuery('sys_id', gr.assignment_group.toString());\n         agGr.queryNoDomain();\n         if (agGr.next())\n            groupName = agGr.name.toString();\n      }\n      var userName = this.approvalUtils.getUserName(user);\n      var comment;\n      if (newState == 'requested')\n         comment = gs.getMessage(\"Manual group approval for {0} reset to requested due to user approval change from {1} to requested.\", [groupName, currentState]);\n      else if (newState == 'approved') {\n         if (user)\n            comment = gs.getMessage(\"Manual group approval for {0} approved by user {1}.\", [groupName, userName]);\n         else\n            comment = gs.getMessage(\"Manual group approval for {0} approved by all users.\", [groupName]);\n      } else if (newState == 'rejected') {\n         if (user)\n            comment = gs.getMessage(\"Manual group approval for {0} rejected by user {1}.\", [groupName, userName]);\n         else\n            comment = gs.getMessage(\"Manual group approval for {0} rejected by all users.\", [groupName]);\n      }\n\n      if (comment)\n         this.approvalUtils.addApprovalHistoryGR(current, comment);\n   },\n\n   type: 'Manual_ApprovalsActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_533e39330a6a803f54a9619525b0a7e7","js_class_name":"Manual_Approvals","name":"Manual Approvals","attributes":"approval=true","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Unlock activity removes a lock created by the Lock activity.\r\n\r\nUse this activity to allow other processes to change values on the current record.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Finished: the activity successfully unlocked the record.","sys_updated_on":"2014-10-22 23:26:05","sys_class_name":"wf_activity_definition","sys_id":"572a84650a0a0ba33674e80e07f71869","sys_updated_by":"harry.nelson","sys_created_on":"2010-01-22 17:56:15","action":"false","sys_name":"Unlock","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"harry.nelson","table":"global","image":"images/heisenberg_icons/workflow/lock_unlocked.png","default_width":"150","base_provider":"","sys_mod_count":"12","sys_tags":"","script":"//Workflowactivitydefinitionhandler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\n\nvar UnlockActivityHandler = Class.create();\nUnlockActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n\n      var key = this.js(activity.vars.key).toString();     \n      var lock = new GlideLock(key);\n      lock.release();\n\n   },\n\n   type: 'LockActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_572a84650a0a0ba33674e80e07f71869","js_class_name":"Unlock","name":"Unlock","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"Invoke a subordinate workflow (sub-flow)\r\n\r\nThe 'workflow' variable contains a reference to the subflow to invoke.","sys_updated_on":"2014-10-22 18:00:18","sys_class_name":"wf_activity_definition","sys_id":"5994b389c0a80011000e64de81b1864c","sys_updated_by":"harry.nelson","sys_created_on":"2007-06-23 17:15:55","action":"false","sys_name":"Subflow","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/workflow.png","default_width":"","base_provider":"","sys_mod_count":"34","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar SubflowActivityHandler = Class.create();\nSubflowActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      // Start the subflow\n      var id = this._getSubflowID();\n      var subflow = workflow.startSubflow(id, current);\n      if (!subflow) {\n         activity.state = 'faulted';\n         activity.fault_description = gs.getMessage('Subflow not found');\n         activity.result = 'finished';\n      } else {\n         // register a listener to wait on the subflow\n         workflow.registerListener(subflow, 'state');\n         activity.scratchpad.subflowId = subflow.sys_id.toString();\n         activity.state = 'waiting';\n         \n         if (activity.vars.script) {\n            // put the subflow into the global context so it can be referenced\n            // by the preprocessing script used to set subflow scratchpad variables\n            workflow.setVariable('subflow', subflow);\n            workflow.eval(activity.vars.script);\n            subflow.update();\n         }\n      }\n   },\n   \n   onCancel: function() {\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n\n      // cancel the subflow\n      if (!activity.scratchpad.subflowId)\n         return;\n\n      var gr = new GlideRecord('wf_context');\n      if (gr.get(activity.scratchpad.subflowId))\n         new Workflow().cancelContext(gr);\n   },\n\n   onListener: function() {\n      // workflow state changed - are we done?\n      if (workflow.isComplete(listenedTo)) {\n         activity.state = 'finished';\n         activity.result = listenedTo.result;\n         if (!activity.result)\n            activity.result = 'success';\n            \n         // run the post processing script\n         if (activity.vars.script_post) {\n            workflow.setVariable('subflow', listenedTo);\n            workflow.eval(activity.vars.script_post);\n         }\n      }\n   },\n   \n   _getSubflowID: function() {\n      return activity.vars.workflow.toString();\n   },\n   \n   type: 'SubflowActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_5994b389c0a80011000e64de81b1864c","js_class_name":"Subflow","name":"Subflow","attributes":"","style":"","category":"Deprecated","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Lock activity locks the current record for exclusive access by the workflow being executed.\n\nUse this activity to prevent other processes from changing values on the current record.\n\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\n*Waiting: the workflow engine is waiting for a lock on the record.\n*Finished: the activity locked the record.\n*Timeout: the activity could not lock the record within the specified duration. The activity waits for the duration defined in the 'Delay between attempts' field and repeats the attempt to lock the record. The activity attempts to lock the record the number of times defined in the 'Max. attempts' field before reaching this state.\n\nThe result values assigned by this activity are: \n*Success: the activity locked the record. The workflow has exclusive access to this record.\n*Failed: the activity could not lock the record.\n\nKeep in mind: \n*The lock only prevents other processes from modifying the record. Another branch in the same workflow can access the record.\n*The record is unlocked after reaching the 'Max. duration'. This is equivalent to running the Unlock activity. No lock should persist indefinitely.","sys_updated_on":"2017-01-13 01:12:12","sys_class_name":"wf_activity_definition","sys_id":"664a3ca90a0a0b052dfc5ca3669e310c","sys_updated_by":"harry.nelson","sys_created_on":"2010-01-25 16:22:06","action":"false","sys_name":"Lock","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"harry.nelson","table":"global","image":"images/heisenberg_icons/workflow/lock_locked.png","default_width":"150","base_provider":"","sys_mod_count":"57","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\n\nvar LockActivityHandler = Class.create();\nLockActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n\n      activity.scratchpad.key          = this.js(activity.vars.key).toString();\n      var expiration   = activity.vars.expiration.getGlideObject().getNumericValue() / 1000; // ms -> s\n      this.lock        = new GlideLock(activity.scratchpad.key, expiration, 1);\n      activity.scratchpad.numTries = activity.scratchpad.numTries!==undefined?activity.scratchpad.numTries:activity.vars.try_count;\n   },\n   \n   onExecute:function() {\n   \tthis.onLock();\n   },\n   \n   onLock:function() {\n      if (this._getLock()) {\n         activity.state = 'finished';\n         activity.result = 'success';\n         return;\n      } else if (activity.scratchpad.numTries > 0) {\n         activity.state = 'waiting';\n      \t this._wait();\t\t\t \n      } else {\n         activity.state = 'timeout';\n         activity.result = 'failed';\n         return;\n         \n      }     \n   },\n   \n   _wait: function() {\n      var sched = new ScheduleOnce();\n      sched.script = \"var w = new Workflow(); w.fireEventById('\" + activity.sys_id + \"', 'lock');\";\n      sched.setAsSeconds(activity.vars.wait_duration.getGlideObject().getNumericValue() / 1000); // ms -> s\n      sched.setDocument(activity);\n      sched.setLabel(\"Lock\" + activity.sys_id);\n      sched.schedule();\n   },\n   \n   _getLock: function() {\n      activity.scratchpad.numTries--;\n      return this.lock.get();\n      \n   },\n   \n   type: 'LockActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_664a3ca90a0a0b052dfc5ca3669e310c","js_class_name":"Lock","name":"Lock","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Send notification(sms,voice,slack,teams) to a user/s\r\n","sys_updated_on":"2024-10-13 12:32:27","sys_class_name":"wf_activity_definition","sys_id":"707874e5c74f00107f840d8c95c260b8","sys_updated_by":"admin","sys_created_on":"2020-02-18 10:04:55","action":"false","sys_name":"On-Call: Send Notification","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"52","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Send_NotificationActivityHandler = Class.create();\nOn_Call__Send_NotificationActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    /**\n     * Activity is executing\n     */\n    onExecute: function() {\n        var notificationType = this.runScript(activity.vars.notification_type + '');\n        switch (notificationType) {\n            case OnCallCommonSNC.COMMUNICATION_TYPES.SMS:\n                this.notifyUtils = new NotifyUtil();\n                this.notify = new SNC.Notify();\n                this.executeSmsActivity();\n                break;\n            case OnCallCommonSNC.COMMUNICATION_TYPES.VOICE:\n                this.notifyUtils = new NotifyUtil();\n                this.executeVoiceActivity();\n                break;\n            case OnCallCommonSNC.COMMUNICATION_TYPES.SLACK:\n                this.executeSlackActivity();\n                break;\n            case OnCallCommonSNC.COMMUNICATION_TYPES.MOBILE_NOTIFICATION:\n                this.executeMobilePushActivity();\n                break;\n            case OnCallCommonSNC.COMMUNICATION_TYPES.TEAMS:\n                this.executeTeamsActivity();\n                break;\n            default:\n\n        }\n    },\n\n    executeTeamsActivity: function() {\n        var notificationDetails = this.runScript(activity.vars.notification_detail + '');\n        if (JSUtil.nil(notificationDetails) || JSUtil.nil(notificationDetails.userId) || JSUtil.nil(notificationDetails.recordSysId) || JSUtil.nil(notificationDetails.recordTableName))\n            activity.state = 'faulted';\n        else {\n            var msTeamsUtils = new OnCallTeamsUtils();\n            var response = msTeamsUtils.sendMSTeamsNotification(notificationDetails.recordTableName, notificationDetails.recordSysId, notificationDetails.userId, notificationDetails.wfContextId, notificationDetails.triggerUserField);\n            if (!gs.nil(response) && Object.keys(response).length > 0)\n                activity.state = 'finished';\n            else {\n                workflow.scratchpad.sendTeamsNotificationError = true;\n                activity.state = 'faulted';\n            }\n        }\n    },\n\n    executeMobilePushActivity: function() {\n        workflow.scratchpad.sendMobileNotificationError = false;\n        activity.state = 'finished';\n        var result = this.runScript(activity.vars.notification_detail + '');\n        if (JSUtil.nil(result) || JSUtil.nil(result.userSysId) || JSUtil.nil(result.tablename) || JSUtil.nil(result.recordSysId)) {\n            activity.state = 'faulted';\n            workflow.scratchpad.sendMobileNotificationError = true;\n        } else if (typeof OnCallPushRequest !== 'undefined') {\n            new OnCallPushRequest()\n                .setUserSysId(result.userSysId)\n                .setSourceTable(result.tablename)\n                .setDocumentID(result.recordSysId)\n                .createOrUpdatePush();\n        }\n    },\n\n    /**\n     * Slack activity starting\n     */\n\n    executeSlackActivity: function() {\n        workflow.scratchpad.sendSlackError = false;\n        activity.state = 'finished';\n        var script = activity.vars.notification_detail + '';\n        var result = this.runScript(script);\n        var util = new OnCallSlackUtils();\n        var output = util.sendActionableMessageToUser(result.taskId, result.user, result.cathAllOption, result.wFContextId);\n        if (output !== 'Success') {\n            activity.state = 'faulted';\n            workflow.scratchpad.sendSlackError = true;\n        }\n    },\n\n    /**\n     * Slack activity ending\n     */\n\n    /**\n     * Voice activity starting\n     */\n\n    executeVoiceActivity: function() {\n        var script = activity.vars.notification_detail + '';\n        var result = this.runScript(script);\n        var notify = new SNC.Notify();\n        var numberToCallFrom = result.numberToCallFrom;\n        var numberToCall = result.numberToCall;\n        var user = result.user;\n        workflow.scratchpad.callErrors = [];\n        if (gs.nil(numberToCallFrom)) {\n            var error = gs.getMessage('Unable to call as the Notify Number to call from is not defined');\n            workflow.scratchpad.callErrors = [error];\n            return this.throwError(error);\n        }\n        var useNotifyCall = new OnCallCommon().isUsingNotifyCallForVoice(workflow.scratchpad.useNotifyCallForVoice);\n\n        if (useNotifyCall)\n            notify.call(numberToCallFrom, numberToCall, null, user, null, current);\n        else {\n            var conferenceCall = notify.conferenceCall(current);\n            notify.call(numberToCallFrom, numberToCall, conferenceCall, user, null, current);\n        }\n        var errors = this.notifyUtils.getErrors();\n        // get API errors (if any)\n        if (notify.hasErrors()) {\n            var iter = notify.getErrors().iterator();\n            while (iter.hasNext())\n                errors.push(j2js(iter.next()));\n        }\n        workflow.scratchpad.callErrors = errors;\n        if (errors.length > 0)\n            return this.throwError(errors.join(', '));\n\n        activity.state = 'finished';\n    },\n\n    /**\n     * Voice activity ending\n     */\n\n\n    /**\n     * Sms activity starting\n     */\n\n    executeSmsActivity: function() {\n        var users = [];\n        var groups = [];\n        var numbers = [];\n        var notifyNumber;\n        workflow.scratchpad.sendSMSErrors = [];\n\n        // reset errors\n        this.notifyUtils.resetErrors();\n\n        // process the advanced script\n        var script = activity.vars.notification_detail + '';\n        // evaluate the script and get the result\n        try {\n            var result = this.runScript(script);\n\n            // check if the result object is okay\n            if (!result.hasOwnProperty('notify_number') || !result.hasOwnProperty('users') || !result.hasOwnProperty('groups') || !result.hasOwnProperty('numbers')) {\n                if (!result.hasOwnProperty('notify_number'))\n                    workflow.scratchpad.sendSMSErrors = [gs.getMessage('Unable to send SMS as the Notify Phone Number to send the SMS is not defined')];\n\n                return this.throwError(gs.getMessage('the result of the advanced script did not return a valid object (expected: {notify_number: \\'...sys_id...\\', users: [...], groups: [...], numbers: [...]})'));\n            }\n\n            // assign notify number and append users, groups and numbers\n            notifyNumber = result.notify_number;\n            users = this.notifyUtils.appendUniquely(users, result.users);\n            groups = this.notifyUtils.appendUniquely(groups, result.groups);\n            numbers = this.notifyUtils.appendUniquely(numbers, result.numbers + '', true);\n        } catch (e) {\n            this.error(e);\n            activity.state = 'faulted';\n            return;\n        }\n\n        // get all unique phone numbers\n        numbers = this.notifyUtils.getUniquePhoneNumbersForUsersAndGroups(numbers, users, groups, this.notifyUtils.numberType.sms);\n\n        // get the notify number record\n        var notifyNumberRecord = this.getNotifyNumberRecord(notifyNumber);\n\n        // check if the notify number is valid\n        if (!this.notifyUtils.isDefined(notifyNumberRecord)) {\n            workflow.scratchpad.sendSMSErrors.push(gs.getMessage('No such Notify Phone Number'));\n            return this.throwError('No such Notify Phone Number');\n        }\n\n        // check if the number supports outbound SMS messages\n        if (!this.supportsOutgoingSMS(notifyNumberRecord.getValue('number'))) {\n            workflow.scratchpad.sendSMSErrors.push(gs.getMessage('Notify Number does not support outbound SMS messages'));\n            return this.throwError('The Notify Number does not support outbound SMS messages');\n        }\n\n        // define sms body\n        var body = this.notifyUtils.expandVariables(activity.vars.message + '', [workflow.scratchpad, activity.scratchpad, current]);\n\n        // send out bulk sms\n        this.notify.sendBulkSMS(notifyNumberRecord.getValue('number'), numbers, body, current);\n\n        // get errors (if any)\n        var errors = this.notifyUtils.getErrors();\n        // get API errors (if any)\n        if (this.notify.hasErrors()) {\n            var iter = this.notify.getErrors().iterator();\n            while (iter.hasNext())\n                errors.push(j2js(iter.next()));\n        }\n\n        workflow.scratchpad.sendSMSErrors = errors;\n\n        if (errors.length > 0)\n            return this.throwError(errors.join(', '));\n\n        // mark activity as done\n        activity.state = 'finished';\n    },\n\n    /**\n     * Set activity to error\n     *\n     * @param message\n     */\n    throwError: function(message) {\n        this.error(message, \"\");\n        this.setResultFaulted(message);\n    },\n\n    /**\n     * Get a NotifyNumber GlideRecord by id\n     *\n     * @param id\n     * @returns {*}\n     */\n    getNotifyNumberRecord: function(id) {\n        if (this.notifyUtils.isDefined(id)) {\n            var number = new GlideRecord('notify_number');\n            if (number.get(id))\n                return number;\n        }\n\n        return null;\n    },\n\n    /**\n     * Check if a notify number supports outbound SMS messages\n     *\n     * @param phoneNumber\n     * @returns {boolean}\n     */\n    supportsOutgoingSMS: function(phoneNumber) {\n        var notifyNumber = new GlideRecord(\"notify_number\");\n        notifyNumber.addQuery(\"number\", phoneNumber);\n        notifyNumber.setLimit(1);\n        notifyNumber.query();\n        if (notifyNumber.next()) {\n            return notifyNumber.getValue(\"has_sms_out\") === \"yes\";\n        }\n        return false;\n    },\n\n    /**\n     * Sms activity ending\n     */\n\n    /**\n     * Activity is updating\n     */\n    onUpdate: function() {},\n\n    type: 'On_Call__Send_NotificationActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_707874e5c74f00107f840d8c95c260b8","js_class_name":"On_Call__Send_Notification","name":"On-Call: Send Notification","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Rollback activity transitions to an earlier activity and updates all approvals and tasks that have executed between the Rollback activity and the activity that the Rollback activity transitions to. This activity resets activities that branch from activities in the rollback path. As a result, a Rollback activity may reset more than expected because activities do not always execute in a predictable order.\r\n \r\nThis activity resets approvals to 'Requested', and tasks to 'Open'. A workflow should only have one Rollback activity.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nKeep in mind: \r\n*Rollback does not reset Manual Approval activities. When the workflow moves through the Manual Approval stage the second time, it automatically approves or rejects based on the approval state. Placing a Manual Approval activity directly before a RollBack activity causes a loop.","sys_updated_on":"2014-10-23 16:36:56","sys_class_name":"wf_activity_definition","sys_id":"7a8ea386c0a80066179bc1f5186e1d2b","sys_updated_by":"harry.nelson","sys_created_on":"2008-12-27 22:41:43","action":"false","sys_name":"Rollback","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task","image":"images/heisenberg_icons/workflow/roll_back_to.png","default_width":"","base_provider":"","sys_mod_count":"59","sys_tags":"","script":"var RollbackActivityHandler = Class.create();\nRollbackActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n    \n    onExecute: function() {\n        // Get the activities the rollback will transition to\n        var ids = workflow.toActivities();\n        this._getTransitionHistory();\n        \n        // Walk from the rollback points, cancelling any executing activities and resetting any approvals/tasks\n        this.activityIds = [];\n        this.visited = {};\n        this.visited[activity.activity.sys_id.toString()] = true;\n        if (previous_activity && previous_activity.activity.sys_id)\n           this.activityIds.push(previous_activity.activity.sys_id + '');\n\n        // set any rollback comment\n        if (activity.vars.comment_field && activity.vars.comment) \n            current.getElement(activity.vars.comment_field.toString()).setDisplayValue(activity.vars.comment.toString());\n        \n        for (var i = 0; i < ids.size(); i++) \n            this._processActivity(ids.get(i));\n        \n        // now get any child activities in our list\n        this._getChildren();\n        // this just cancels Timers for now, easy to add other jobs, \n        this._cancelJobs();\n        this._cancelExecuting();\n        this._restartHistory();\n        this._resetApprovalsAndTasks();\n\t\t\n\t\t// signal engine that roll-back finished.\n\t\tworkflow.onRollbackComplete(activity);\n    },\n    \n    _getTransitionHistory: function() {\n        this.transitions = {};\n        var gr = new GlideRecord('wf_transition_history');\n        gr.addQuery('context', activity.context);\n\t\tgr.addQuery('rolled_back', false);\n        gr.query();\n        while (gr.next()) {\n            var from = gr.transition.from.toString();\n            var to = gr.transition.to.toString();\n            if (!this.transitions[from]) \n                this.transitions[from] = [];\n            \n            this.transitions[from].push(to);\n\t\t\tgr.setValue('rolled_back', true);\n\t\t\tgr.update();\n        }\n    },\n    \n    _processActivity: function(id) {\n        if (this.visited[id]) \n            return;\n        \n        this.visited[id] = true;\n        this.activityIds.push(id);\n        // follow the transitions\n        if (!this.transitions[id]) \n            return;\n        \n        for (var i = 0; i < this.transitions[id].length; i++) \n            this._processActivity(this.transitions[id][i]);\n    },\n    \n    _getChildren: function() {\n        if (this.activityIds.length == 0) \n            return;\n        \n        // load up any child activities and associated them with their parent\n        var gr = new GlideRecord('wf_activity');\n        gr.addQuery('workflow_version', activity.workflow_version);\n        gr.addQuery('parent', \"IN\", this.activityIds);\n        gr.query();\n        while (gr.next()) \n            this.activityIds.push(gr.sys_id.toString())\n    },\n    \n    _cancelExecuting: function() {\n        if (this.activityIds.length == 0) \n            return;\n        \n        var gr = new GlideRecord('wf_executing');\n        gr.addQuery('context', activity.context);\n        gr.addQuery('sys_id', '!=', activity.sys_id); // don't delete the rollback activity we are executing\n        gr.addQuery('activity', \"IN\", this.activityIds);\n        gr.deleteMultiple();\n    },\n\n    _cancelJobs: function() {\n        if (this.activityIds.length == 0) \n            return;\n\n        var jobNames = [];\n        jobNames.push('Timer');\n        var gr = new GlideRecord('wf_executing');\n        gr.addQuery('context', activity.context);\n        gr.addQuery('sys_id', '!=', activity.sys_id); // don't delete the rollback activity we are executing\n        gr.addQuery('activity', \"IN\", this.activityIds);\n        gr.addQuery('activity.activity_definition.name', \"IN\", jobNames);\n        gr.query();\n      \n        while (gr.next()) {\n          // cancel this timer so the schedule (trigger) item is no longer valid\n          var s = new Schedule();\n          s.setDocument(gr);\n          s.setLabel(\"Workflow\" + activity.context_id);\n          s.cancel();\n        }\n    },\n    \n    _restartHistory: function() {\n        if (this.activityIds.length == 0) \n            return;\n        \n        var mu = new GlideMultipleUpdate('wf_history');\n        mu.addQuery('context', activity.context);\n        mu.addQuery('activity', \"IN\", this.activityIds);\n        mu.setValue('state', 'restart');\n        mu.execute();\n    },\n    \n    _resetApprovalsAndTasks: function() {\n        if (this.activityIds.length == 0) \n            return;\n        \n        var gr = new GlideRecord('sysapproval_group');\n        gr.addQuery('parent', current.sys_id);\n        gr.addQuery('wf_activity', \"IN\", this.activityIds);\n        gr.addQuery('approval', '!=', 'not requested');\n        gr.query();\n        while (gr.next()) {\n            gr.setValue('approval', 'not requested');\n            gr.update();\n        }\n        \n        var mu = new GlideMultipleUpdate('sysapproval_approver');\n        mu.addQuery('sysapproval', current.sys_id);\n        mu.addQuery('wf_activity', \"IN\", this.activityIds);\n        mu.addQuery('state', '!=', 'not requested');\n        mu.setValue('state', 'not requested');\n        mu.execute();\n        \n        mu = new GlideMultipleUpdate('task');\n        mu.addQuery('parent', current.sys_id);\n        mu.addQuery('wf_activity', \"IN\", this.activityIds);\n        mu.addQuery('state', '!=', '-5');\n        mu.setValue('state', '-5');\n        mu.setValue('work_end', '');\n        mu.setValue('active', 'true');\n        mu.execute();\n    },\n    \n    _getName: function(id) {\n        var gr = new GlideRecord('wf_activity');\n        if (gr.get(id)) \n            return gr.name.toString();\n        \n        return id;\n    },\n    \n    type: 'RollbackActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_7a8ea386c0a80066179bc1f5186e1d2b","js_class_name":"Rollback","name":"Rollback","attributes":"","style":"","category":"deprecated","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Join activity unites multiple concurrent execution paths into a single transition.\r\n\r\nUse this activity to cause a workflow to wait for all activities in multiple paths to finish before continuing.\r\n\r\nPossible result values for this activity are:\r\n*Complete: all predecessor activities finished executing and transitioned to the Join activity. \r\n*Incomplete: all predecessor activities finished executing, but one or more bypassed the Join activity.","sys_updated_on":"2014-10-22 17:26:52","sys_class_name":"wf_activity_definition","sys_id":"7c9a2ba9c0a801650021ada408de0ebd","sys_updated_by":"harry.nelson","sys_created_on":"2007-11-26 15:37:19","action":"false","sys_name":"Join","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/join.png","default_width":"","base_provider":"","sys_mod_count":"49","sys_tags":"","script":"// Wait for all predecessor activities to complete before we continue\n\nvar JoinActivityHandler = Class.create();\nJoinActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      this._getTransitionsToMe();\n      this._determineJoinActivity();\n   },\n   \n   onCancel: function(eventName) {\n      // We need an onCancel here so that our onOtherEvent does not run and reset our cancelled state\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n   },\n   \n   onActivityComplete: function() {\n      this._checkComplete();\n   },\n   \n   onOtherEvent: function() {\n      this._determineJoinActivity();\n   },\n   \n   // See if there is already a Join activity running that we should let handle things\n   // If not, then set ourselves up to handle the Join\n   _determineJoinActivity: function() {\n\n      var gr = new GlideRecord('wf_executing');\n      gr.addQuery('activity', activity.activity);\n      gr.addQuery('context', activity.context);\n      gr.addQuery('sys_id', '!=', activity.sys_id);\n      gr.query();\n      if (gr.next()) {\n         // there is one - use it (deleting this activity will generate an activityComplete event to the real Join activity)\n         activity.state = 'delete';\n      } else {\n         // we are the one - check to see if we are complete before returning\n         if (!this._checkComplete()) {\n            // set to waiting state and indicate that we want to be notified of activity completions\n            activity.state = 'waiting';\n            activity.notify_termination = true;\n         }\n      }\n   },\n   \n   // See if any predecessor activites are active - if any are active, we have to wait on it\n   _checkComplete: function() {\n      var ids = workflow.getPredecessors();\n      ids.add(activity.activity.sys_id);   // check for a transition to us, but with a 'new' join that will be deleted in _checkComplete when it runs\n \n      var gr = new GlideRecord('wf_executing');\n      gr.addQuery('context', activity.context);\n      gr.addQuery('activity', ids);\n      gr.addQuery('sys_id', '!=', activity.sys_id);  // skip me!\n      gr.query();\n      if (gr.hasNext()) {\n         return false;\n      }\n\n      activity.state = 'finished';\n      this._setResult();\n      return true;\n   },\n   \n   _getTransitionsToMe: function() {\n      var transIds = [];\n      var transGR = new GlideRecord('wf_transition');\n      transGR.addQuery('to', activity.activity.sys_id);\n      transGR.query();\n      while (transGR.next())\n         transIds.push(transGR.sys_id.toString());\n\n      activity.scratchpad.transIds = transIds;\n   },\n   \n   // Determine if all predecessor activities transitioned to us (complete) or not (incomplete)\n   _setResult: function() {\n      var transIds = activity.scratchpad.transIds;\n      var transToMe = transIds.length;\n      \n      // now see who transitioned to us\n      var transTaken = 0;\n      var transTakenIds = {};\n      transGR = new GlideRecord('wf_transition_history');\n      transGR.addQuery('context', activity.context);\n      transGR.addQuery('transition', transIds);\n      transGR.addQuery('rolled_back', 'false');\n      transGR.query();\n      while (transGR.next()) {\n         var id = transGR.sys_id.toString();\n         if (!transTakenIds[id]) {\n            transTakenIds[id] = true;\n            transTaken++;\n         }\n      }\n\n      if (transTaken >= transToMe)\n         activity.result = \"complete\";\n      else\n         activity.result = \"incomplete\";\n   },\n   \n   type: 'JoinActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_7c9a2ba9c0a801650021ada408de0ebd","js_class_name":"Join","name":"Join","attributes":"generate=join","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Approval - Group activity creates a group approval record or set of group approval records. The activity generates approval records for each member of the group. As opposed to user approvals, ServiceNow tracks group approvals at the group level. Group approvals let you see which groups approve or reject the request along with the users responsible for the group level approval.\r\n\r\nUse this activity to request approvals from users within a group.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity or the workflow that contains this activity was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value is the final approval disposition. This disposition depends on the actions take by the approvers and the conditions specified in the 'Wait for' and 'When Anyone Rejects' fields. Possible result values are: \r\n*Approved\r\n*Rejected\r\n*Skipped\r\n*Deleted\r\n*Cancelled\r\n \r\nKeep in mind: \r\n*This activity contains script fields. Do not use the 'current.update()' method in these script fields because it may cause recursive updates to the current record.\r\n*If the approval group assigned in the 'Groups' field can not be resolved, the default result of the approval is Skipped and will result in the Approved transition.","sys_updated_on":"2014-06-13 17:47:27","sys_class_name":"wf_activity_definition","sys_id":"80c4d7115f112100a9ad2572f2b477b3","sys_updated_by":"admin","sys_created_on":"2014-06-13 17:07:20","action":"false","sys_name":"Service Approval - Group","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"task","image":"images/workflow/approval_group.gif","default_width":"","base_provider":"","sys_mod_count":"3","sys_tags":"","script":"/**\n * Group approvals are tracked by the group but requested from all group members\n */\n\nvar Service_Approval___GroupActivityHandler = Class.create();\nService_Approval___GroupActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n      this.approvalUtils = new WorkflowApprovalUtils();\n      this.setDatesFlag = false;\n   },\n   \n   onExecute: function() {\n      /**\n       * Create the approvals and (optionally) wait for them to either be approved or rejected.\n       */\n      \n      var approvals = this._createApprovals();\n      \n      // any approvals?\n      if (approvals.length == 0)\n         activity.result = 'skipped';\n      else\n         activity.state = 'waiting';\n      \n      // save the list of approval ids\n      activity.scratchpad.approval_ids = approvals;\n      \n         this._onUpdate();\n   },\n\n   // override this to provide the proper stage state\n   getFinalStageState: function() {\n\t   return new WFApprovalStages().getApprovalState(current, current.stage, activity);\n   },\n\n   onDetermineApprovalState: function() {\n      this.forceState = true;\n      this._onUpdate();\n   },\n   \n   // The task has changed, see if we need to update our approval state\n   onUpdate: function() {\n      this._onUpdate();\n   },\n   \n   _onUpdate: function() {\n      var state = this._determineOverallState();\n      if (state && (state != 'requested')) {\n         this.approvalUtils.setPendingGroupApprovalsByIds(activity.scratchpad.approval_ids, 'not_required');\n         activity.state = 'finished';\n         activity.result = state;\n      } else if ((state == 'requested') && (activity.result != state)) {\n         // changed back to requested state (unapprove can do this)\n         activity.state = 'waiting';\n         activity.result = '';\n      }\n   },\n   \n   // The approval was cancelled\n   onCancel: function() {\n      this.approvalUtils.setPendingGroupApprovalsByIds(activity.scratchpad.approval_ids, 'cancelled');\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n   },\n   \n   // Create the approval(s) based on the variables that are specified\n   _createApprovals: function() {\n      var groupIds = this._getGroupIds();\n      var approvalIds = this._buildApprovals(groupIds);\n      return approvalIds;\n   },\n   \n   _getGroupIds: function() {\n      var groups = {};\n      \n         var ids = this.runScript(activity.vars.approver_script);\n         if (ids) {\n            if (typeof(ids) == 'string')\n               ids = ids.split(',');\n            \n            this.approvalUtils.addIdsToApprovalList(groups, ids);\n         }\n      \n      return groups;\n   },\n   \n   _buildApprovals: function(groupIds) {\n      var approvalIds = [];\n      for (var id in groupIds) {\n         var approvalId = this._createApproval(id);\n         if (approvalId)\n            approvalIds.push(approvalId);\n      }\n      return approvalIds;\n   },\n   \n   /**\n    * Create a new group approval\n    */\n   _createApproval: function(groupId) {\n      var approvalId = this._createNewApproval(groupId);\n      return approvalId;\n   },\n   \n   _createNewApproval: function(groupId) {\n      // make sure there are users of the group before creating it\n      var ids = this.approvalUtils.getMembersOfGroup(groupId);\n      if (ids.length == 0)\n         return \"\";\n      \n      var approval = new GlideRecord('sysapproval_group');\n      approval.assignment_group = groupId;\n      approval.parent = current.sys_id;\n\t  approval.parent.setRefRecord(current);\n      approval.wf_activity = activity.activity.sys_id;\n      approval.approval = 'requested';\n      return approval.insert();\n   },\n   \n   // Determine the overall state of the approvals (approved, rejected or '')\n   _determineOverallState: function() {\n      var ids = activity.scratchpad.approval_ids;\n      if (!ids)\n         return 'skipped';\n      \n\t  // check for approval state change within each group\n      var rejectHandling = activity.vars.reject_handling;\n      var changed = false;\n      var groupApprovals = new GlideRecord('sysapproval_group');\n      groupApprovals.addQuery('sys_id', ids);\n      groupApprovals.query();\n      while (groupApprovals.next()) {\n         if (this._determineGroupState(groupApprovals))\n            changed = true;\n      }\n      \n      if (!changed && !this.forceState)\n         return '';\n      \n      // And then the overall state\n      var ret = this.approvalUtils.getGroupIdListApprovalCounts(ids);\n      ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['duplicate'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0)\n         return 'skipped';\n      \n      if (ret.counts['rejected'] > 0)\n         return 'rejected';\n      \n      if (ret.counts['approved'] > 0)\n         return 'approved';\n      \n      if ((ret.counts['rejected'] + ret.counts['approved']) == ret.counts['total']) {\n         // we are complete - we have to make a decision\n         return 'rejected';\n      }\n      \n      return 'requested';\n   },\n   \n   // Determine approval state for a group approval\n   _determineGroupState: function(gr) {\n      if (gr.admin_override == true)\n         return true;\t\t// force a determination of overall state since this might be the first change for admin override\n      \n      var currentState = gr.approval + '';\n      if ((currentState == 'not_required')\n         || (currentState == 'not requested')\n      || (currentState == 'cancelled'))\n      return false;\n      \n      var newState = \"requested\";\n      var user;\n      var mootPeers = false;\n      var ret = this.approvalUtils.getUserGroupApprovalCounts(gr.sys_id + '');\n      ret.counts['total'] -= ret.counts['not_required'];\n      ret.counts['total'] -= ret.counts['cancelled'];\n      if (ret.counts['total'] == 0) {\n         newState = 'approved';\n         mootPeers = true;\n         \n      } else if (ret.counts['rejected'] > 0) {\n         // first response with a rejection\n         newState = 'rejected';\n         user = ret.approvalIDs['rejected'][0];\n         mootPeers = true;\n         \n      } else if (ret.counts['approved'] > 0) {\n         // first response with an approval\n         newState = 'approved';\n         user = ret.approvalIDs['approved'][0];\n         mootPeers = true;\n         \n      }\n      \n      if (newState && (currentState != newState)) {\n         gr.approval = newState;\n         if (user)\n            gr.approval_user = user;\n         else if (newState == 'requested')\n            gr.approval_user = \"\";\n         \n         this._setGroupApprovalComment(gr, currentState, newState, user);\n         \n         gr.update();\n         return true;\n      }\n      return false;\n   },\n   \n   _setGroupApprovalComment: function(gr, currentState, newState, user) {\n      var groupName = gr.assignment_group.name.toString();\n      var userName = this.approvalUtils.getUserName(user);\n      var comment;\n      if (newState == 'requested')\n         comment = gs.getMessage(\"Group approval for {0} reset to requested due to user approval change from {1} to requested ({2}).\", [groupName, currentState, activity.activity.name.toString()]);\n      \n      else if (newState == 'approved') {\n         if (user)\n            comment = gs.getMessage(\"Group approval for {0} approved by user {1} ({2}).\", [groupName, userName, activity.activity.name.toString()]);\n         else\n            comment = gs.getMessage(\"Group approval for {0} approved by all users ({1}).\", [groupName, activity.activity.name.toString()]);\n      }\n      \n      else if (newState == 'rejected') {\n         if (user)\n            comment = gs.getMessage(\"Group approval for {0} rejected by user {1} ({2}).\", [groupName, userName, activity.activity.name.toString()]);\n         else\n            comment = gs.getMessage(\"Group approval for {0} rejected by all users ({1}).\", [groupName, activity.activity.name.toString()]);\n      }\n      \n      if (comment)\n         this.approvalUtils.addApprovalHistoryGR(current, comment);\n   },\n   \n   type: 'Service_Approval___GroupActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/696867b304f12210559073c06a02f721","value":"696867b304f12210559073c06a02f721"},"sys_update_name":"wf_activity_definition_80c4d7115f112100a9ad2572f2b477b3","js_class_name":"Service_Approval___Group","name":"Service Approval - Group","attributes":"generate=approval","style":"","category":"","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Wait for event causes the workflow to wait at this activity until the specified event is fired.\r\n \r\nUse this activity to register for an event that is fired by another activity of the workflow and then wait for that event to be fired.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. This activity transitions when the specified event fires.","sys_updated_on":"2014-10-22 17:47:56","sys_class_name":"wf_activity_definition","sys_id":"88fbebdcac146426045370ed7901e2e2","sys_updated_by":"harry.nelson","sys_created_on":"2008-06-14 21:32:23","action":"false","sys_name":"Wait for WF Event","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/wait_for_event.png","default_width":"","base_provider":"","sys_mod_count":"18","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Wait_for_WF_EventActivityHandler = Class.create();\nWait_for_WF_EventActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      workflow.registerForEvent(this.js(activity.vars.wait_for_event));\n      activity.state = 'waiting';\n   },\n   \n   onUnhandledEvent: function(eventName) {\n\t  var waitingForEventName = this.js(activity.vars.wait_for_event);\n      if (eventName == waitingForEventName) {\n         activity.state = \"finished\";\n         activity.result = waitingForEventName;\n      }\n   },\n\n   type: 'Wait_for_WF_EventActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_88fbebdcac146426045370ed7901e2e2","js_class_name":"Wait_for_WF_Event","name":"Wait for WF Event","attributes":"","style":"","category":"Conditions","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Update escalation level end time","sys_updated_on":"2023-03-09 05:48:14","sys_class_name":"wf_activity_definition","sys_id":"8a45d9f7eb912110249e8d835d52287b","sys_updated_by":"admin","sys_created_on":"2023-03-07 13:14:25","action":"false","sys_name":"On-Call: Update Escalation Level","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"8","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Update_Escalation_LevelActivityHandler = Class.create();\nOn_Call__Update_Escalation_LevelActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    onExecute: function() {\n        // implement activity definition code here\n        var escalationId = '';\n        var rotaId = '';\n        var level = '';\n        var catchAll;\n\n        try {\n            escalationId = this.runScript(activity.vars.escalation_id + '');\n            rotaId = this.runScript(activity.vars.shift_id + '');\n            level = this.runScript(activity.vars.level + '');\n            catchAll = activity.vars.catch_all;\n        } catch (e) {\n            this.throwError(e.message);\n            activity.state = 'faulted';\n            return;\n        }\n\n\t\tvar ocEscalationGr = new GlideRecord(\"on_call_escalation_level\");\n\t\tocEscalationGr.addQuery(\"escalation\", escalationId);\n\t\tocEscalationGr.addQuery(\"rota\", rotaId);\n\t\tocEscalationGr.addQuery(\"level\", level);\n\t\tif (catchAll + \"\" == \"true\")\n\t\t\tocEscalationGr.addQuery(\"catch_all\", true);\n\t\tocEscalationGr.query();\n\n\t\tif(ocEscalationGr.next()) {\n\t\t\tocEscalationGr.level_end_time = new GlideDateTime().getDisplayValue();\n\t\t\tocEscalationGr.update();\n\t\t}\n    },\n\n    type: 'On_Call__Update_Escalation_LevelActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_8a45d9f7eb912110249e8d835d52287b","js_class_name":"On_Call__Update_Escalation_Level","name":"On-Call: Update Escalation Level","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"A timer that is based on a percentage of an SLA duration.\r\n\r\nWhen a Task SLA is being repaired the activitie's 'repair' condition will be true. This condition should be used to bypass activities that should not be exeuted when a Task SLA is being repaired. The \"Default SLA Repair Workflow\" bypasses all notification activities to prevent emails from being sent.\r\n\r\nUnder all other circumstances, the 'normal' condition is true.","sys_updated_on":"2020-08-18 13:40:10","sys_class_name":"wf_activity_definition","sys_id":"8e291a23ac1464262f4366bb3182d840","sys_updated_by":"admin","sys_created_on":"2008-06-15 21:37:15","action":"false","sys_name":"SLA Percentage Timer","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task_sla","image":"images/workflow/timer.gif","default_width":"","base_provider":"","sys_mod_count":"124","sys_tags":"","script":"/**\n * SLA Percent Timer Activity used to wait for some percentage amount of SLA time. Takes into account\n * 'workflow.scratchpad.retroactiveSecsLeft' for a \"retroactive\", or delayed, start.\n */\n\nworkflow.includeActivityDefinition(\"Timer\");\nvar SLA_Percentage_TimerActivityHandler = Class.create();\nSLA_Percentage_TimerActivityHandler.prototype = Object.extendsObject(TimerActivityHandler, {\n\tRESULT_NORMAL: 'normal',\n\tRESULT_REPAIR: 'repair',\n\tSTATE_FINISHED: 'finished',\n\n\tinitialize: function() {\n\t\tTimerActivityHandler.prototype.initialize.call(this);\n\n\t\t// remove any milliseconds from now time as granularity of all computation is seconds\n\t\tthis._now = new GlideDateTime(this._now.getValue());\n\n\t\t// if the scratchpad already contains a JSON string with the SLA Definition field values use it\n\t\tif (!workflow.scratchpad.sla && workflow.scratchpad.slaDataJSON)\n\t\t\tworkflow.scratchpad.sla = JSON.parse(workflow.scratchpad.slaDataJSON);\n\n\t\tif (!workflow.scratchpad.hasOwnProperty(\"timezoneForSchedule\"))\n\t\t\tworkflow.scratchpad.timezoneForSchedule = new SLAUtil().getTimezone(current);\n\n\t\tif (!workflow.scratchpad.repairedTaskSLA && workflow.scratchpad.repairedTaskSLADataJSON)\n\t\t\tworkflow.scratchpad.repairedTaskSLA = JSON.parse(workflow.scratchpad.repairedTaskSLADataJSON);\n\n\t\tthis.slaDefGr = this._getSLADefinition();\n\t\tif (!workflow.scratchpad.sla)\n\t\t\tthis._populateScratchpad();\n\n\t\tif (workflow.scratchpad.sla.duration_type) {\n\t\t\tactivity.vars.timer_type = 'relative_duration';\n\t\t\tactivity.vars.relative_duration = workflow.scratchpad.sla.duration_type;\n\t\t} else {\n\t\t\tactivity.vars.timer_type = 'duration';\n\t\t\tactivity.vars.field = String(workflow.scratchpad.sla.duration / 1000);\n\t\t}\n\n\t\tactivity.vars.modifier = 'percentage';\n\t\tactivity.vars.timezone_type = 'user_specified_timezone';\n\t\tactivity.vars.schedule_field = 'schedule';\n\t\tactivity.vars.user_specified_timezone = workflow.scratchpad.timezoneForSchedule;\n\t\tactivity.vars.schedule_type = 'from_field_schedule';\n\n\t\tif (!workflow.scratchpad.repairMode)\n\t\t\tworkflow.scratchpad.repairMode = workflow.inputs.sla_repair_mode + '';\n\n\t\t// Need to check for the string 'undefined' too as that's what will get assigned with \"workflow.inputs.sla_repair_mode + '';\"\n\t\t// when workflow.inputs.sla_repair_mode does not exist\n\t\tif ((typeof workflow.scratchpad.repairMode === \"undefined\") || workflow.scratchpad.repairMode === \"undefined\")\n\t\t\tworkflow.scratchpad.repairMode = workflow.inputs.u_sla_repair_mode + '';\n\n\t\t// If workflow is missing sla_repair_mode and u_sla_repair_mode inputs get the default value from the scratchpad\n\t\tif ((typeof workflow.scratchpad.repairMode === \"undefined\") || workflow.scratchpad.repairMode === \"undefined\")\n\t\t\tworkflow.scratchpad.repairMode = workflow.scratchpad.sla_repair_mode_default + '';\n\t},\n\n\t// @Override\n\tonExecute: function () {\n        /* if we're not repairing or we are repairing but the scratchpad doesn't contain the data we need\n           then call the standard onExecute function for a Timer */\n\t\tif (\"\" + workflow.scratchpad.repairMode !== \"true\" || !workflow.scratchpad.hasOwnProperty(\"repairedTaskSLA\") ||\n\t\t\t!workflow.scratchpad.repairedTaskSLA.startTime || !workflow.scratchpad.repairedTaskSLA.businessElapsed) {\n\t\t\tTimerActivityHandler.prototype.onExecute.call(this);\n\t\t\treturn;\n\t\t}\n\n\t\tactivity.state = \"waiting\";\n\t\tvar startTime = new GlideDateTime(workflow.scratchpad.repairedTaskSLA.startTime);\n\t\tvar totalSecs = this._calcTotalDuration(startTime); // total duration time, not including any schedule\n\t\tvar secs = this._seconds; // total duration time, within any schedule\n\t\tvar elapsedSecsLeft = parseInt(workflow.scratchpad.repairedTaskSLA.businessElapsed);\n\n\t\tthis.debug(\"SLAPercentageTimer->onExecute: executing in repair mode  startTime={0}, duration of this activity={1}s, \" +\n\t\t\t\t\t\" remaining elapsed time to consume in repaired SLA={2}s\", [startTime.getValue(), secs, elapsedSecsLeft]);\n        /* if the total time that this activity timer represents is equal to or less than what has already \n           elapsed on the repaired Task SLA we can just subtract this from the total and end this timer */\n\t\tif (secs <= elapsedSecsLeft) {\n\t\t\tthis.debug(\"SLAPercentageTimer->onExecute: timer duration has already elapsed in the repaired Task SLA so end it\");\n\t\t\telapsedSecsLeft -= secs;\n\t\t\tworkflow.scratchpad.repairedTaskSLA.businessElapsed = elapsedSecsLeft;\n\t\t\tthis.onTimer();\n\t\t\treturn;\n\t\t}\n\n        /* if we've got to here then we're still repairing but this timer is now going to finish after\n           what has already elapsed so we need to calculate and end date for this timer less any elapsed\n           time that we still haven't accounted for */\n\t\tvar timerSecsLeft = secs - elapsedSecsLeft;\n\n\t\tvar endTime = this._calcEndTime(this._now, timerSecsLeft);\n\t\tvar totalSecsLeft = this._getTotalSecsLeft();\n\n\t\tthis.debug(\"SLAPercentageTimer->onExecute: reached a timer activity that has time left before it can complete - remaining time={0}s, activity end time={1}\", [timerSecsLeft, endTime.getValue()]);\n\n\t\t// this shouldn't happen but just in case we've got no time left on this timer end it now\n\t\tif (totalSecsLeft === 0) {\n\t\t\t// Refactored to return faster as we don't need to schedule anything here....\n\t\t\tthis.onTimer();\n\t\t\treturn;\n\t\t}\n\n\t\tvar sched = this._getScheduleOnce(totalSecsLeft, endTime);\n\t\tsched.schedule();\n\t},\n\n\t// @Override\n\tonTimer: function() {\n\t\tactivity.state = this.STATE_FINISHED;\n\t\tactivity.result = workflow.scratchpad.repairMode === 'true' ? this.RESULT_REPAIR : this.RESULT_NORMAL;\n\n\t\t/* Refresh the timings in the Task SLA record when a timer expires (but only for non-repair mode)\n\t\t   and only if there are no unprocessed records in the \"sla_async_queue\" */\n\t\tif (workflow.scratchpad.repairMode !== 'true' && !(new SLAAsyncQueue().isTaskQueued(current.getValue(\"task\"))))\n\t\t\tSLACalculatorNG.calculateSLA(current, true /* skip update */, undefined, this.slaDefGr);\n\n\t\tthis.debug('SLA Percentage Timer complete (endTime ' + activity.scratchpad.endTime + ')');\n\t\tthis.debug('SLA Percentage Timer exiting in ' + activity.result + \" mode\");\n\n\t\tvar retroSecs = this._getRetroSecs();\n\n\t\t// if we had any trigger delay between our expected end time and now\n\t\t// add that to retroactive time to be used up by the next Timer\n\t\tif (retroSecs > 0)\n\t\t\treturn;\n\n\t\tvar triggerDelay = this._getTriggerDelay();\n\t\tif (triggerDelay > 0)\n\t\t\tretroSecs += triggerDelay;\n\n\t\tthis._saveRetroSecs(retroSecs);\n\t},\n\n\tonRepairModeFalse: function() {\n\t\tthis.debug('SLA Percentage Timer - turning off repair mode');\n\t\tworkflow.scratchpad.repairMode = 'false';\n\t},\n\t\n\t// @Override\n\t_getTotalSecsLeft: function() {\n\t\t// see if there is any retroactive time we need to use up (can be +ve or -ve)\n\t\t// (the retroactive time to be consumed doesn't take any schedule into account)\n\t\tvar usedSecs = this._getRetroSecs();\n\n\t\t// and subtract the actual total seconds from the retroactive seconds still to be used\n\t\treturn this._updateRetroSecs(usedSecs, this._totalSecs);\n\t},\n\n\t_getRetroSecs: function() {\n\t\tvar retroSecs = parseInt(workflow.scratchpad.retroactiveSecsLeft, 10);\n\t\tif (isNaN(retroSecs))\n\t\t\tretroSecs = 0;\n\t\tthis.debug('workflow.scratchpad.retroactiveSecsLeft=' + retroSecs);\n\t\treturn retroSecs;\n\t},\n\n\t_saveRetroSecs: function(secs) {\n\t\tthis.debug('workflow.scratchpad.retroactiveSecsLeft -> ' + secs);\n\t\tworkflow.scratchpad.retroactiveSecsLeft = secs;\n\t\t// stores the time the delay computations are based on\n\t\tworkflow.scratchpad.baseDelayTime = this._now;\n\t},\n\n\t// calculate remaining time, after subtracting usedSecs from totalSecs\n\t// updates workflow.scratchpad.retroactiveSecsLeft, \n\t// - which will be > 0 on return, if there is more time still to be used than was available\n\t//   and 0, if all the time has been used up\n\t_updateRetroSecs: function(usedSecs, totalSecs) {\n\t\tthis.debug('usedSecs=' + usedSecs + ', totalSecs=' + totalSecs);\n\t\tvar result = this._consumeSecs(usedSecs, totalSecs);\n\t\tvar unusedSecs = result[0];\n\t\tvar remainingSecs = result[1];\n\t\tthis.debug(\"Remaining/retroactive time: \" + unusedSecs + \" seconds\");\n\n\t\tthis._saveRetroSecs(unusedSecs);\n\t\treturn remainingSecs; // time remaining\n\t},\n\n\t// deduce the \"real\" start time of the Timer\n\t// based upon any retroactive seconds to be accomodated,\n\t// @Override\n\t_calcTimerStartTime: function(now) {\n\t\tvar timerStartTime = TimerActivityHandler.prototype._calcTimerStartTime.call(this, now);\n\t\tvar usedSecs = this._getRetroSecs();\n\t\tvar startDelay = this._getStartDelay(now);\n\t\tif (usedSecs !== 0 || startDelay !== 0)\n\t\t\ttimerStartTime.addSeconds(0 - (usedSecs + startDelay));\n\n\t\tactivity.scratchpad.timerStartTime = timerStartTime.getValue();\n\t\tthis.debug('timerStartTime=' + timerStartTime);\n\t\treturn timerStartTime;\n\t},\n\n\t// deduce the start time basis for the durations to be calculated\n\t// (this may be the start time of the Workflow, or the start time of this Timer) \n\t// based upon any retroactive seconds to be accomodated, \n\t// and any previously stored real start time (essential for subsequent % of Relative Durations)\n\t// @Override\n\t_calcDurationBaseTime: function(now) {\n\t\tthis.debug(\"now=\" + now);\n\t\tthis.debug(\"workflow.scratchpad.realStartTime=\" + workflow.scratchpad.realStartTime);\n\t\tvar usedSecs = this._getRetroSecs();\n\t\tvar baseTime = new GlideDateTime(now);\n\n\t\tif (workflow.scratchpad.realStartTime)\n\t\t\tbaseTime = new GlideDateTime(workflow.scratchpad.realStartTime);\n\t\telse if (activity.scratchpad.timerStartTime)\n\t\t\tbaseTime = new GlideDateTime(activity.scratchpad.timerStartTime);\n\t\telse if (usedSecs !== 0)\n\t\t\tbaseTime.addSeconds(0 - usedSecs);\n\n\t\tworkflow.scratchpad.realStartTime = baseTime.getValue();\n\t\tthis.debug('baseTime=' + baseTime);\n\t\treturn baseTime;\n\t},\n\n\t// consume usedSecs, from secs\n\t// returns either:\n\t// - [ 0, secs ], if usedSecs == 0\n\t// - [ unused seconds, 0 ], if usedSecs > secs\n\t// - [ 0, time remaining ], if usedSecs <= secs\n\t_consumeSecs: function(usedSecs, secs) {\n\t\tvar consumedSecs = 0;\n\t\tif (usedSecs !== 0) {\n\t\t\tif (usedSecs > secs) {\n\t\t\t\tusedSecs -= secs;\n\t\t\t\tconsumedSecs += secs;\n\t\t\t\tsecs = 0;\n\t\t\t} else {\n\t\t\t\tsecs -= usedSecs;\n\t\t\t\tconsumedSecs += usedSecs;\n\t\t\t\tusedSecs = 0;\n\t\t\t}\n\t\t}\n\t\treturn [ usedSecs, secs ];\n\t},\n\n\t// deduce any trigger delay\n\t// (the time between when the trigger was meant to fire, and when it did fire)\n\t// returns the delay, in seconds\n\t_getTriggerDelay: function() {\n\t\tvar triggerDelay = 0;\n\t\tif (activity.scratchpad.endTime)\n\t\t\ttriggerDelay = Math.floor((this._now.getNumericValue() - this._getEndTime().getNumericValue()) / 1000);\n\t\tthis.debug('triggerDelay=' + triggerDelay);\n\t\treturn triggerDelay;\n\t},\n\n\t_getStartDelay: function(now) {\n\t\tvar startDelay = 0;\n\t\tif (workflow.scratchpad.baseDelayTime)\n\t\t\tstartDelay = Math.floor((now.getNumericValue() - new GlideDateTime(workflow.scratchpad.baseDelayTime).getNumericValue()) / 1000);\n\t\tthis.debug('startDelay=' + startDelay);\n\t\treturn startDelay;\n\t},\n\n\t// the whole duration of this Timer\n\t_calcTotalDuration: function(start) {\n\t\tvar wd = new SLAWorkflowDuration();\n\t\twd.setStartDateTime(start);\n\t\twd.setWorkflow(context.schedule, context.timezone);\n\t\twd.setActivity(this);\n\t\twd.calculate(activity.vars.__var_record__);\n\t\tvar secs = wd.getSeconds();\n\t\tvar totalSecs = wd.getTotalSeconds();\n\n\t\tthis._seconds = secs;\n\t\tthis._totalSeconds = totalSecs;\n\t\tthis._endTime = wd.getEndDateTime();\n\t\treturn totalSecs;\n\t},\n\n\t// @Override\n\t// for testing purposes only\n\t_setStartDateTime: function(start) {\n\t\tthis.testing = true;\n\t\tthis._now = new GlideDateTime(start.getValue());\n\t\t\n\t\tif (workflow.scratchpad.baseDelayTime)\n\t\t\tworkflow.scratchpad.baseDelayTime = this._now;\n\t},\n\n\t_getSLADefinition: function() {\n\t\t// We need a GlideRecord for the SLA Definition as well to pass to SLACalculatorNG\n\t\tvar slaDefGr = new GlideRecord(\"contract_sla\");\n\t\t// If we haven't already got it on the scratchpad we'll need to fetch it from the database\n\t\tif (!workflow.scratchpad.sla) {\n\t\t\tslaDefGr.addDomainQuery(current);\n\t\t\tif (!slaDefGr.get(current.getValue(\"sla\")))\n\t\t\t\tthis.error('_getSLADefinition: failed to retrieve SLA Definition with sys_id ' + current.getValue(\"sla\"));\n\n\t\t} else {\n\t\t\t// Otherwise we can just set the fields we need in our GlideRecord object to save a database query\n\t\t\tslaDefGr.setValue(\"name\", workflow.scratchpad.sla.name);\n\t\t\tslaDefGr.setValue(\"duration_type\", workflow.scratchpad.sla.duration_type);\n\t\t\tslaDefGr.duration.setDateNumericValue(workflow.scratchpad.sla.duration);\n\t\t\tslaDefGr.setValue(\"relative_duration_works_on\", workflow.scratchpad.sla.relative_duration_works_on);\n\t\t}\n\t\t\n\t\treturn slaDefGr;\n\t},\n\n\t_populateScratchpad: function() {\n\t\tworkflow.scratchpad.sla = {\n\t\t\tname: this.slaDefGr.getValue(\"name\"),\n\t\t\tduration: this.slaDefGr.duration.dateNumericValue(),\n\t\t\tduration_type: this.slaDefGr.getValue(\"duration_type\"),\n\t\t\trelative_duration_works_on: this.slaDefGr.getValue(\"relative_duration_works_on\")\n\t\t};\n\t},\n\n\ttype: 'SLA_Percentage_TimerActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_8e291a23ac1464262f4366bb3182d840","js_class_name":"SLA_Percentage_Timer","name":"SLA Percentage Timer","attributes":"","style":"","category":"Timers","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The SOAP Message activity makes SOAP requests to specified endpoints. You must define the SOAP envelope and endpoint in a SOAP message function record. \r\n\r\nThe result values assigned by this activity are:\r\n*Success: the activity received a successful HTTP response code.\r\n*Failure: the activity failed to receive a successful HTTP response code or a SOAP fault was detected in the returned response.\r\n\r\nKeep in mind:\r\n*This activity can utilize a MID Server if the target endpoint is located behind a firewall where the MID Server can reside, but can also make direct calls to publicly available endpoints without a MID Server.\r\n*If using a MID Server, it must be configured to use SOAP to run this activity.\r\n","sys_updated_on":"2016-04-01 12:26:00","sys_class_name":"wf_activity_definition","sys_id":"9359a22ac0a801975710cd9e7daa8bfe","sys_updated_by":"christen.mitchell","sys_created_on":"2011-04-26 19:48:55","action":"false","sys_name":"SOAP Message","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"jimmy.yuan","table":"global","image":"images/heisenberg_icons/workflow/provider_soap.png","default_width":"","base_provider":"","sys_mod_count":"160","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar SOAP_MessageActivityHandler = Class.create();\nSOAP_MessageActivityHandler.prototype = Object.extendsObject(WebServiceActivityHandler, {\n\n    initialize: function() {\n        WebServiceActivityHandler.prototype.initialize.call(this);\n        this.probe = 'a152c4d40a0a0b5e009be973b683d69e';\n        this.capability = 'SOAP';\n        this.soap_message = '';\n        this.soap_message_function = '';\n        this.soap_endpoint = '';\n        this.executionType = 'soap';\n    },\n\n    _hasOtherErrors: function() {\n        return this._hasSoapFault();\n    },\n\n    _hasSoapFault : function() {\n        var XMLUtil = GlideXMLUtil;\n        var responseXML = XMLUtil.parse(this.response);\n\n\t\tif (!responseXML) {\n\t\t\tvar errorStr = gs.getMessage('There is no response from the target server.  The endpoint may not be reachable.');\n            this.setResultFailed(errorStr);\n            workflow.error(errorStr);\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n        var fault = XMLUtil.getElementByTagName(responseXML, 'SOAP-ENV:Fault');\n\n        if (fault) {\n            var faultString = XMLUtil.getElementValueByTagName(responseXML, 'faultstring');\n            var errorStr = 'SOAP fault detected in response: ' + faultString;\n            this.setResultFailed(errorStr);\n            workflow.error(errorStr);\n            return true;\n        }\n\n        return false;\n    },\n\n    _getHttpStatus: function() {\n    },\n\n    _getMessageObject: function() {\n        return new SOAPMessage(this.web_service_message, this.web_service_message_function);\n    },\n\n    _getOutput: function() {\n        return this.response;\n    },\n\n    _getStatusCode: function() {\n        return this.mo.getHttpStatus();\n    },\n\n    _getValues: function() {\n        var sm = this.js(activity.vars.soap_message);\n        this.web_service_message = '';\n        if (!gs.nil(sm)) {\n            var smgr = new GlideRecord('sys_soap_message');\n            if (smgr.get('sys_id', sm))\n                this.web_service_message = smgr.name;\n        }\n\n        var smf = this.js(activity.vars.soap_message_function);\n        this.web_service_message_function = '';\n        if (!gs.nil(smf)) {\n            var smfgr = new GlideRecord('sys_soap_message_function');\n            if (smfgr.get('sys_id', smf))\n                this.web_service_message_function = smfgr.function_name;\n        }\n\n        this.endpoint = this.js(activity.vars.soap_endpoint);\n        if (gs.nil(this.endpoint) && !gs.nil(smf)) {\n            var smfgr = new GlideRecord('sys_soap_message_function');\n            if (smfgr.get('sys_id', smf))\n                this.endpoint = smfgr.soap_endpoint;            \n        }\n\n        this.variables = this.js(activity.vars.variables);\n        this.use_midserver = this.js(activity.vars.use_midserver);\n\n        if (this.use_midserver != 'false') {\n            var mid = this.js(activity.vars.midserver);\n            this.midserver = '';\n            if (mid) {\n                var midgr = new GlideRecord('ecc_agent');\n                midgr.addQuery('sys_id', mid);\n                midgr.query();\n                if (midgr.next())\n                    this.midserver = midgr.name;\n            }\n        } else if (!gs.nil('' + smfgr.use_mid_server)) {\n            this.use_midserver = 'true';\n            this.midserver = '' + smfgr.use_mid_server.name;\n        }\n    },\n\n    _launch: function() {\n        return this.mo.post();\n    },\n\n    _processValues: function() {\n        if (JSUtil.nil(this.web_service_message) && !JSUtil.nil(this.soap_message)) {\n            workflow.debug('Setting soap message: ' + this.soap_message);\n            this.web_service_message = this.soap_message;\n        }\n    \n        if (JSUtil.nil(this.web_service_message_function) && !JSUtil.nil(this.soap_message_function)) {\n            workflow.debug('Setting soap message function: ' + this.soap_message_function);\n            this.web_service_message_function = this.soap_message_function;\n        }\n\n        if (JSUtil.nil(this.endpoint) && !JSUtil.nil(this.soap_endpoint)) {\n            workflow.debug('Setting endpoint: ' + this.soap_endpoint);\n            this.endpoint = this.soap_endpoint;\n        }\n    },\n\n    _setEndpoint: function() {\n        this.mo.setSoapEndPoint(this.endpoint);\n    },\n\n    type: 'SOAP_MessageActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_9359a22ac0a801975710cd9e7daa8bfe","js_class_name":"SOAP_Message","name":"SOAP Message","attributes":"","style":"","category":"Deprecated","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The If activity checks a condition or script to determine which transition a workflow should follow, either 'Yes' or 'No'.\r\n\r\nUse this activity to transition workflow to a specific path based on result of condition.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the result value of the activity is the final result of the condition or script specified. Possible result values are: \r\n*Yes \r\n*No\r\n\r\nKeep in mind: \r\n*If you specify both the 'Condition' and the advanced 'Script', both conditions must evaluate to true for the workflow to take the 'Yes' transition.","sys_updated_on":"2014-10-22 17:26:36","sys_class_name":"wf_activity_definition","sys_id":"98f621ca0a0a0b5900f7c291f5e45a0e","sys_updated_by":"harry.nelson","sys_created_on":"2008-06-17 23:57:57","action":"false","sys_name":"If","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/if.png","default_width":"","base_provider":"","sys_mod_count":"29","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar IfActivityHandler = Class.create();\nIfActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      if (this._checkQueryCondition() && this._checkScriptCondition())\n         activity.result = 'yes';\n      else\n         activity.result = 'no';\n   },\n   \n   // Filter condition matching\n   _checkQueryCondition: function() {\n      try {\n         // is there a filter to match?\n         var condition = activity.vars.condition + '';\n         if (!condition)\n            return true;\n         \n         var match = GlideFilter.checkRecord(current, condition);\n         return match === true;\n         \n      } catch (ex) {\n         this.error(ex);\n         activity.state = \"faulted\";\n      }\n      return false;\n   },\n   \n   // Script condition matching\n   _checkScriptCondition: function() {\n      // is there a script?\n      if (!activity.vars.advanced)\n         return true;\n      \n      var script = activity.vars.script + '';\n      if (!script)\n         return true;\n\n      var answer = this.runScript(script);\n      return ((answer === true) || (answer === 'yes'));\n   },\n   \n   type: 'IfActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_98f621ca0a0a0b5900f7c291f5e45a0e","js_class_name":"If","name":"If","attributes":"","style":"","category":"Conditions","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Return Value activity enables a subflow to return data to its parent flow.\r\n\r\nThis activity adds the data from the 'value' variable to the return_value field of this context. The workflow activity that runs the subflow includes a 'Map return value to' variable that defines where the parent flow stores the returned data in finds in the subflows wf_context.return_value field.\r\n\r\nThe returned data can be scalar data, a JavaScript object that can be expressed as a string, or an expression that evaluates to a JavaScript object that can be expressed as a string.\r\n\r\nKeep in mind:\r\n*Subsequent Return Value activities within a single subflow overwrite the data of the previous Return Value activity. Use only one Return Value activity per independent transition path.","sys_updated_on":"2014-10-22 17:30:34","sys_class_name":"wf_activity_definition","sys_id":"9b2dba250a0a0b6400396e341ba9d9a4","sys_updated_by":"harry.nelson","sys_created_on":"2009-09-08 19:42:28","action":"false","sys_name":"Return Value","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"images/heisenberg_icons/workflow/return_value.png","default_width":"","base_provider":"","sys_mod_count":"26","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Return_ValueActivityHandler = Class.create();\nReturn_ValueActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      var value = activity.vars.value + '';\n      value = this.js(value);\n      workflow.scratchpad.__return__ = value; // legacy return value location\n      context.return_value.__return__ = value;\n   },\n\n   type: 'Return_ValueActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_9b2dba250a0a0b6400396e341ba9d9a4","js_class_name":"Return_Value","name":"Return Value","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Makes On-Call escalation log inactive provided the escalation log id","sys_updated_on":"2020-01-09 05:37:14","sys_class_name":"wf_activity_definition","sys_id":"9cb0d080c75200100c54885827c260c6","sys_updated_by":"admin","sys_created_on":"2020-01-07 08:33:45","action":"false","sys_name":"On-Call: Log Escalation End","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"6","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Log_Escalation_EndActivityHandler = Class.create();\nOn_Call__Log_Escalation_EndActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n\t/**\n     * Set activity to error\n     *\n     * @param message\n     */\n    throwError: function(message) {\n        this.error(message, \"\");\n        this.setResultFaulted(message);\n    },\n\t\n\tonExecute: function() {\n\t\tvar escalationId = '';\n\n\t\ttry {\n\t\t\tescalationId = this.runScript(activity.vars.escalation_id + '');\n\t\t} catch (e) {\n\t\t\tthis.throwError(e.message);\n\t\t\tactivity.state = 'faulted';\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tvar ocEscalationUtil = new OnCallEscalationUtil();\n\t\tocEscalationUtil.logEscalationEnd(escalationId);\n\t\t\n\t\tactivity.state = 'finished';\n\t},\n\n   type: 'On_Call__Log_Escalation_EndActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_9cb0d080c75200100c54885827c260c6","js_class_name":"On_Call__Log_Escalation_End","name":"On-Call: Log Escalation End","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Creates On-Call escalation level record provided shift,level details","sys_updated_on":"2020-02-17 08:09:28","sys_class_name":"wf_activity_definition","sys_id":"9d86959bc7be00100c54885827c26066","sys_updated_by":"admin","sys_created_on":"2020-02-11 12:30:30","action":"false","sys_name":"On-Call: Log Escalation Level","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"3","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Log_Escalation_LevelActivityHandler = Class.create();\nOn_Call__Log_Escalation_LevelActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    onExecute: function() {\n        // implement activity definition code here\n        var escalationId = '';\n        var rotaId = '';\n        var level = '';\n        var escalatee = {};\n        var catchAll;\n\n        try {\n            escalationId = this.runScript(activity.vars.escalation_id + '');\n            rotaId = this.runScript(activity.vars.rota_id + '');\n            level = this.runScript(activity.vars.level + '');\n            escalatee = this.runScript(activity.vars.escalatee + '');\n            catchAll = activity.vars.catch_all;\n        } catch (e) {\n            this.throwError(e.message);\n            activity.state = 'faulted';\n            return;\n        }\n\n        var ocEscalationUtil = new OnCallEscalationUtil();\n        var result = ocEscalationUtil.logEscalationLevel(escalationId, rotaId, level, escalatee, catchAll);\n\n        if (result && result.escalationLogEnabled) {\n            if (result.success) {\n                workflow.scratchpad.escalationLevelId = result.logGr.getUniqueValue();\n            } else {\n                var msg = '';\n                if (result.error)\n                    msg = result.error.msg;\n                return this.throwError(msg);\n            }\n        }\n\n        activity.state = 'finished';\n\n    },\n\n    type: 'On_Call__Log_Escalation_LevelActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_9d86959bc7be00100c54885827c26066","js_class_name":"On_Call__Log_Escalation_Level","name":"On-Call: Log Escalation Level","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"Invoke a subordinate workflow (sub-flow) by sys_id - typically used when the subflow is a result of a lookup\r\n\r\nThe 'workflow' variable specifies the sys_id of the subflow to invoke.","sys_updated_on":"2014-10-22 18:00:16","sys_class_name":"wf_activity_definition","sys_id":"9f46fb44c0a8016400e10261db653ecd","sys_updated_by":"harry.nelson","sys_created_on":"2008-01-22 02:15:04","action":"false","sys_name":"Subflow by ID","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/workflow.png","default_width":"","base_provider":"","sys_mod_count":"17","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nworkflow.includeActivityDefinition('Subflow');\n\nvar Subflow_by_IDActivityHandler = Class.create();\nSubflow_by_IDActivityHandler.prototype = Object.extendsObject(SubflowActivityHandler, {\n   \n   initialize: function() {\n      SubflowActivityHandler.prototype.initialize.call(this);\n   },\n\n   _getSubflowID: function() {\n      return workflow.eval(activity.vars.workflow_script);\n   },\n \n   type: 'Subflow_by_IDActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_9f46fb44c0a8016400e10261db653ecd","js_class_name":"Subflow_by_ID","name":"Subflow by ID","attributes":"","style":"","category":"Deprecated","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Create Task activity creates a record on any of the tables that extends the Task table.\r\n \r\nUse this activity to create a task for a user to complete.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are: \r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n \r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the final 'State' value of the task record determines the result value for the Create Task activity. Possible result values are:  \r\n*Closed complete\r\n*Closed incomplete\r\n*Closed skipped\r\n*Deleted\r\n*Cancelled\r\n \r\nKeep in mind: \r\n*Only workflows that run on the Task table, or a table that extends Task, can use this activity.","sys_updated_on":"2017-03-28 22:15:15","sys_class_name":"wf_activity_definition","sys_id":"9f4d1be5c0a8016400043d34ce066316","sys_updated_by":"nisha.ilame","sys_created_on":"2008-01-22 02:21:46","action":"false","sys_name":"Create Task","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"task","image":"images/heisenberg_icons/workflow/task_add.png","default_width":"","base_provider":"","sys_mod_count":"203","sys_tags":"","script":"/**\n * Workflow activity used to create and manage tasks\n */\nvar Create_TaskActivityHandler = Class.create();\n\nCreate_TaskActivityHandler.prototype = Object.extendsObject(WFCreateTaskActivityUtils, {\n    \n    initialize: function() {\n        WFCreateTaskActivityUtils.prototype.initialize.call(this);\n    },\n    \n    onExecute: function() {\n        var taskID = this.execute(activity);\n\n        this._removeGenerateObj(activity.activity.toString());\n        activity.scratchpad.taskID = taskID;\n        \n        // Do we want to wait on the task?\n        if (activity.vars.wait_for_completion)\n            executing.state = 'waiting';\n\n        this.autoClose(taskID);\n    },\n    \n    // will evaluate task after insert in case\n    // logic in advanced scripting has closed the current task\n    // and set the executing state to finished so the Activity Manager will\n    // move the workflow along.\n    autoClose: function(taskID) {\n        var gr = new GlideRecord('task');\n        if (!taskID || !gr.get(taskID)) {\n            executing.state = 'finished';\n            executing.result = 'deleted';\n        } else if (!gr.active) {\n            executing.state = 'finished';\n            executing.result = gr.state;\n        }\n    },\n    \n    // The task has changed, see if the task is done\n    onUpdate: function() {\n        // check for completion\n        var gr = new GlideRecord('task');\n        if (!gr.get(activity.scratchpad.taskID)) {\n            executing.state = 'finished';\n            executing.result = 'deleted';\n            return;\n        }\n        \n        if (!gr.active) {\n            executing.state = 'finished';\n            executing.result = gr.state;\n        }\n    },\n    \n    onCancel: function() {\n\t\tthis._setTaskState(activity.scratchpad.taskID, '4'); // mark task as Closed Incomplete\n        executing.state = 'cancelled';\n        executing.result = 'cancelled';\n    },\n    \n    /**\n     * Create the task as a forward-looking process in which we just create, but do\n     * not process the task. This allows the task to be generated up front before\n     * the workflow runs such that the task is visible prior to being active (ie,\n     * open).\n     */\n    _generate: function(order, startAt, noCreateFlag) {\n        var id = this._createTask('-5', order, startAt, noCreateFlag);\n        var genObj = {};\n        genObj.taskID = id;\n        genObj.duration = this.duration;\n        return genObj;\n    },\n\n    type: 'Create_TaskActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_9f4d1be5c0a8016400043d34ce066316","js_class_name":"Create_Task","name":"Create Task","attributes":"generate=task","style":"","category":"Tasks","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Create Event activity sends a system event to the event processor. Usually this is used to send an e-mail.\r\n\r\nSee http://docs.servicenow.com/?context=Events_and_Email_Notification For details on system events.\r\n\r\nThe activity state tells the workflow engine how to handle the executing record. \r\nPossible state values are:\r\n* finished:\r\n\r\nPlease be aware that: \r\n* The system event is registered. There is no guarantee on when the event will be executed although typically it will execute within one minute.\r\n","sys_updated_on":"2014-10-22 23:22:29","sys_class_name":"wf_activity_definition","sys_id":"9f680b92c0a801640026553f665b429f","sys_updated_by":"cameron.ellis","sys_created_on":"2008-01-22 02:54:36","action":"false","sys_name":"Create Event","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/event_add.png","default_width":"","base_provider":"","sys_mod_count":"13","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Create_EventActivityHandler = Class.create();\nCreate_EventActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      // Get parm1 and parm2 from the parameter script\n      var p1 = this.runScript(activity.vars.event_param1);\n      var p2 = this.runScript(activity.vars.event_param2);\n\n      gs.eventQueue(activity.vars.event_name.getDisplayValue(), current, p1, p2);\n   },\n\n   type: 'Create_EventActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_9f680b92c0a801640026553f665b429f","js_class_name":"Create_Event","name":"Create Event","attributes":"","style":"","category":"Notifications","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Run Workflow activity runs another workflow as a subflow.\r\n\r\nUse this activity run a sub-flow if you do not know the name of the sub-flow to run until run-time.\r\n\r\nThe activity state tells the workflow engine how to handle the executing record. Possible state values are:\r\n*Waiting: the workflow engine is waiting for the sub-flow to finish.\r\n*Cancelled: the activity has been cancelled by the workflow.\r\n*Finished: the sub-flow has completed and this activity is finished.\r\n*faulted: some kind of error occured such as the sub-flow does not exist, or a script error.\r\n\r\nThe result values assigned by this activity are: \r\n*Success: the sub-flow ran correctly and the sub-flow did not return a result.\r\n*: the result is set to the value of the sub-flow result, if any.\r\n*Finished: the activity is finished with an error (see state).","sys_updated_on":"2014-10-23 21:25:05","sys_class_name":"wf_activity_definition","sys_id":"a1e18d75c33101008de24a3c5bba8fe4","sys_updated_by":"harry.nelson","sys_created_on":"2013-06-06 23:51:48","action":"false","sys_name":"Run Workflow","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"rick.crawford","table":"global","image":"images/heisenberg_icons/workflow/workflow.png","default_width":"","base_provider":"","sys_mod_count":"40","sys_tags":"","script":"// Run Workflow activity definition handler class \nworkflow.includeActivityDefinition(\"Workflow\");\n\nvar Run_WorkflowActivityHandler = Class.create();\nRun_WorkflowActivityHandler.prototype = Object.extendsObject(WorkflowActivityHandler, {\n    initialize: function() {\n       WorkflowActivityHandler.prototype.initialize.call(this);\n    },\n\n    onExecute: function() {\n        // Start the subflow\n        var wfSysId, subflow;\n        var workflowHelper = new Workflow();\n\n        if (activity.vars.advanced && activity.vars.advanced_script) {\n            try {\n\t\t\t\tvar ans = this.runScript(activity.vars.advanced_script);\n\t\t\t} catch (ex) {\n                this._setError(gs.getMessage('Return value \"answer\" not set correctly'));\n\t\t\t\tthrow ex;  // propagate exception up to WorkflowScopedScriptRunner\n\t\t\t}\n            if (!ans.workflow) {\n                this._setError(gs.getMessage('Return value \"answer\" not set correctly'));\n                return;\n            }\n            wfSysId = workflowHelper.getWorkflowFromName(ans.workflow);\n            if (!wfSysId) {\n                this._setError(gs.getMessage(\"Can't find workflow '\" + ans.workflow + \"'\"));\n                return;\n            }\n            subflow = workflow.startSubflow(wfSysId, current, ans.inputs, activity.sys_id+'');\n\n        } else {\n            // process subflows based on condition matrix\n            this._setError(gs.getMessage(\"Non-advanced launching of workflow not implemented yet.\"));\n            return;\n        }\n      \n      \n        if (!subflow) {\n            this._setError(gs.getMessage('Subflow did not launch (wf_workflow.sys_id=' + wfSysId + ')'));\n        } else {\n            activity.scratchpad.subflowId = subflow.sys_id.toString();\n            activity.state = 'waiting';\n        }\n    },\n\n  \t_getMapTo: function() {\n  \t\treturn new String(activity.vars.return_value);\n  \t},\n   \n   _getSubflowVariables: function() {\n       var vars = {};\n\n       var wfi = activity.vars.workflow_instance;\n       var varNames = wfi.workflow.vars.getVariableNames();\n\n       for(var i = 0; i < varNames.length; i++) {\n           var name = varNames[i];\n           var value = wfi.workflow.vars.getVariableValue(name);\n           value = this.js(value);\n           vars[name] = value;\n       }\n\n       return vars;\n   },\n   \n    _setError: function(reason) {\n       workflow.error(reason);\n       activity.state = 'faulted';\n       activity.fault_description = reason;\n       activity.result = 'finished';\n\n    },\n\n    type: 'Run_WorkflowActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_a1e18d75c33101008de24a3c5bba8fe4","js_class_name":"Run_Workflow","name":"Run Workflow","attributes":"","style":"","category":"deprecated","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Branch activity splits the workflow into multiple transition paths from a single activity.\r\n\r\nThe activity provides a single condition of 'Always'. Authors may draw multiple transitions from this condition.  Optionally, add conditions to selectively transition to one or more activities.\r\n\r\nKeep in mind: \r\n*You can draw multiple transitions from a single activity to subsequent activities. A workflow designed in this way behaves the same as a workflow that uses the Branch activity. Using Branch explicitly shows the workflow designer's intent and can simplify later workflow development.\r\n*Branching can affect the behavior of Rollback activities. See Selecting a Rollback Activity on the ServiceNow Wiki for more information.","sys_updated_on":"2017-02-07 22:39:33","sys_class_name":"wf_activity_definition","sys_id":"a246173ac0a8016400a47421cd41e42c","sys_updated_by":"cmitchell","sys_created_on":"2008-01-22 16:14:23","action":"false","sys_name":"Branch","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/branch.png","default_width":"","base_provider":"","sys_mod_count":"11","sys_tags":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_a246173ac0a8016400a47421cd41e42c","js_class_name":"Branch","name":"Branch","attributes":"branch=true","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Attachment Note activity adds an attachment to the current record.\r\n\r\nUse this activity to add an attachment, and a comment or work note referring to the attachment, to the current record.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Finished: the activity added the attachment to the record.","sys_updated_on":"2014-10-23 21:17:01","sys_class_name":"wf_activity_definition","sys_id":"a2cd53480a000105007187e0b5c6bfb7","sys_updated_by":"harry.nelson","sys_created_on":"2009-09-10 07:15:27","action":"false","sys_name":"Attachment Note","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"bow","table":"task","image":"images/heisenberg_icons/workflow/add_attachment.png","default_width":"","base_provider":"","sys_mod_count":"44","sys_tags":"","script":"/**\n* Add an attachment to the current record and add a note to comments or work_notes field.\n*\n*/\nvar Attachment_NoteActivityHandler = Class.create();\nAttachment_NoteActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    onExecute: function() {\n        var attachmentData = this.js(activity.vars.data + '');\n        var attachmentName = this.js(activity.vars.name + '');\n        var fieldName = \"comments\";\n\n        if (activity.vars.field != \"comments\")\n            fieldName = \"work_notes\";\n\n        var sa = new GlideSysAttachment();\n        var attachmentId = sa.write(current, attachmentName, attachmentData);\n        current[fieldName] = gs.getMessage('Attachment \"{0}\" added by workflow \"{1}\".', [attachmentName, context.name]);\n    },\n\n    type: 'Attachment_NoteActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_a2cd53480a000105007187e0b5c6bfb7","js_class_name":"Attachment_Note","name":"Attachment Note","attributes":"","style":"","category":"Tasks","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Creates On-Call escalation communication record provided shift,level, attempt and communication details","sys_updated_on":"2020-02-17 08:13:29","sys_class_name":"wf_activity_definition","sys_id":"bc81ce16c70240100c54885827c26063","sys_updated_by":"admin","sys_created_on":"2020-01-02 07:05:09","action":"false","sys_name":"On-Call: Log Escalation Communication","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"45","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Log_Escalation_CommunicationActivityHandler = Class.create();\nOn_Call__Log_Escalation_CommunicationActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    /**\n     * Set activity to error\n     *\n     * @param message\n     */\n    throwError: function(message) {\n        this.error(message, \"\");\n        this.setResultFaulted(message);\n    },\n\n    onExecute: function() {\n        // implement activity definition code here\n        var escalationId = '';\n        var rotaId = '';\n\t\tvar level = '';\n\t\tvar contactAttempt = '';\n\t\tvar escalateeType = '';\n\t\tvar escalateeId = '';\n\t\tvar communicationType = '';\n\t\tvar communicationValue = '';\n\t\tvar status = '';\n\t\tvar escalatee = {};\n\t\tvar catchAll;\n\n        try {\n            escalationId = this.runScript(activity.vars.escalation_id + '');\n\t\t\trotaId = this.runScript(activity.vars.rota_id + '');\n\t\t\tlevel = this.runScript(activity.vars.level + '');\n\t\t\tcontactAttempt = this.runScript(activity.vars.contact_attempt + '');\n\t\t\tescalateeType = this.runScript(activity.vars.escalatee_type + '');\n\t\t\tescalateeId = this.runScript(activity.vars.escalatee_id + '');\n\t\t\tcommunicationType = this.runScript(activity.vars.communication_type + '');\n\t\t\tcommunicationValue = this.runScript(activity.vars.communication_value + '');\n\t\t\tstatus = this.runScript(activity.vars.status + '');\n\t\t\tescalatee = this.runScript(activity.vars.escalatee + '');\n\t\t\tcatchAll = activity.vars.catch_all;\n        } catch (e) {\n            this.throwError(e.message);\n            activity.state = 'faulted';\n            return;\n        }\n\t\t\n\t\tvar ocEscalationUtil = new OnCallEscalationUtil();\n\t\tvar result = ocEscalationUtil.logEscalationCommunication(escalationId, rotaId, level, contactAttempt, escalateeType, escalateeId, communicationType, communicationValue, status, escalatee, catchAll);\n\t\t\n\t\tif (result && result.escalationLogEnabled) {\n            if (result.error) {\n                var msg = result.error.msg || '';\n                return this.throwError(msg);\n            }\n        }\n\t\t\n\t\tactivity.state = 'finished';\n    },\n\n    type: 'On_Call__Log_Escalation_CommunicationActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_bc81ce16c70240100c54885827c26063","js_class_name":"On_Call__Log_Escalation_Communication","name":"On-Call: Log Escalation Communication","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Rollback To activity transitions to an earlier activity. The Rollback To activity updates all activities that executed between the Rollback To activity and the transitioned to activity. \r\n \r\nUse this activity to revert the workflow to an earlier activity. Approvals are reset to 'Requested', and tasks are reset to 'Open' or 'Pending'.\r\n\r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'run' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n \r\nKeep in mind: \r\n*The Rollback To activity does not reset Manual Approval activities. When a workflow moves through a Manual Approval activity again, the workflow automatically sets the approval state based on the existing value. Placing a Manual Approval activity directly before a Rollback To activity causes a loop.","sys_updated_on":"2014-10-23 16:37:02","sys_class_name":"wf_activity_definition","sys_id":"bd5711773b230000dada82c09ccf3d0d","sys_updated_by":"harry.nelson","sys_created_on":"2011-07-05 21:58:36","action":"false","sys_name":"Rollback To","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"Frankie.Thompson","table":"global","image":"images/heisenberg_icons/workflow/roll_back_to.png","default_width":"","base_provider":"","sys_mod_count":"18","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Rollback_ToActivityHandler = Class.create();\nRollback_ToActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      workflow.debug('Rollback Complete for ' + current.sys_id );\n\n     if (previous_activity && previous_activity.activity.sys_id){\n\n          var model = new WorkflowModelManager(activity.context);\n          model.getExecutedHistory();\n          model.rollbackTransitionHistory(previous_activity.sys_id, activity.activity.sys_id.toString(), activity.activity_index);\n          // set any rollback comment\n          if (activity.vars.comment_field && activity.vars.comment) \n              current.getElement(activity.vars.comment_field.toString()).setDisplayValue(activity.vars.comment.toString());\n      \n\t\t  // signal engine that roll-back finished.\n\t\t  workflow.onRollbackComplete(activity);\n          workflow.debug('Rollback Complete for ' + current.sys_id );\n     }\n     \n   },\n\n   type: 'Rollback_ToActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_bd5711773b230000dada82c09ccf3d0d","js_class_name":"Rollback_To","name":"Rollback To","attributes":"","style":"","category":"Approvals","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Finds the corresponding communication record and set the response","sys_updated_on":"2024-05-31 15:25:33","sys_class_name":"wf_activity_definition","sys_id":"bfa43d03c7e600100c54885827c260cc","sys_updated_by":"admin","sys_created_on":"2020-01-29 09:53:51","action":"false","sys_name":"On-Call: Set Escalatee Response","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"5","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Set_Escalatee_ResponseActivityHandler = Class.create();\nOn_Call__Set_Escalatee_ResponseActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    /**\n     * Set activity to error\n     *\n     * @param message\n     */\n    throwError: function(message) {\n        this.error(message, \"\");\n        this.setResultFaulted(message);\n    },\n\n    onExecute: function() {\n        // implement activity definition code here\n        var table;\n        var source;\n        var communicationType;\n        var communicationValue;\n        var response;\n\t\tvar escalationId;\n\n        try {\n            table = this.runScript(activity.vars.table + '');\n            source = this.runScript(activity.vars.source + '');\n            communicationType = this.runScript(activity.vars.communication_type + '');\n            communicationValue = this.runScript(activity.vars.communication_value + '');\n            response = this.runScript(activity.vars.response + '');\n\t\t\tescalationId = this.runScript(activity.vars.escalation_id + '');\n\n\t\t\tvar workflowUtil = new global.OnCallWorkflowUtilsSNC();\n\t\t\tif (workflowUtil.isDebugLogEnabled()) {\n\t\t\t\tgs.log('[On-Call: Set Escalatee Response] params: ' + JSON.stringify({\n\t\t\t\t\ttable: table,\n\t\t\t\t\tsource: source,\n\t\t\t\t\tcommunicationType: communicationType,\n\t\t\t\t\tresponse: response,\n\t\t\t\t\tescalationId: escalationId,\n\t\t\t\t\tescalationActiveStatus: workflowUtil.logEscalationActiveStatus(escalationId)\n\t\t\t\t}));\n\t\t\t}\n        } catch (e) {\n            this.throwError(e.message);\n            activity.state = 'faulted';\n            return;\n        }\n\n        if (response) {\n            var ocEscalationUtil = new OnCallEscalationUtil();\n            ocEscalationUtil.setCommunicationResponse(table, source, communicationType, communicationValue, response, escalationId);\n        }\n\n        activity.state = 'finished';\n\n    },\n\n    type: 'On_Call__Set_Escalatee_ResponseActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_bfa43d03c7e600100c54885827c260cc","js_class_name":"On_Call__Set_Escalatee_Response","name":"On-Call: Set Escalatee Response","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Log Trace Message activity writes a trace message to the log.\r\n\r\nUse this activity to log the activity name, the event that last invoked the workflow and the table name of the current glide record.\r\n\r\nTo log other details, use the Log Message activity.","sys_updated_on":"2014-10-22 17:27:26","sys_class_name":"wf_activity_definition","sys_id":"c13ed50d7f00000101ac0aa8e373ea73","sys_updated_by":"harry.nelson","sys_created_on":"2007-04-05 10:16:32","action":"false","sys_name":"Log Trace Message","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/logging.png","default_width":"","base_provider":"","sys_mod_count":"13","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Log_Trace_MessageActivityHandler = Class.create();\nLog_Trace_MessageActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      this.info(\"Workflow trace, activity: \" + activity.name);\n      this.info(\"Workflow trace, event: \" + event);\n      this.info(\"Workflow trace, GlideRecord: \" + current.getTableName());\n   },\n   \n   type: 'Log_Trace_MessageActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_c13ed50d7f00000101ac0aa8e373ea73","js_class_name":"Log_Trace_Message","name":"Log Trace Message","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"Begin workflow","sys_updated_on":"2014-12-10 14:11:13","sys_class_name":"wf_activity_definition","sys_id":"c7a5e32c0a0a0b3a002377c24ed8ea76","sys_updated_by":"john.maher","sys_created_on":"2008-01-29 22:24:05","action":"false","sys_name":"Begin","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"chuck.farley","table":"global","image":"images/heisenberg_icons/workflow/play.png","default_width":"","base_provider":"","sys_mod_count":"10","sys_tags":"","script":"","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_c7a5e32c0a0a0b3a002377c24ed8ea76","js_class_name":"Begin","name":"Begin","attributes":"begin=true","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"End workflow","sys_updated_on":"2014-12-10 14:11:13","sys_class_name":"wf_activity_definition","sys_id":"c7a66f7d0a0a0b3a004544a6d2f14076","sys_updated_by":"john.maher","sys_created_on":"2008-01-29 22:24:23","action":"false","sys_name":"End","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"chuck.farley","table":"global","image":"images/heisenberg_icons/workflow/finish.png","default_width":"","base_provider":"","sys_mod_count":"17","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar EndActivityHandler = Class.create();\nEndActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   \tinitialize: function() {\n   \t\tWFActivityHandler.prototype.initialize.call(this);\n   \t},\n\n   \tonExecute: function(eventParms) {\n\t\tworkflow.end();\n   \t},\n   \t\n   \tonCancel: function(eventName, eventParms) {\n   \t\t//End never cancels\n   \t\treturn;\n   \t},\n\n   type: 'EndActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_c7a66f7d0a0a0b3a004544a6d2f14076","js_class_name":"End","name":"End","attributes":"end=true","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The REST Message activity integrates with the System Web Services plugin and allows the workflow to send REST messages and process their responses.\r\n\r\nUse this activity to invoke REST Message functions defined in the web service.\r\n\r\nThis activity may optionally use a MID Server.\r\n","sys_updated_on":"2016-04-01 12:26:00","sys_class_name":"wf_activity_definition","sys_id":"d6eb35df07b31000dada43c0d1021e90","sys_updated_by":"christen.mitchell","sys_created_on":"2012-01-31 17:29:02","action":"false","sys_name":"REST Message","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"jimmy.yuan","table":"global","image":"images/heisenberg_icons/workflow/provider_rest.png","default_width":"","base_provider":"","sys_mod_count":"55","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar REST_MessageActivityHandler = Class.create();\nREST_MessageActivityHandler.prototype = Object.extendsObject(WebServiceActivityHandler, {\n\n    initialize: function() {\n        WebServiceActivityHandler.prototype.initialize.call(this);\n        this.probeId = '5d7d1a9b07d31000dada43c0d1021e99';\n        this.capability = 'REST';\n        this.executionType = 'rest';\n    },\n\n    _getMessageObject: function() {\n        return new RESTMessage(this.web_service_message, this.web_service_message_function);\n    },\n\n    _getOutput: function() {\n        return this.response.getBody();\n    },\n\n    _getStatusCode: function() {\n        return this.response.getStatusCode();\n    },\n\n    _getValues: function() {\n        var rm = this.js(activity.vars.rest_message);\n        this.web_service_message = '';\n        if (!gs.nil(rm)) {\n            var rmgr = new GlideRecord('sys_rest_message');\n            if (rmgr.get('sys_id', rm))\n                this.web_service_message = rmgr.name;\n        }\n\n        var rmf = this.js(activity.vars.rest_message_function);\n        this.web_service_message_function = '';\n        if (!gs.nil(rmf)) {\n            var rmfgr = new GlideRecord('sys_rest_message_fn');\n            if (rmfgr.get('sys_id', rmf))\n                this.web_service_message_function = rmfgr.function_name;\n        }\n\n        var rmfgr;\n        // Wrap this in a try-catch so if the this.js tries substitution on a REST defined\n        // parameter that it can't find as a workflow parameter, we can just take the\n        // literal activity endpoint for substitution later\n        try {\n            this.endpoint = this.js(activity.vars.rest_endpoint);\n        } catch(ex) {\n            this.endpoint = activity.vars.rest_endpoint;\n        }\n        if (gs.nil(this.endpoint) && !gs.nil(rmf)) {\n            rmfgr = new GlideRecord('sys_rest_message_fn');\n            if (rmfgr.get('sys_id', rmf))\n                this.endpoint = rmfgr.rest_endpoint;            \n        }\n\n        this.variables = this.js(activity.vars.variables);\n        this.use_midserver = this.js(activity.vars.use_midserver);\n        \n        if (this.use_midserver != 'false') {\n            var mid = this.js(activity.vars.midserver);\n            this.midserver = '';\n            if (mid) {\n                var midgr = new GlideRecord('ecc_agent');\n                midgr.addQuery('sys_id', mid);\n                midgr.query();\n                if (midgr.next())\n                    this.midserver = midgr.name;\n            }\n        } else if (!gs.nil('' + rmfgr.use_mid_server)) {\n            this.use_midserver = 'true';\n            this.midserver = '' + rmfgr.use_mid_server.name;\n        }\n    },\n\n    _launch: function() {\n        return this.mo.execute();\n    },\n\n    _setEndpoint: function() {\n        this.mo.setRestEndPoint(this.endpoint);\n    },\n\n    type: 'REST_MessageActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_d6eb35df07b31000dada43c0d1021e90","js_class_name":"REST_Message","name":"REST Message","attributes":"","style":"","category":"Deprecated","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Wait for condition activity causes the workflow to wait until the current record matches the specified condition.\r\n \r\nUse this activity to pause a workflow indefinitely until a particular condition is met.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nYou can assign a result value using 'activity.result' from within a script field of the activity. The activity transitions when the result value is 'true'.\r\n \r\nKeep in mind: \r\n*You cannot use this activity to pause a workflow for a specific time period.  ","sys_updated_on":"2014-10-22 17:47:47","sys_class_name":"wf_activity_definition","sys_id":"d93a02ae0a0a0aa30077abad3fdac035","sys_updated_by":"harry.nelson","sys_created_on":"2007-04-10 02:02:09","action":"false","sys_name":"Wait for condition","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/wait_for.png","default_width":"","base_provider":"","sys_mod_count":"33","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Wait_for_conditionActivityHandler = Class.create();\nWait_for_conditionActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      // stay waiting until true or fault\n      activity.state = \"waiting\";\n      this.onUpdate();\n   },\n   \n   onUpdate: function() {\n      if (this._checkQueryCondition() && this._checkScriptCondition())\n         activity.state = \"finished\";\n   },\n   \n   // Filter condition matching\n   _checkQueryCondition: function() {\n      try {\n         // is there a filter to match?\n         var condition = activity.vars.wait_for_condition + '';\n         if (!condition)\n            return true;\n         \n         var match = GlideFilter.checkRecord(current, condition);\n         return match === true;\n         \n      } catch (ex) {\n         this.error(ex);\n         activity.state = \"faulted\";\n      }\n      return false;\n   },\n   \n   // Script condition matching\n   _checkScriptCondition: function() {\n      // is there a script?\n      var condition = activity.vars.script_condition + '';\n      if (!condition)\n         return true;\n      \n      var answer = this.runScript(condition);\n      return (answer === true);\n   },\n   \n   type: 'Wait_for_conditionActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_d93a02ae0a0a0aa30077abad3fdac035","js_class_name":"Wait_for_condition","name":"Wait for condition","attributes":"","style":"","category":"Conditions","sys_policy":""},{"default_height":"","version_container_id":"","access":"package_private","description":"The Run Script activity runs any script.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n\r\nKeep in mind: \r\n*ServiceNow automatically updates the current record. Do not call current.update() in your script.","sys_updated_on":"2015-07-06 21:50:13","sys_class_name":"wf_activity_definition","sys_id":"db8c65aec0a8016501d00259bc7203a4","sys_updated_by":"russ.sarbora","sys_created_on":"2007-04-10 12:51:23","action":"false","sys_name":"Run Script","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/play_script.png","default_width":"","base_provider":"","sys_mod_count":"64","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Run_ScriptActivityHandler = Class.create();\nRun_ScriptActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   \tinitialize: function() {\n    \tWFActivityHandler.prototype.initialize.call(this);\n   \t},\n   \t\n   \tonExecute: function() {\n\t\tworkflow.evaluateString(activity.vars.script, activity.name+\" - advanced script\", this); \n   \t},\n   \t\n  \ttype: 'Run_ScriptActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_db8c65aec0a8016501d00259bc7203a4","js_class_name":"Run_Script","name":"Run Script","attributes":"","style":"","category":"Utilities","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"Invoke a workflow (sub-flow)\r\n\r\nThe 'workflow' variable contains a reference to the subflow to invoke.\r\n","sys_updated_on":"2016-09-01 23:30:09","sys_class_name":"wf_activity_definition","sys_id":"f1afb4010a0a0b2c00d8f55e2372c728","sys_updated_by":"nisha.ilame","sys_created_on":"2009-08-06 21:48:59","action":"false","sys_name":"Workflow","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"glide.maint","table":"global","image":"images/heisenberg_icons/workflow/workflow.png","default_width":"","base_provider":"","sys_mod_count":"57","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar WorkflowActivityHandler = Class.create();\nWorkflowActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n   \n   onExecute: function() {\n      // Start the subflow\n      var subflow = workflow.startSubflow(this._getSubflowID(), current, this._getSubflowVariables(), activity.sys_id+'');\n      if (!subflow) {\n         activity.state = 'faulted';\n         activity.fault_description = gs.getMessage('Subflow not found');\n         activity.result = 'finished';\n      } else {\n         activity.scratchpad.subflowId = subflow.sys_id.toString();\n         activity.state = 'waiting';         \n      }\n   },\n\n   onCancel: function(eventName, eventParms) {\n      activity.state = 'cancelled';\n      activity.result = 'cancelled';\n\n      // cancel the subflow\n      if (!activity.scratchpad.subflowId)\n         return;\n\n      var gr = new GlideRecord('wf_context');\n      if (gr.get(activity.scratchpad.subflowId))\n         new Workflow().cancelContext(gr);\n   },\n   \n   onListener: function(eventName, eventParms) {\n      // workflow state changed - are we done?\n      if (eventParms.isComplete) {\n\t\t if(eventParms.status == 'faulted')\n\t\t\t activity.state = eventParms.status;\n\t\t else\n\t\t\t activity.state = 'finished';\n         activity.result = eventParms.result;\n         if (!activity.result)\n            activity.result = 'success';\n\n         var returnVar = this._getMapTo();\n         if (returnVar.startsWith(\"${\") && returnVar.endsWith(\"}\"))\n             returnVar = returnVar.substring(2, returnVar.length - 1);\n\n         if (returnVar.startsWith(\"workflow.scratchpad.\"))\n             returnVar = returnVar.substring(20);\n\n         if (!gs.nil(returnVar)) {\n             workflow.scratchpad[returnVar] = eventParms.returnValue;\n         }\n      }\n   },\n   \n   \t_getMapTo: function() {\n  \t\treturn new String(activity.vars.workflow_instance.return_map);\n  \t},\n   \n   \n   \t_getSubflowID: function() {\n    \treturn activity.vars.workflow_instance.workflow.sys_id;\n   \t},\n\n   _getSubflowVariables: function() {\n       var vars = {};\n\n       var wfi = activity.vars.workflow_instance;\n       var varNames = wfi.workflow.vars.getVariableNames();\n\n       for(var i = 0; i < varNames.length; i++) {\n           var name = varNames[i];\n           var value = wfi.workflow.vars.getVariableValue(name);\n           value = this.js(value);\n           vars[name] = value;\n       }\n\n       return vars;\n   },\n   \n   type: 'WorkflowActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_f1afb4010a0a0b2c00d8f55e2372c728","js_class_name":"Workflow","name":"Workflow","attributes":"","style":"","category":"","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Creates On-Call escalation attempt record provided shift,level,attempt details","sys_updated_on":"2020-02-17 08:11:01","sys_class_name":"wf_activity_definition","sys_id":"f2df4693c77200100c54885827c260c5","sys_updated_by":"admin","sys_created_on":"2020-02-11 16:40:29","action":"false","sys_name":"On-Call: Log Escalation Attempt","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"4","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar On_Call__Log_Escalation_AttemptActivityHandler = Class.create();\nOn_Call__Log_Escalation_AttemptActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n    initialize: function() {\n        WFActivityHandler.prototype.initialize.call(this);\n    },\n\n    onExecute: function() {\n        // implement activity definition code here\n        var escalationId = '';\n        var rotaId = '';\n        var level = '';\n        var contactAttempt = '';\n\n        try {\n            escalationId = this.runScript(activity.vars.escalation_id + '');\n            rotaId = this.runScript(activity.vars.rota_id + '');\n            level = this.runScript(activity.vars.level + '');\n            contactAttempt = this.runScript(activity.vars.contact_attempt + '');\n        } catch (e) {\n            this.throwError(e.message);\n            activity.state = 'faulted';\n            return;\n        }\n\n        var ocEscalationUtil = new OnCallEscalationUtil();\n        var result = ocEscalationUtil.logEscalationAttempt(escalationId, rotaId, level, contactAttempt);\n\n        if (result && result.escalationLogEnabled) {\n            if (result.success) {\n                workflow.scratchpad.escalationAttemptId = result.logGr.getUniqueValue();\n            } else {\n                var msg = '';\n                if (result.error)\n                    msg = result.error.msg;\n                return this.throwError(msg);\n            }\n        }\n\n        activity.state = 'finished';\n\n    },\n\n    type: 'On_Call__Log_Escalation_AttemptActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_f2df4693c77200100c54885827c260c5","js_class_name":"On_Call__Log_Escalation_Attempt","name":"On-Call: Log Escalation Attempt","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"Adds a worknote to the incident.","sys_updated_on":"2012-12-11 17:59:24","sys_class_name":"wf_activity_definition","sys_id":"f6d7c2480a0a3ca60116d3ec01b40688","sys_updated_by":"rick.crawford","sys_created_on":"2010-09-09 14:14:40","action":"false","sys_name":"Add Worknote","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"tom.dilatush@snc","table":"incident","image":"","default_width":"","base_provider":"","sys_mod_count":"9","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar Add_WorknoteActivityHandler = Class.create();\nAdd_WorknoteActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\n   onExecute: function() {\n      current.work_notes = '' + activity.vars.worknote;\n   },\n\n   type: 'Add_WorknoteActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_f6d7c2480a0a3ca60116d3ec01b40688","js_class_name":"Add_Worknote","name":"Add Worknote","attributes":"","style":"","category":"Tasks","sys_policy":""},{"default_height":"","version_container_id":"","access":"public","description":"Provides ability to manage escalation response record:\r\n1 - Inserts record, for tracking notifications awaiting response. Inputs - workflow context id, user id, table, source\r\n2 - Captures response to the notifications. Inputs - user id, table, source, response\r\n3 - Cleans up records. Inputs - workflow context id","sys_updated_on":"2024-06-05 13:03:05","sys_class_name":"wf_activity_definition","sys_id":"f728efdec73c1010d58f0d8c95c260f2","sys_updated_by":"admin","sys_created_on":"2020-05-18 06:52:20","action":"false","sys_name":"On-Call: Manage Escalation Response","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"admin","table":"global","image":"","default_width":"","base_provider":"","sys_mod_count":"10","sys_tags":"","script":"var On_Call__Manage_Escalation_ResponseActivityHandler = Class.create();\nOn_Call__Manage_Escalation_ResponseActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n\n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n\t\n   /**\n    * Set activity to error\n    *\n    * @param message\n    */\n   throwError: function(message) {\n       this.error(message, \"\");\n       this.setResultFaulted(message);\n   },\n\n   onExecute: function() {\n      // implement activity definition code here\n      var workflowContextId = '';\n      var escalateeId = '';\n      var currentTableName = '';\n      var currentSysId = '';\n      var actionType = '';\n      var responseValue = '';\n      try {\n            workflowContextId = this.runScript(activity.vars.workflow_context + '');\n            escalateeId = this.runScript(activity.vars.escalatee_id + '');\n            currentTableName = this.runScript(activity.vars.table_name + '');\n            currentSysId = this.runScript(activity.vars.current_record_id + '');\n            actionType = this.runScript(activity.vars.action_type + '');\n            responseValue = this.runScript(activity.vars.response + '');\n            var onCallWorkflowUtils = new OnCallWorkflowUtils();\n            if (actionType == 'add') {\n                onCallWorkflowUtils.createEscalationResponse(workflowContextId, currentSysId, currentTableName, escalateeId);\n            }\n            else if (actionType == 'clean') {\n                onCallWorkflowUtils.cleanEscalationResponse(workflowContextId);\n            }\n            else if (actionType == 'update') {\n                onCallWorkflowUtils.updateEscalationResponse(escalateeId, currentTableName, currentSysId, responseValue);\n            }\n\n\t\t\tif (onCallWorkflowUtils.isDebugLogEnabled()) {\n\t\t\t\tgs.log(\"[On-Call: Manage Escalation Response] params: \" + JSON.stringify({\n\t\t\t\t\tescalateeId: escalateeId,\n\t\t\t\t\tcurrentTableName: currentTableName,\n\t\t\t\t\tcurrentSysId: currentSysId,\n\t\t\t\t\tactionType: actionType,\n\t\t\t\t\tresponseValue: responseValue\n\t\t\t\t}), workflowContextId);\n\t\t\t}\n            activity.state = 'finished';\n        } catch (e) {\t\t\n            activity.state = 'faulted';\n            this.throwError(e.message);\n        }\n   },\n\n   type: 'On_Call__Manage_Escalation_ResponseActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/8c6ca73b04352210559073c06a02f754","value":"8c6ca73b04352210559073c06a02f754"},"sys_update_name":"wf_activity_definition_f728efdec73c1010d58f0d8c95c260f2","js_class_name":"On_Call__Manage_Escalation_Response","name":"On-Call: Manage Escalation Response","attributes":"","style":"","category":"On-Call","sys_policy":""},{"default_height":"","version_container_id":"","access":"","description":"The Switch activity performs a check to determine if the value of a passed field or variable is equivalent to one of several case values.\r\n \r\nUse this activity to check a variable or field value against activity conditions for a matching value. When the value passed in this variable or field matches the value defined in the Condition field of the activity condition, the workflow progresses through that activity condition.\r\n \r\nThe activity state tells the workflow engine how to handle the record being executed. Possible state values are:\r\n*Executing: the workflow engine starts the 'onExecute' function of the activity.\r\n*Waiting: the workflow engine ignores the activity until a specific event to restart the activity is fired. \r\n*Finished: the activity finished running. See the result value for the outcome of the activity.\r\n*Cancelled: this activity, or the workflow that contains this activity, was canceled.\r\n*Error: a JavaScript error occurred. Review the logs for error details.\r\n \r\nYou can assign a result value using 'activity.result' from within a script field of the activity. By default, the item selected in the 'Variable' or 'Field' activity variable determines the possible result values.\r\n\r\nKeep in mind: \r\n*The Switch activity works when the selected variable or field is a type of choice list , so that the Switch activity uses all the choices as possible transition paths.  \r\n*You can use service catalog variables as the selected 'Variable'.\r\n*ServiceNow recommends only selecting choice list or reference type fields in the 'Variable' or 'Field' activity variables.","sys_updated_on":"2014-11-08 01:53:46","sys_class_name":"wf_activity_definition","sys_id":"f84eda480a0a3c1800a6fa8c7badf346","sys_updated_by":"harry.nelson","sys_created_on":"2010-04-13 17:55:50","action":"false","sys_name":"Switch","sys_scope":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_scope/global","value":"global"},"sys_created_by":"snc-services","table":"global","image":"images/heisenberg_icons/workflow/switch.png","default_width":"","base_provider":"","sys_mod_count":"9","sys_tags":"","script":"// Workflow activity definition handler class\n//\n// Implement activity definition handling in the onExecute method\n//\n// Implement any event handlers for the activity definition as a method named 'on[event_name]'\n//     For example, to handle the 'cancel' event, implement an 'onCancel' method\n//\n\nvar SwitchActivityHandler = Class.create();\nSwitchActivityHandler.prototype = Object.extendsObject(WFActivityHandler, {\n \n   initialize: function() {\n      WFActivityHandler.prototype.initialize.call(this);\n   },\n \n   onExecute: function() {\n      if(activity.vars.type == \"variable\")\n        activity.result = eval(\"current.variables.\" + activity.vars.item_variable.name);\n      else\n        activity.result = eval(\"current.\" + activity.vars.field);\n   },\n \n   type: 'SwitchActivityHandler'\n});","sys_package":{"link":"https://dev315171.service-now.com/api/now/v1/table/sys_package/41672bfb04b12210559073c06a02f7c6","value":"41672bfb04b12210559073c06a02f7c6"},"sys_update_name":"wf_activity_definition_f84eda480a0a3c1800a6fa8c7badf346","js_class_name":"Switch","name":"Switch","attributes":"","style":"","category":"Conditions","sys_policy":""}]}